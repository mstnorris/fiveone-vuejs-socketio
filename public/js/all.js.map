{"version":3,"sources":["vue.js","vue-resource.js","socket.io.js","app.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACr3QA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACntBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACx1NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"all.js","sourcesContent":["/**\n * Vue.js v0.11.10\n * (c) 2015 Evan You\n * Released under the MIT License.\n */\n\n(function webpackUniversalModuleDefinition(root, factory) {\n    if(typeof exports === 'object' && typeof module === 'object')\n        module.exports = factory();\n    else if(typeof define === 'function' && define.amd)\n        define(factory);\n    else if(typeof exports === 'object')\n        exports[\"Vue\"] = factory();\n    else\n        root[\"Vue\"] = factory();\n})(this, function() {\n    return /******/ (function(modules) { // webpackBootstrap\n        /******/ \t// The module cache\n        /******/ \tvar installedModules = {};\n\n        /******/ \t// The require function\n        /******/ \tfunction __webpack_require__(moduleId) {\n\n            /******/ \t\t// Check if module is in cache\n            /******/ \t\tif(installedModules[moduleId])\n            /******/ \t\t\treturn installedModules[moduleId].exports;\n\n            /******/ \t\t// Create a new module (and put it into the cache)\n            /******/ \t\tvar module = installedModules[moduleId] = {\n                /******/ \t\t\texports: {},\n                /******/ \t\t\tid: moduleId,\n                /******/ \t\t\tloaded: false\n                /******/ \t\t};\n\n            /******/ \t\t// Execute the module function\n            /******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n            /******/ \t\t// Flag the module as loaded\n            /******/ \t\tmodule.loaded = true;\n\n            /******/ \t\t// Return the exports of the module\n            /******/ \t\treturn module.exports;\n            /******/ \t}\n\n\n        /******/ \t// expose the modules object (__webpack_modules__)\n        /******/ \t__webpack_require__.m = modules;\n\n        /******/ \t// expose the module cache\n        /******/ \t__webpack_require__.c = installedModules;\n\n        /******/ \t// __webpack_public_path__\n        /******/ \t__webpack_require__.p = \"\";\n\n        /******/ \t// Load entry module and return exports\n        /******/ \treturn __webpack_require__(0);\n        /******/ })\n        /************************************************************************/\n        /******/ ([\n        /* 0 */\n        /***/ function(module, exports, __webpack_require__) {\n\n            var _ = __webpack_require__(11)\n            var extend = _.extend\n\n            /**\n             * The exposed Vue constructor.\n             *\n             * API conventions:\n             * - public API methods/properties are prefiexed with `$`\n             * - internal methods/properties are prefixed with `_`\n             * - non-prefixed properties are assumed to be proxied user\n             *   data.\n             *\n             * @constructor\n             * @param {Object} [options]\n             * @public\n             */\n\n            function Vue (options) {\n                this._init(options)\n            }\n\n            /**\n             * Mixin global API\n             */\n\n            extend(Vue, __webpack_require__(1))\n\n            /**\n             * Vue and every constructor that extends Vue has an\n             * associated options object, which can be accessed during\n             * compilation steps as `this.constructor.options`.\n             *\n             * These can be seen as the default options of every\n             * Vue instance.\n             */\n\n            Vue.options = {\n                directives  : __webpack_require__(12),\n                filters     : __webpack_require__(13),\n                partials    : {},\n                transitions : {},\n                components  : {}\n            }\n\n            /**\n             * Build up the prototype\n             */\n\n            var p = Vue.prototype\n\n            /**\n             * $data has a setter which does a bunch of\n             * teardown/setup work\n             */\n\n            Object.defineProperty(p, '$data', {\n                get: function () {\n                    return this._data\n                },\n                set: function (newData) {\n                    this._setData(newData)\n                }\n            })\n\n            /**\n             * Mixin internal instance methods\n             */\n\n            extend(p, __webpack_require__(2))\n            extend(p, __webpack_require__(3))\n            extend(p, __webpack_require__(4))\n            extend(p, __webpack_require__(5))\n\n            /**\n             * Mixin public API methods\n             */\n\n            extend(p, __webpack_require__(6))\n            extend(p, __webpack_require__(7))\n            extend(p, __webpack_require__(8))\n            extend(p, __webpack_require__(9))\n            extend(p, __webpack_require__(10))\n\n            module.exports = _.Vue = Vue\n\n            /***/ },\n        /* 1 */\n        /***/ function(module, exports, __webpack_require__) {\n\n            var _ = __webpack_require__(11)\n            var mergeOptions = __webpack_require__(14)\n\n            /**\n             * Expose useful internals\n             */\n\n            exports.util = _\n            exports.nextTick = _.nextTick\n            exports.config = __webpack_require__(15)\n\n            exports.compiler = {\n                compile: __webpack_require__(16),\n                transclude: __webpack_require__(17)\n            }\n\n            exports.parsers = {\n                path: __webpack_require__(18),\n                text: __webpack_require__(19),\n                template: __webpack_require__(20),\n                directive: __webpack_require__(21),\n                expression: __webpack_require__(22)\n            }\n\n            /**\n             * Each instance constructor, including Vue, has a unique\n             * cid. This enables us to create wrapped \"child\n             * constructors\" for prototypal inheritance and cache them.\n             */\n\n            exports.cid = 0\n            var cid = 1\n\n            /**\n             * Class inehritance\n             *\n             * @param {Object} extendOptions\n             */\n\n            exports.extend = function (extendOptions) {\n                extendOptions = extendOptions || {}\n                var Super = this\n                var Sub = createClass(\n                    extendOptions.name ||\n                    Super.options.name ||\n                    'VueComponent'\n                )\n                Sub.prototype = Object.create(Super.prototype)\n                Sub.prototype.constructor = Sub\n                Sub.cid = cid++\n                Sub.options = mergeOptions(\n                    Super.options,\n                    extendOptions\n                )\n                Sub['super'] = Super\n                // allow further extension\n                Sub.extend = Super.extend\n                // create asset registers, so extended classes\n                // can have their private assets too.\n                createAssetRegisters(Sub)\n                return Sub\n            }\n\n            /**\n             * A function that returns a sub-class constructor with the\n             * given name. This gives us much nicer output when\n             * logging instances in the console.\n             *\n             * @param {String} name\n             * @return {Function}\n             */\n\n            function createClass (name) {\n                return new Function(\n                    'return function ' + _.classify(name) +\n                    ' (options) { this._init(options) }'\n                )()\n            }\n\n            /**\n             * Plugin system\n             *\n             * @param {Object} plugin\n             */\n\n            exports.use = function (plugin) {\n                // additional parameters\n                var args = _.toArray(arguments, 1)\n                args.unshift(this)\n                if (typeof plugin.install === 'function') {\n                    plugin.install.apply(plugin, args)\n                } else {\n                    plugin.apply(null, args)\n                }\n                return this\n            }\n\n            /**\n             * Define asset registration methods on a constructor.\n             *\n             * @param {Function} Constructor\n             */\n\n            var assetTypes = [\n                'directive',\n                'filter',\n                'partial',\n                'transition'\n            ]\n\n            function createAssetRegisters (Constructor) {\n\n                /* Asset registration methods share the same signature:\n                 *\n                 * @param {String} id\n                 * @param {*} definition\n                 */\n\n                assetTypes.forEach(function (type) {\n                    Constructor[type] = function (id, definition) {\n                        if (!definition) {\n                            return this.options[type + 's'][id]\n                        } else {\n                            this.options[type + 's'][id] = definition\n                        }\n                    }\n                })\n\n                /**\n                 * Component registration needs to automatically invoke\n                 * Vue.extend on object values.\n                 *\n                 * @param {String} id\n                 * @param {Object|Function} definition\n                 */\n\n                Constructor.component = function (id, definition) {\n                    if (!definition) {\n                        return this.options.components[id]\n                    } else {\n                        if (_.isPlainObject(definition)) {\n                            definition.name = id\n                            definition = _.Vue.extend(definition)\n                        }\n                        this.options.components[id] = definition\n                    }\n                }\n            }\n\n            createAssetRegisters(exports)\n\n            /***/ },\n        /* 2 */\n        /***/ function(module, exports, __webpack_require__) {\n\n            var mergeOptions = __webpack_require__(14)\n\n            /**\n             * The main init sequence. This is called for every\n             * instance, including ones that are created from extended\n             * constructors.\n             *\n             * @param {Object} options - this options object should be\n             *                           the result of merging class\n             *                           options and the options passed\n             *                           in to the constructor.\n             */\n\n            exports._init = function (options) {\n\n                options = options || {}\n\n                this.$el           = null\n                this.$parent       = options._parent\n                this.$root         = options._root || this\n                this.$             = {} // child vm references\n                this.$$            = {} // element references\n                this._watcherList  = [] // all watchers as an array\n                this._watchers     = {} // internal watchers as a hash\n                this._userWatchers = {} // user watchers as a hash\n                this._directives   = [] // all directives\n\n                // a flag to avoid this being observed\n                this._isVue = true\n\n                // events bookkeeping\n                this._events         = {}    // registered callbacks\n                this._eventsCount    = {}    // for $broadcast optimization\n                this._eventCancelled = false // for event cancellation\n\n                // block instance properties\n                this._isBlock     = false\n                this._blockStart  =          // @type {CommentNode}\n                    this._blockEnd    = null     // @type {CommentNode}\n\n                // lifecycle state\n                this._isCompiled  =\n                    this._isDestroyed =\n                        this._isReady     =\n                            this._isAttached  =\n                                this._isBeingDestroyed = false\n\n                // children\n                this._children = []\n                this._childCtors = {}\n\n                // transclusion unlink functions\n                this._containerUnlinkFn =\n                    this._contentUnlinkFn = null\n\n                // transcluded components that belong to the parent.\n                // need to keep track of them so that we can call\n                // attached/detached hooks on them.\n                this._transCpnts = []\n                this._host = options._host\n\n                // push self into parent / transclusion host\n                if (this.$parent) {\n                    this.$parent._children.push(this)\n                }\n                if (this._host) {\n                    this._host._transCpnts.push(this)\n                }\n\n                // props used in v-repeat diffing\n                this._new = true\n                this._reused = false\n\n                // merge options.\n                options = this.$options = mergeOptions(\n                    this.constructor.options,\n                    options,\n                    this\n                )\n\n                // set data after merge.\n                this._data = options.data || {}\n\n                // initialize data observation and scope inheritance.\n                this._initScope()\n\n                // setup event system and option events.\n                this._initEvents()\n\n                // call created hook\n                this._callHook('created')\n\n                // if `el` option is passed, start compilation.\n                if (options.el) {\n                    this.$mount(options.el)\n                }\n            }\n\n            /***/ },\n        /* 3 */\n        /***/ function(module, exports, __webpack_require__) {\n\n            var _ = __webpack_require__(11)\n            var inDoc = _.inDoc\n\n            /**\n             * Setup the instance's option events & watchers.\n             * If the value is a string, we pull it from the\n             * instance's methods by name.\n             */\n\n            exports._initEvents = function () {\n                var options = this.$options\n                registerCallbacks(this, '$on', options.events)\n                registerCallbacks(this, '$watch', options.watch)\n            }\n\n            /**\n             * Register callbacks for option events and watchers.\n             *\n             * @param {Vue} vm\n             * @param {String} action\n             * @param {Object} hash\n             */\n\n            function registerCallbacks (vm, action, hash) {\n                if (!hash) return\n                var handlers, key, i, j\n                for (key in hash) {\n                    handlers = hash[key]\n                    if (_.isArray(handlers)) {\n                        for (i = 0, j = handlers.length; i < j; i++) {\n                            register(vm, action, key, handlers[i])\n                        }\n                    } else {\n                        register(vm, action, key, handlers)\n                    }\n                }\n            }\n\n            /**\n             * Helper to register an event/watch callback.\n             *\n             * @param {Vue} vm\n             * @param {String} action\n             * @param {String} key\n             * @param {*} handler\n             */\n\n            function register (vm, action, key, handler) {\n                var type = typeof handler\n                if (type === 'function') {\n                    vm[action](key, handler)\n                } else if (type === 'string') {\n                    var methods = vm.$options.methods\n                    var method = methods && methods[handler]\n                    if (method) {\n                        vm[action](key, method)\n                    } else {\n                        _.warn(\n                            'Unknown method: \"' + handler + '\" when ' +\n                            'registering callback for ' + action +\n                            ': \"' + key + '\".'\n                        )\n                    }\n                }\n            }\n\n            /**\n             * Setup recursive attached/detached calls\n             */\n\n            exports._initDOMHooks = function () {\n                this.$on('hook:attached', onAttached)\n                this.$on('hook:detached', onDetached)\n            }\n\n            /**\n             * Callback to recursively call attached hook on children\n             */\n\n            function onAttached () {\n                this._isAttached = true\n                this._children.forEach(callAttach)\n                if (this._transCpnts.length) {\n                    this._transCpnts.forEach(callAttach)\n                }\n            }\n\n            /**\n             * Iterator to call attached hook\n             *\n             * @param {Vue} child\n             */\n\n            function callAttach (child) {\n                if (!child._isAttached && inDoc(child.$el)) {\n                    child._callHook('attached')\n                }\n            }\n\n            /**\n             * Callback to recursively call detached hook on children\n             */\n\n            function onDetached () {\n                this._isAttached = false\n                this._children.forEach(callDetach)\n                if (this._transCpnts.length) {\n                    this._transCpnts.forEach(callDetach)\n                }\n            }\n\n            /**\n             * Iterator to call detached hook\n             *\n             * @param {Vue} child\n             */\n\n            function callDetach (child) {\n                if (child._isAttached && !inDoc(child.$el)) {\n                    child._callHook('detached')\n                }\n            }\n\n            /**\n             * Trigger all handlers for a hook\n             *\n             * @param {String} hook\n             */\n\n            exports._callHook = function (hook) {\n                var handlers = this.$options[hook]\n                if (handlers) {\n                    for (var i = 0, j = handlers.length; i < j; i++) {\n                        handlers[i].call(this)\n                    }\n                }\n                this.$emit('hook:' + hook)\n            }\n\n            /***/ },\n        /* 4 */\n        /***/ function(module, exports, __webpack_require__) {\n\n            var _ = __webpack_require__(11)\n            var Observer = __webpack_require__(49)\n            var Dep = __webpack_require__(23)\n\n            /**\n             * Setup the scope of an instance, which contains:\n             * - observed data\n             * - computed properties\n             * - user methods\n             * - meta properties\n             */\n\n            exports._initScope = function () {\n                this._initData()\n                this._initComputed()\n                this._initMethods()\n                this._initMeta()\n            }\n\n            /**\n             * Initialize the data.\n             */\n\n            exports._initData = function () {\n                // proxy data on instance\n                var data = this._data\n                var keys = Object.keys(data)\n                var i = keys.length\n                var key\n                while (i--) {\n                    key = keys[i]\n                    if (!_.isReserved(key)) {\n                        this._proxy(key)\n                    }\n                }\n                // observe data\n                Observer.create(data).addVm(this)\n            }\n\n            /**\n             * Swap the isntance's $data. Called in $data's setter.\n             *\n             * @param {Object} newData\n             */\n\n            exports._setData = function (newData) {\n                newData = newData || {}\n                var oldData = this._data\n                this._data = newData\n                var keys, key, i\n                // unproxy keys not present in new data\n                keys = Object.keys(oldData)\n                i = keys.length\n                while (i--) {\n                    key = keys[i]\n                    if (!_.isReserved(key) && !(key in newData)) {\n                        this._unproxy(key)\n                    }\n                }\n                // proxy keys not already proxied,\n                // and trigger change for changed values\n                keys = Object.keys(newData)\n                i = keys.length\n                while (i--) {\n                    key = keys[i]\n                    if (!this.hasOwnProperty(key) && !_.isReserved(key)) {\n                        // new property\n                        this._proxy(key)\n                    }\n                }\n                oldData.__ob__.removeVm(this)\n                Observer.create(newData).addVm(this)\n                this._digest()\n            }\n\n            /**\n             * Proxy a property, so that\n             * vm.prop === vm._data.prop\n             *\n             * @param {String} key\n             */\n\n            exports._proxy = function (key) {\n                // need to store ref to self here\n                // because these getter/setters might\n                // be called by child instances!\n                var self = this\n                Object.defineProperty(self, key, {\n                    configurable: true,\n                    enumerable: true,\n                    get: function proxyGetter () {\n                        return self._data[key]\n                    },\n                    set: function proxySetter (val) {\n                        self._data[key] = val\n                    }\n                })\n            }\n\n            /**\n             * Unproxy a property.\n             *\n             * @param {String} key\n             */\n\n            exports._unproxy = function (key) {\n                delete this[key]\n            }\n\n            /**\n             * Force update on every watcher in scope.\n             */\n\n            exports._digest = function () {\n                var i = this._watcherList.length\n                while (i--) {\n                    this._watcherList[i].update()\n                }\n                var children = this._children\n                i = children.length\n                while (i--) {\n                    var child = children[i]\n                    if (child.$options.inherit) {\n                        child._digest()\n                    }\n                }\n            }\n\n            /**\n             * Setup computed properties. They are essentially\n             * special getter/setters\n             */\n\n            function noop () {}\n            exports._initComputed = function () {\n                var computed = this.$options.computed\n                if (computed) {\n                    for (var key in computed) {\n                        var userDef = computed[key]\n                        var def = {\n                            enumerable: true,\n                            configurable: true\n                        }\n                        if (typeof userDef === 'function') {\n                            def.get = _.bind(userDef, this)\n                            def.set = noop\n                        } else {\n                            def.get = userDef.get\n                                ? _.bind(userDef.get, this)\n                                : noop\n                            def.set = userDef.set\n                                ? _.bind(userDef.set, this)\n                                : noop\n                        }\n                        Object.defineProperty(this, key, def)\n                    }\n                }\n            }\n\n            /**\n             * Setup instance methods. Methods must be bound to the\n             * instance since they might be called by children\n             * inheriting them.\n             */\n\n            exports._initMethods = function () {\n                var methods = this.$options.methods\n                if (methods) {\n                    for (var key in methods) {\n                        this[key] = _.bind(methods[key], this)\n                    }\n                }\n            }\n\n            /**\n             * Initialize meta information like $index, $key & $value.\n             */\n\n            exports._initMeta = function () {\n                var metas = this.$options._meta\n                if (metas) {\n                    for (var key in metas) {\n                        this._defineMeta(key, metas[key])\n                    }\n                }\n            }\n\n            /**\n             * Define a meta property, e.g $index, $key, $value\n             * which only exists on the vm instance but not in $data.\n             *\n             * @param {String} key\n             * @param {*} value\n             */\n\n            exports._defineMeta = function (key, value) {\n                var dep = new Dep()\n                Object.defineProperty(this, key, {\n                    enumerable: true,\n                    configurable: true,\n                    get: function metaGetter () {\n                        if (Observer.target) {\n                            Observer.target.addDep(dep)\n                        }\n                        return value\n                    },\n                    set: function metaSetter (val) {\n                        if (val !== value) {\n                            value = val\n                            dep.notify()\n                        }\n                    }\n                })\n            }\n\n            /***/ },\n        /* 5 */\n        /***/ function(module, exports, __webpack_require__) {\n\n            var _ = __webpack_require__(11)\n            var Directive = __webpack_require__(24)\n            var compile = __webpack_require__(16)\n            var transclude = __webpack_require__(17)\n\n            /**\n             * Transclude, compile and link element.\n             *\n             * If a pre-compiled linker is available, that means the\n             * passed in element will be pre-transcluded and compiled\n             * as well - all we need to do is to call the linker.\n             *\n             * Otherwise we need to call transclude/compile/link here.\n             *\n             * @param {Element} el\n             * @return {Element}\n             */\n\n            exports._compile = function (el) {\n                var options = this.$options\n                if (options._linkFn) {\n                    // pre-transcluded with linker, just use it\n                    this._initElement(el)\n                    options._linkFn(this, el)\n                } else {\n                    // transclude and init element\n                    // transclude can potentially replace original\n                    // so we need to keep reference\n                    var original = el\n                    el = transclude(el, options)\n                    this._initElement(el)\n                    // compile and link the rest\n                    compile(el, options)(this, el)\n                    // finally replace original\n                    if (options.replace) {\n                        _.replace(original, el)\n                    }\n                }\n                return el\n            }\n\n            /**\n             * Initialize instance element. Called in the public\n             * $mount() method.\n             *\n             * @param {Element} el\n             */\n\n            exports._initElement = function (el) {\n                if (el instanceof DocumentFragment) {\n                    this._isBlock = true\n                    this.$el = this._blockStart = el.firstChild\n                    this._blockEnd = el.lastChild\n                    this._blockFragment = el\n                } else {\n                    this.$el = el\n                }\n                this.$el.__vue__ = this\n                this._callHook('beforeCompile')\n            }\n\n            /**\n             * Create and bind a directive to an element.\n             *\n             * @param {String} name - directive name\n             * @param {Node} node   - target node\n             * @param {Object} desc - parsed directive descriptor\n             * @param {Object} def  - directive definition object\n             * @param {Vue|undefined} host - transclusion host component\n             */\n\n            exports._bindDir = function (name, node, desc, def, host) {\n                this._directives.push(\n                    new Directive(name, node, this, desc, def, host)\n                )\n            }\n\n            /**\n             * Teardown an instance, unobserves the data, unbind all the\n             * directives, turn off all the event listeners, etc.\n             *\n             * @param {Boolean} remove - whether to remove the DOM node.\n             * @param {Boolean} deferCleanup - if true, defer cleanup to\n             *                                 be called later\n             */\n\n            exports._destroy = function (remove, deferCleanup) {\n                if (this._isBeingDestroyed) {\n                    return\n                }\n                this._callHook('beforeDestroy')\n                this._isBeingDestroyed = true\n                var i\n                // remove self from parent. only necessary\n                // if parent is not being destroyed as well.\n                var parent = this.$parent\n                if (parent && !parent._isBeingDestroyed) {\n                    i = parent._children.indexOf(this)\n                    parent._children.splice(i, 1)\n                }\n                // same for transclusion host.\n                var host = this._host\n                if (host && !host._isBeingDestroyed) {\n                    i = host._transCpnts.indexOf(this)\n                    host._transCpnts.splice(i, 1)\n                }\n                // destroy all children.\n                i = this._children.length\n                while (i--) {\n                    this._children[i].$destroy()\n                }\n                // teardown all directives. this also tearsdown all\n                // directive-owned watchers. intentionally check for\n                // directives array length on every loop since directives\n                // that manages partial compilation can splice ones out\n                for (i = 0; i < this._directives.length; i++) {\n                    this._directives[i]._teardown()\n                }\n                // teardown all user watchers.\n                var watcher\n                for (i in this._userWatchers) {\n                    watcher = this._userWatchers[i]\n                    if (watcher) {\n                        watcher.teardown()\n                    }\n                }\n                // remove reference to self on $el\n                if (this.$el) {\n                    this.$el.__vue__ = null\n                }\n                // remove DOM element\n                var self = this\n                if (remove && this.$el) {\n                    this.$remove(function () {\n                        self._cleanup()\n                    })\n                } else if (!deferCleanup) {\n                    this._cleanup()\n                }\n            }\n\n            /**\n             * Clean up to ensure garbage collection.\n             * This is called after the leave transition if there\n             * is any.\n             */\n\n            exports._cleanup = function () {\n                // remove reference from data ob\n                this._data.__ob__.removeVm(this)\n                this._data =\n                    this._watchers =\n                        this._userWatchers =\n                            this._watcherList =\n                                this.$el =\n                                    this.$parent =\n                                        this.$root =\n                                            this._children =\n                                                this._transCpnts =\n                                                    this._directives = null\n                // call the last hook...\n                this._isDestroyed = true\n                this._callHook('destroyed')\n                // turn off all instance listeners.\n                this.$off()\n            }\n\n            /***/ },\n        /* 6 */\n        /***/ function(module, exports, __webpack_require__) {\n\n            var _ = __webpack_require__(11)\n            var Watcher = __webpack_require__(25)\n            var Path = __webpack_require__(18)\n            var textParser = __webpack_require__(19)\n            var dirParser = __webpack_require__(21)\n            var expParser = __webpack_require__(22)\n            var filterRE = /[^|]\\|[^|]/\n\n            /**\n             * Get the value from an expression on this vm.\n             *\n             * @param {String} exp\n             * @return {*}\n             */\n\n            exports.$get = function (exp) {\n                var res = expParser.parse(exp)\n                if (res) {\n                    try {\n                        return res.get.call(this, this)\n                    } catch (e) {}\n                }\n            }\n\n            /**\n             * Set the value from an expression on this vm.\n             * The expression must be a valid left-hand\n             * expression in an assignment.\n             *\n             * @param {String} exp\n             * @param {*} val\n             */\n\n            exports.$set = function (exp, val) {\n                var res = expParser.parse(exp, true)\n                if (res && res.set) {\n                    res.set.call(this, this, val)\n                }\n            }\n\n            /**\n             * Add a property on the VM\n             *\n             * @param {String} key\n             * @param {*} val\n             */\n\n            exports.$add = function (key, val) {\n                this._data.$add(key, val)\n            }\n\n            /**\n             * Delete a property on the VM\n             *\n             * @param {String} key\n             */\n\n            exports.$delete = function (key) {\n                this._data.$delete(key)\n            }\n\n            /**\n             * Watch an expression, trigger callback when its\n             * value changes.\n             *\n             * @param {String} exp\n             * @param {Function} cb\n             * @param {Boolean} [deep]\n             * @param {Boolean} [immediate]\n             * @return {Function} - unwatchFn\n             */\n\n            exports.$watch = function (exp, cb, deep, immediate) {\n                var vm = this\n                var key = deep ? exp + '**deep**' : exp\n                var watcher = vm._userWatchers[key]\n                var wrappedCb = function (val, oldVal) {\n                    cb.call(vm, val, oldVal)\n                }\n                if (!watcher) {\n                    watcher = vm._userWatchers[key] =\n                        new Watcher(vm, exp, wrappedCb, {\n                            deep: deep,\n                            user: true\n                        })\n                } else {\n                    watcher.addCb(wrappedCb)\n                }\n                if (immediate) {\n                    wrappedCb(watcher.value)\n                }\n                return function unwatchFn () {\n                    watcher.removeCb(wrappedCb)\n                    if (!watcher.active) {\n                        vm._userWatchers[key] = null\n                    }\n                }\n            }\n\n            /**\n             * Evaluate a text directive, including filters.\n             *\n             * @param {String} text\n             * @return {String}\n             */\n\n            exports.$eval = function (text) {\n                // check for filters.\n                if (filterRE.test(text)) {\n                    var dir = dirParser.parse(text)[0]\n                    // the filter regex check might give false positive\n                    // for pipes inside strings, so it's possible that\n                    // we don't get any filters here\n                    return dir.filters\n                        ? _.applyFilters(\n                        this.$get(dir.expression),\n                        _.resolveFilters(this, dir.filters).read,\n                        this\n                    )\n                        : this.$get(dir.expression)\n                } else {\n                    // no filter\n                    return this.$get(text)\n                }\n            }\n\n            /**\n             * Interpolate a piece of template text.\n             *\n             * @param {String} text\n             * @return {String}\n             */\n\n            exports.$interpolate = function (text) {\n                var tokens = textParser.parse(text)\n                var vm = this\n                if (tokens) {\n                    return tokens.length === 1\n                        ? vm.$eval(tokens[0].value)\n                        : tokens.map(function (token) {\n                        return token.tag\n                            ? vm.$eval(token.value)\n                            : token.value\n                    }).join('')\n                } else {\n                    return text\n                }\n            }\n\n            /**\n             * Log instance data as a plain JS object\n             * so that it is easier to inspect in console.\n             * This method assumes console is available.\n             *\n             * @param {String} [path]\n             */\n\n            exports.$log = function (path) {\n                var data = path\n                    ? Path.get(this._data, path)\n                    : this._data\n                if (data) {\n                    data = JSON.parse(JSON.stringify(data))\n                }\n                console.log(data)\n            }\n\n            /***/ },\n        /* 7 */\n        /***/ function(module, exports, __webpack_require__) {\n\n            var _ = __webpack_require__(11)\n            var transition = __webpack_require__(50)\n\n            /**\n             * Append instance to target\n             *\n             * @param {Node} target\n             * @param {Function} [cb]\n             * @param {Boolean} [withTransition] - defaults to true\n             */\n\n            exports.$appendTo = function (target, cb, withTransition) {\n                return insert(\n                    this, target, cb, withTransition,\n                    append, transition.append\n                )\n            }\n\n            /**\n             * Prepend instance to target\n             *\n             * @param {Node} target\n             * @param {Function} [cb]\n             * @param {Boolean} [withTransition] - defaults to true\n             */\n\n            exports.$prependTo = function (target, cb, withTransition) {\n                target = query(target)\n                if (target.hasChildNodes()) {\n                    this.$before(target.firstChild, cb, withTransition)\n                } else {\n                    this.$appendTo(target, cb, withTransition)\n                }\n                return this\n            }\n\n            /**\n             * Insert instance before target\n             *\n             * @param {Node} target\n             * @param {Function} [cb]\n             * @param {Boolean} [withTransition] - defaults to true\n             */\n\n            exports.$before = function (target, cb, withTransition) {\n                return insert(\n                    this, target, cb, withTransition,\n                    before, transition.before\n                )\n            }\n\n            /**\n             * Insert instance after target\n             *\n             * @param {Node} target\n             * @param {Function} [cb]\n             * @param {Boolean} [withTransition] - defaults to true\n             */\n\n            exports.$after = function (target, cb, withTransition) {\n                target = query(target)\n                if (target.nextSibling) {\n                    this.$before(target.nextSibling, cb, withTransition)\n                } else {\n                    this.$appendTo(target.parentNode, cb, withTransition)\n                }\n                return this\n            }\n\n            /**\n             * Remove instance from DOM\n             *\n             * @param {Function} [cb]\n             * @param {Boolean} [withTransition] - defaults to true\n             */\n\n            exports.$remove = function (cb, withTransition) {\n                var inDoc = this._isAttached && _.inDoc(this.$el)\n                // if we are not in document, no need to check\n                // for transitions\n                if (!inDoc) withTransition = false\n                var op\n                var self = this\n                var realCb = function () {\n                    if (inDoc) self._callHook('detached')\n                    if (cb) cb()\n                }\n                if (\n                    this._isBlock &&\n                    !this._blockFragment.hasChildNodes()\n                ) {\n                    op = withTransition === false\n                        ? append\n                        : transition.removeThenAppend\n                    blockOp(this, this._blockFragment, op, realCb)\n                } else {\n                    op = withTransition === false\n                        ? remove\n                        : transition.remove\n                    op(this.$el, this, realCb)\n                }\n                return this\n            }\n\n            /**\n             * Shared DOM insertion function.\n             *\n             * @param {Vue} vm\n             * @param {Element} target\n             * @param {Function} [cb]\n             * @param {Boolean} [withTransition]\n             * @param {Function} op1 - op for non-transition insert\n             * @param {Function} op2 - op for transition insert\n             * @return vm\n             */\n\n            function insert (vm, target, cb, withTransition, op1, op2) {\n                target = query(target)\n                var targetIsDetached = !_.inDoc(target)\n                var op = withTransition === false || targetIsDetached\n                    ? op1\n                    : op2\n                var shouldCallHook =\n                    !targetIsDetached &&\n                    !vm._isAttached &&\n                    !_.inDoc(vm.$el)\n                if (vm._isBlock) {\n                    blockOp(vm, target, op, cb)\n                } else {\n                    op(vm.$el, target, vm, cb)\n                }\n                if (shouldCallHook) {\n                    vm._callHook('attached')\n                }\n                return vm\n            }\n\n            /**\n             * Execute a transition operation on a block instance,\n             * iterating through all its block nodes.\n             *\n             * @param {Vue} vm\n             * @param {Node} target\n             * @param {Function} op\n             * @param {Function} cb\n             */\n\n            function blockOp (vm, target, op, cb) {\n                var current = vm._blockStart\n                var end = vm._blockEnd\n                var next\n                while (next !== end) {\n                    next = current.nextSibling\n                    op(current, target, vm)\n                    current = next\n                }\n                op(end, target, vm, cb)\n            }\n\n            /**\n             * Check for selectors\n             *\n             * @param {String|Element} el\n             */\n\n            function query (el) {\n                return typeof el === 'string'\n                    ? document.querySelector(el)\n                    : el\n            }\n\n            /**\n             * Append operation that takes a callback.\n             *\n             * @param {Node} el\n             * @param {Node} target\n             * @param {Vue} vm - unused\n             * @param {Function} [cb]\n             */\n\n            function append (el, target, vm, cb) {\n                target.appendChild(el)\n                if (cb) cb()\n            }\n\n            /**\n             * InsertBefore operation that takes a callback.\n             *\n             * @param {Node} el\n             * @param {Node} target\n             * @param {Vue} vm - unused\n             * @param {Function} [cb]\n             */\n\n            function before (el, target, vm, cb) {\n                _.before(el, target)\n                if (cb) cb()\n            }\n\n            /**\n             * Remove operation that takes a callback.\n             *\n             * @param {Node} el\n             * @param {Vue} vm - unused\n             * @param {Function} [cb]\n             */\n\n            function remove (el, vm, cb) {\n                _.remove(el)\n                if (cb) cb()\n            }\n\n            /***/ },\n        /* 8 */\n        /***/ function(module, exports, __webpack_require__) {\n\n            var _ = __webpack_require__(11)\n\n            /**\n             * Listen on the given `event` with `fn`.\n             *\n             * @param {String} event\n             * @param {Function} fn\n             */\n\n            exports.$on = function (event, fn) {\n                (this._events[event] || (this._events[event] = []))\n                    .push(fn)\n                modifyListenerCount(this, event, 1)\n                return this\n            }\n\n            /**\n             * Adds an `event` listener that will be invoked a single\n             * time then automatically removed.\n             *\n             * @param {String} event\n             * @param {Function} fn\n             */\n\n            exports.$once = function (event, fn) {\n                var self = this\n                function on () {\n                    self.$off(event, on)\n                    fn.apply(this, arguments)\n                }\n                on.fn = fn\n                this.$on(event, on)\n                return this\n            }\n\n            /**\n             * Remove the given callback for `event` or all\n             * registered callbacks.\n             *\n             * @param {String} event\n             * @param {Function} fn\n             */\n\n            exports.$off = function (event, fn) {\n                var cbs\n                // all\n                if (!arguments.length) {\n                    if (this.$parent) {\n                        for (event in this._events) {\n                            cbs = this._events[event]\n                            if (cbs) {\n                                modifyListenerCount(this, event, -cbs.length)\n                            }\n                        }\n                    }\n                    this._events = {}\n                    return this\n                }\n                // specific event\n                cbs = this._events[event]\n                if (!cbs) {\n                    return this\n                }\n                if (arguments.length === 1) {\n                    modifyListenerCount(this, event, -cbs.length)\n                    this._events[event] = null\n                    return this\n                }\n                // specific handler\n                var cb\n                var i = cbs.length\n                while (i--) {\n                    cb = cbs[i]\n                    if (cb === fn || cb.fn === fn) {\n                        modifyListenerCount(this, event, -1)\n                        cbs.splice(i, 1)\n                        break\n                    }\n                }\n                return this\n            }\n\n            /**\n             * Trigger an event on self.\n             *\n             * @param {String} event\n             */\n\n            exports.$emit = function (event) {\n                this._eventCancelled = false\n                var cbs = this._events[event]\n                if (cbs) {\n                    // avoid leaking arguments:\n                    // http://jsperf.com/closure-with-arguments\n                    var i = arguments.length - 1\n                    var args = new Array(i)\n                    while (i--) {\n                        args[i] = arguments[i + 1]\n                    }\n                    i = 0\n                    cbs = cbs.length > 1\n                        ? _.toArray(cbs)\n                        : cbs\n                    for (var l = cbs.length; i < l; i++) {\n                        if (cbs[i].apply(this, args) === false) {\n                            this._eventCancelled = true\n                        }\n                    }\n                }\n                return this\n            }\n\n            /**\n             * Recursively broadcast an event to all children instances.\n             *\n             * @param {String} event\n             * @param {...*} additional arguments\n             */\n\n            exports.$broadcast = function (event) {\n                // if no child has registered for this event,\n                // then there's no need to broadcast.\n                if (!this._eventsCount[event]) return\n                var children = this._children\n                for (var i = 0, l = children.length; i < l; i++) {\n                    var child = children[i]\n                    child.$emit.apply(child, arguments)\n                    if (!child._eventCancelled) {\n                        child.$broadcast.apply(child, arguments)\n                    }\n                }\n                return this\n            }\n\n            /**\n             * Recursively propagate an event up the parent chain.\n             *\n             * @param {String} event\n             * @param {...*} additional arguments\n             */\n\n            exports.$dispatch = function () {\n                var parent = this.$parent\n                while (parent) {\n                    parent.$emit.apply(parent, arguments)\n                    parent = parent._eventCancelled\n                        ? null\n                        : parent.$parent\n                }\n                return this\n            }\n\n            /**\n             * Modify the listener counts on all parents.\n             * This bookkeeping allows $broadcast to return early when\n             * no child has listened to a certain event.\n             *\n             * @param {Vue} vm\n             * @param {String} event\n             * @param {Number} count\n             */\n\n            var hookRE = /^hook:/\n            function modifyListenerCount (vm, event, count) {\n                var parent = vm.$parent\n                // hooks do not get broadcasted so no need\n                // to do bookkeeping for them\n                if (!parent || !count || hookRE.test(event)) return\n                while (parent) {\n                    parent._eventsCount[event] =\n                        (parent._eventsCount[event] || 0) + count\n                    parent = parent.$parent\n                }\n            }\n\n            /***/ },\n        /* 9 */\n        /***/ function(module, exports, __webpack_require__) {\n\n            var _ = __webpack_require__(11)\n\n            /**\n             * Create a child instance that prototypally inehrits\n             * data on parent. To achieve that we create an intermediate\n             * constructor with its prototype pointing to parent.\n             *\n             * @param {Object} opts\n             * @param {Function} [BaseCtor]\n             * @return {Vue}\n             * @public\n             */\n\n            exports.$addChild = function (opts, BaseCtor) {\n                BaseCtor = BaseCtor || _.Vue\n                opts = opts || {}\n                var parent = this\n                var ChildVue\n                var inherit = opts.inherit !== undefined\n                    ? opts.inherit\n                    : BaseCtor.options.inherit\n                if (inherit) {\n                    var ctors = parent._childCtors\n                    ChildVue = ctors[BaseCtor.cid]\n                    if (!ChildVue) {\n                        var optionName = BaseCtor.options.name\n                        var className = optionName\n                            ? _.classify(optionName)\n                            : 'VueComponent'\n                        ChildVue = new Function(\n                            'return function ' + className + ' (options) {' +\n                            'this.constructor = ' + className + ';' +\n                            'this._init(options) }'\n                        )()\n                        ChildVue.options = BaseCtor.options\n                        ChildVue.prototype = this\n                        ctors[BaseCtor.cid] = ChildVue\n                    }\n                } else {\n                    ChildVue = BaseCtor\n                }\n                opts._parent = parent\n                opts._root = parent.$root\n                var child = new ChildVue(opts)\n                return child\n            }\n\n            /***/ },\n        /* 10 */\n        /***/ function(module, exports, __webpack_require__) {\n\n            var _ = __webpack_require__(11)\n            var compile = __webpack_require__(16)\n\n            /**\n             * Set instance target element and kick off the compilation\n             * process. The passed in `el` can be a selector string, an\n             * existing Element, or a DocumentFragment (for block\n             * instances).\n             *\n             * @param {Element|DocumentFragment|string} el\n             * @public\n             */\n\n            exports.$mount = function (el) {\n                if (this._isCompiled) {\n                    _.warn('$mount() should be called only once.')\n                    return\n                }\n                if (!el) {\n                    el = document.createElement('div')\n                } else if (typeof el === 'string') {\n                    var selector = el\n                    el = document.querySelector(el)\n                    if (!el) {\n                        _.warn('Cannot find element: ' + selector)\n                        return\n                    }\n                }\n                this._compile(el)\n                this._isCompiled = true\n                this._callHook('compiled')\n                if (_.inDoc(this.$el)) {\n                    this._callHook('attached')\n                    this._initDOMHooks()\n                    ready.call(this)\n                } else {\n                    this._initDOMHooks()\n                    this.$once('hook:attached', ready)\n                }\n                return this\n            }\n\n            /**\n             * Mark an instance as ready.\n             */\n\n            function ready () {\n                this._isAttached = true\n                this._isReady = true\n                this._callHook('ready')\n            }\n\n            /**\n             * Teardown the instance, simply delegate to the internal\n             * _destroy.\n             */\n\n            exports.$destroy = function (remove, deferCleanup) {\n                this._destroy(remove, deferCleanup)\n            }\n\n            /**\n             * Partially compile a piece of DOM and return a\n             * decompile function.\n             *\n             * @param {Element|DocumentFragment} el\n             * @return {Function}\n             */\n\n            exports.$compile = function (el) {\n                return compile(el, this.$options, true)(this, el)\n            }\n\n            /***/ },\n        /* 11 */\n        /***/ function(module, exports, __webpack_require__) {\n\n            var lang   = __webpack_require__(26)\n            var extend = lang.extend\n\n            extend(exports, lang)\n            extend(exports, __webpack_require__(27))\n            extend(exports, __webpack_require__(28))\n            extend(exports, __webpack_require__(29))\n            extend(exports, __webpack_require__(30))\n\n            /***/ },\n        /* 12 */\n        /***/ function(module, exports, __webpack_require__) {\n\n            // manipulation directives\n            exports.text       = __webpack_require__(31)\n            exports.html       = __webpack_require__(32)\n            exports.attr       = __webpack_require__(33)\n            exports.show       = __webpack_require__(34)\n            exports['class']   = __webpack_require__(35)\n            exports.el         = __webpack_require__(36)\n            exports.ref        = __webpack_require__(37)\n            exports.cloak      = __webpack_require__(38)\n            exports.style      = __webpack_require__(39)\n            exports.partial    = __webpack_require__(40)\n            exports.transition = __webpack_require__(41)\n\n            // event listener directives\n            exports.on         = __webpack_require__(42)\n            exports.model      = __webpack_require__(51)\n\n            // child vm directives\n            exports.component  = __webpack_require__(43)\n            exports.repeat     = __webpack_require__(44)\n            exports['if']      = __webpack_require__(45)\n\n            // child vm communication directives\n            exports['with']    = __webpack_require__(46)\n            exports.events     = __webpack_require__(47)\n\n            /***/ },\n        /* 13 */\n        /***/ function(module, exports, __webpack_require__) {\n\n            var _ = __webpack_require__(11)\n\n            /**\n             * Stringify value.\n             *\n             * @param {Number} indent\n             */\n\n            exports.json = {\n                read: function (value, indent) {\n                    return typeof value === 'string'\n                        ? value\n                        : JSON.stringify(value, null, Number(indent) || 2)\n                },\n                write: function (value) {\n                    try {\n                        return JSON.parse(value)\n                    } catch (e) {\n                        return value\n                    }\n                }\n            }\n\n            /**\n             * 'abc' => 'Abc'\n             */\n\n            exports.capitalize = function (value) {\n                if (!value && value !== 0) return ''\n                value = value.toString()\n                return value.charAt(0).toUpperCase() + value.slice(1)\n            }\n\n            /**\n             * 'abc' => 'ABC'\n             */\n\n            exports.uppercase = function (value) {\n                return (value || value === 0)\n                    ? value.toString().toUpperCase()\n                    : ''\n            }\n\n            /**\n             * 'AbC' => 'abc'\n             */\n\n            exports.lowercase = function (value) {\n                return (value || value === 0)\n                    ? value.toString().toLowerCase()\n                    : ''\n            }\n\n            /**\n             * 12345 => $12,345.00\n             *\n             * @param {String} sign\n             */\n\n            var digitsRE = /(\\d{3})(?=\\d)/g\n\n            exports.currency = function (value, sign) {\n                value = parseFloat(value)\n                if (!isFinite(value) || (!value && value !== 0)) return ''\n                sign = sign || '$'\n                var s = Math.floor(Math.abs(value)).toString(),\n                    i = s.length % 3,\n                    h = i > 0\n                        ? (s.slice(0, i) + (s.length > 3 ? ',' : ''))\n                        : '',\n                    v = Math.abs(parseInt((value * 100) % 100, 10)),\n                    f = '.' + (v < 10 ? ('0' + v) : v)\n                return (value < 0 ? '-' : '') +\n                    sign + h + s.slice(i).replace(digitsRE, '$1,') + f\n            }\n\n            /**\n             * 'item' => 'items'\n             *\n             * @params\n             *  an array of strings corresponding to\n             *  the single, double, triple ... forms of the word to\n             *  be pluralized. When the number to be pluralized\n             *  exceeds the length of the args, it will use the last\n             *  entry in the array.\n             *\n             *  e.g. ['single', 'double', 'triple', 'multiple']\n             */\n\n            exports.pluralize = function (value) {\n                var args = _.toArray(arguments, 1)\n                return args.length > 1\n                    ? (args[value % 10 - 1] || args[args.length - 1])\n                    : (args[0] + (value === 1 ? '' : 's'))\n            }\n\n            /**\n             * A special filter that takes a handler function,\n             * wraps it so it only gets triggered on specific\n             * keypresses. v-on only.\n             *\n             * @param {String} key\n             */\n\n            var keyCodes = {\n                enter    : 13,\n                tab      : 9,\n                'delete' : 46,\n                up       : 38,\n                left     : 37,\n                right    : 39,\n                down     : 40,\n                esc      : 27\n            }\n\n            exports.key = function (handler, key) {\n                if (!handler) return\n                var code = keyCodes[key]\n                if (!code) {\n                    code = parseInt(key, 10)\n                }\n                return function (e) {\n                    if (e.keyCode === code) {\n                        return handler.call(this, e)\n                    }\n                }\n            }\n\n            // expose keycode hash\n            exports.key.keyCodes = keyCodes\n\n            /**\n             * Install special array filters\n             */\n\n            _.extend(exports, __webpack_require__(48))\n\n\n            /***/ },\n        /* 14 */\n        /***/ function(module, exports, __webpack_require__) {\n\n            var _ = __webpack_require__(11)\n            var extend = _.extend\n\n            /**\n             * Option overwriting strategies are functions that handle\n             * how to merge a parent option value and a child option\n             * value into the final value.\n             *\n             * All strategy functions follow the same signature:\n             *\n             * @param {*} parentVal\n             * @param {*} childVal\n             * @param {Vue} [vm]\n             */\n\n            var strats = Object.create(null)\n\n            /**\n             * Helper that recursively merges two data objects together.\n             */\n\n            function mergeData (to, from) {\n                var key, toVal, fromVal\n                for (key in from) {\n                    toVal = to[key]\n                    fromVal = from[key]\n                    if (!to.hasOwnProperty(key)) {\n                        to.$add(key, fromVal)\n                    } else if (_.isObject(toVal) && _.isObject(fromVal)) {\n                        mergeData(toVal, fromVal)\n                    }\n                }\n                return to\n            }\n\n            /**\n             * Data\n             */\n\n            strats.data = function (parentVal, childVal, vm) {\n                if (!vm) {\n                    // in a Vue.extend merge, both should be functions\n                    if (!childVal) {\n                        return parentVal\n                    }\n                    if (typeof childVal !== 'function') {\n                        _.warn(\n                            'The \"data\" option should be a function ' +\n                            'that returns a per-instance value in component ' +\n                            'definitions.'\n                        )\n                        return parentVal\n                    }\n                    if (!parentVal) {\n                        return childVal\n                    }\n                    // when parentVal & childVal are both present,\n                    // we need to return a function that returns the\n                    // merged result of both functions... no need to\n                    // check if parentVal is a function here because\n                    // it has to be a function to pass previous merges.\n                    return function mergedDataFn () {\n                        return mergeData(\n                            childVal.call(this),\n                            parentVal.call(this)\n                        )\n                    }\n                } else {\n                    // instance merge, return raw object\n                    var instanceData = typeof childVal === 'function'\n                        ? childVal.call(vm)\n                        : childVal\n                    var defaultData = typeof parentVal === 'function'\n                        ? parentVal.call(vm)\n                        : undefined\n                    if (instanceData) {\n                        return mergeData(instanceData, defaultData)\n                    } else {\n                        return defaultData\n                    }\n                }\n            }\n\n            /**\n             * El\n             */\n\n            strats.el = function (parentVal, childVal, vm) {\n                if (!vm && childVal && typeof childVal !== 'function') {\n                    _.warn(\n                        'The \"el\" option should be a function ' +\n                        'that returns a per-instance value in component ' +\n                        'definitions.'\n                    )\n                    return\n                }\n                var ret = childVal || parentVal\n                // invoke the element factory if this is instance merge\n                return vm && typeof ret === 'function'\n                    ? ret.call(vm)\n                    : ret\n            }\n\n            /**\n             * Hooks and param attributes are merged as arrays.\n             */\n\n            strats.created =\n                strats.ready =\n                    strats.attached =\n                        strats.detached =\n                            strats.beforeCompile =\n                                strats.compiled =\n                                    strats.beforeDestroy =\n                                        strats.destroyed =\n                                            strats.paramAttributes = function (parentVal, childVal) {\n                                                return childVal\n                                                    ? parentVal\n                                                    ? parentVal.concat(childVal)\n                                                    : _.isArray(childVal)\n                                                    ? childVal\n                                                    : [childVal]\n                                                    : parentVal\n                                            }\n\n            /**\n             * Assets\n             *\n             * When a vm is present (instance creation), we need to do\n             * a three-way merge between constructor options, instance\n             * options and parent options.\n             */\n\n            strats.directives =\n                strats.filters =\n                    strats.partials =\n                        strats.transitions =\n                            strats.components = function (parentVal, childVal, vm, key) {\n                                var ret = Object.create(\n                                    vm && vm.$parent\n                                        ? vm.$parent.$options[key]\n                                        : _.Vue.options[key]\n                                )\n                                if (parentVal) {\n                                    var keys = Object.keys(parentVal)\n                                    var i = keys.length\n                                    var field\n                                    while (i--) {\n                                        field = keys[i]\n                                        ret[field] = parentVal[field]\n                                    }\n                                }\n                                if (childVal) extend(ret, childVal)\n                                return ret\n                            }\n\n            /**\n             * Events & Watchers.\n             *\n             * Events & watchers hashes should not overwrite one\n             * another, so we merge them as arrays.\n             */\n\n            strats.watch =\n                strats.events = function (parentVal, childVal) {\n                    if (!childVal) return parentVal\n                    if (!parentVal) return childVal\n                    var ret = {}\n                    extend(ret, parentVal)\n                    for (var key in childVal) {\n                        var parent = ret[key]\n                        var child = childVal[key]\n                        if (parent && !_.isArray(parent)) {\n                            parent = [parent]\n                        }\n                        ret[key] = parent\n                            ? parent.concat(child)\n                            : [child]\n                    }\n                    return ret\n                }\n\n            /**\n             * Other object hashes.\n             */\n\n            strats.methods =\n                strats.computed = function (parentVal, childVal) {\n                    if (!childVal) return parentVal\n                    if (!parentVal) return childVal\n                    var ret = Object.create(parentVal)\n                    extend(ret, childVal)\n                    return ret\n                }\n\n            /**\n             * Default strategy.\n             */\n\n            var defaultStrat = function (parentVal, childVal) {\n                return childVal === undefined\n                    ? parentVal\n                    : childVal\n            }\n\n            /**\n             * Make sure component options get converted to actual\n             * constructors.\n             *\n             * @param {Object} components\n             */\n\n            function guardComponents (components) {\n                if (components) {\n                    var def\n                    for (var key in components) {\n                        def = components[key]\n                        if (_.isPlainObject(def)) {\n                            def.name = key\n                            components[key] = _.Vue.extend(def)\n                        }\n                    }\n                }\n            }\n\n            /**\n             * Merge two option objects into a new one.\n             * Core utility used in both instantiation and inheritance.\n             *\n             * @param {Object} parent\n             * @param {Object} child\n             * @param {Vue} [vm] - if vm is present, indicates this is\n             *                     an instantiation merge.\n             */\n\n            module.exports = function mergeOptions (parent, child, vm) {\n                guardComponents(child.components)\n                var options = {}\n                var key\n                if (child.mixins) {\n                    for (var i = 0, l = child.mixins.length; i < l; i++) {\n                        parent = mergeOptions(parent, child.mixins[i], vm)\n                    }\n                }\n                for (key in parent) {\n                    merge(key)\n                }\n                for (key in child) {\n                    if (!(parent.hasOwnProperty(key))) {\n                        merge(key)\n                    }\n                }\n                function merge (key) {\n                    var strat = strats[key] || defaultStrat\n                    options[key] = strat(parent[key], child[key], vm, key)\n                }\n                return options\n            }\n\n            /***/ },\n        /* 15 */\n        /***/ function(module, exports, __webpack_require__) {\n\n            module.exports = {\n\n                /**\n                 * The prefix to look for when parsing directives.\n                 *\n                 * @type {String}\n                 */\n\n                prefix: 'v-',\n\n                /**\n                 * Whether to print debug messages.\n                 * Also enables stack trace for warnings.\n                 *\n                 * @type {Boolean}\n                 */\n\n                debug: false,\n\n                /**\n                 * Whether to suppress warnings.\n                 *\n                 * @type {Boolean}\n                 */\n\n                silent: false,\n\n                /**\n                 * Whether allow observer to alter data objects'\n                 * __proto__.\n                 *\n                 * @type {Boolean}\n                 */\n\n                proto: true,\n\n                /**\n                 * Whether to parse mustache tags in templates.\n                 *\n                 * @type {Boolean}\n                 */\n\n                interpolate: true,\n\n                /**\n                 * Whether to use async rendering.\n                 */\n\n                async: true,\n\n                /**\n                 * Whether to warn against errors caught when evaluating\n                 * expressions.\n                 */\n\n                warnExpressionErrors: true,\n\n                /**\n                 * Internal flag to indicate the delimiters have been\n                 * changed.\n                 *\n                 * @type {Boolean}\n                 */\n\n                _delimitersChanged: true\n\n            }\n\n            /**\n             * Interpolation delimiters.\n             * We need to mark the changed flag so that the text parser\n             * knows it needs to recompile the regex.\n             *\n             * @type {Array<String>}\n             */\n\n            var delimiters = ['{{', '}}']\n            Object.defineProperty(module.exports, 'delimiters', {\n                get: function () {\n                    return delimiters\n                },\n                set: function (val) {\n                    delimiters = val\n                    this._delimitersChanged = true\n                }\n            })\n\n            /***/ },\n        /* 16 */\n        /***/ function(module, exports, __webpack_require__) {\n\n            var _ = __webpack_require__(11)\n            var config = __webpack_require__(15)\n            var textParser = __webpack_require__(19)\n            var dirParser = __webpack_require__(21)\n            var templateParser = __webpack_require__(20)\n\n            module.exports = compile\n\n            /**\n             * Compile a template and return a reusable composite link\n             * function, which recursively contains more link functions\n             * inside. This top level compile function should only be\n             * called on instance root nodes.\n             *\n             * @param {Element|DocumentFragment} el\n             * @param {Object} options\n             * @param {Boolean} partial\n             * @param {Boolean} transcluded\n             * @return {Function}\n             */\n\n            function compile (el, options, partial, transcluded) {\n                var isBlock = el.nodeType === 11\n                // link function for param attributes.\n                var params = options.paramAttributes\n                var paramsLinkFn = params && !partial && !transcluded && !isBlock\n                    ? compileParamAttributes(el, params, options)\n                    : null\n                // link function for the node itself.\n                // if this is a block instance, we return a link function\n                // for the attributes found on the container, if any.\n                // options._containerAttrs are collected during transclusion.\n                var nodeLinkFn = isBlock\n                    ? compileBlockContainer(options._containerAttrs, params, options)\n                    : compileNode(el, options)\n                // link function for the childNodes\n                var childLinkFn =\n                    !(nodeLinkFn && nodeLinkFn.terminal) &&\n                    el.tagName !== 'SCRIPT' &&\n                    el.hasChildNodes()\n                        ? compileNodeList(el.childNodes, options)\n                        : null\n\n                /**\n                 * A composite linker function to be called on a already\n                 * compiled piece of DOM, which instantiates all directive\n                 * instances.\n                 *\n                 * @param {Vue} vm\n                 * @param {Element|DocumentFragment} el\n                 * @return {Function|undefined}\n                 */\n\n                function compositeLinkFn (vm, el) {\n                    var originalDirCount = vm._directives.length\n                    var parentOriginalDirCount =\n                        vm.$parent && vm.$parent._directives.length\n                    if (paramsLinkFn) {\n                        paramsLinkFn(vm, el)\n                    }\n                    // cache childNodes before linking parent, fix #657\n                    var childNodes = _.toArray(el.childNodes)\n                    // if this is a transcluded compile, linkers need to be\n                    // called in source scope, and the host needs to be\n                    // passed down.\n                    var source = transcluded ? vm.$parent : vm\n                    var host = transcluded ? vm : undefined\n                    // link\n                    if (nodeLinkFn) nodeLinkFn(source, el, host)\n                    if (childLinkFn) childLinkFn(source, childNodes, host)\n\n                    /**\n                     * If this is a partial compile, the linker function\n                     * returns an unlink function that tearsdown all\n                     * directives instances generated during the partial\n                     * linking.\n                     */\n\n                    if (partial && !transcluded) {\n                        var selfDirs = vm._directives.slice(originalDirCount)\n                        var parentDirs = vm.$parent &&\n                            vm.$parent._directives.slice(parentOriginalDirCount)\n\n                        var teardownDirs = function (vm, dirs) {\n                            var i = dirs.length\n                            while (i--) {\n                                dirs[i]._teardown()\n                            }\n                            i = vm._directives.indexOf(dirs[0])\n                            vm._directives.splice(i, dirs.length)\n                        }\n\n                        return function unlink () {\n                            teardownDirs(vm, selfDirs)\n                            if (parentDirs) {\n                                teardownDirs(vm.$parent, parentDirs)\n                            }\n                        }\n                    }\n                }\n\n                // transcluded linkFns are terminal, because it takes\n                // over the entire sub-tree.\n                if (transcluded) {\n                    compositeLinkFn.terminal = true\n                }\n\n                return compositeLinkFn\n            }\n\n            /**\n             * Compile the attributes found on a \"block container\" -\n             * i.e. the container node in the parent tempate of a block\n             * instance. We are only concerned with v-with and\n             * paramAttributes here.\n             *\n             * @param {Object} attrs - a map of attr name/value pairs\n             * @param {Array} params - param attributes list\n             * @param {Object} options\n             * @return {Function}\n             */\n\n            function compileBlockContainer (attrs, params, options) {\n                if (!attrs) return null\n                var paramsLinkFn = params\n                    ? compileParamAttributes(attrs, params, options)\n                    : null\n                var withVal = attrs[config.prefix + 'with']\n                var withLinkFn = null\n                if (withVal) {\n                    var descriptor = dirParser.parse(withVal)[0]\n                    var def = options.directives['with']\n                    withLinkFn = function (vm, el) {\n                        vm._bindDir('with', el, descriptor, def)\n                    }\n                }\n                return function blockContainerLinkFn (vm) {\n                    // explicitly passing null to the linkers\n                    // since v-with doesn't need a real element\n                    if (paramsLinkFn) paramsLinkFn(vm, null)\n                    if (withLinkFn) withLinkFn(vm, null)\n                }\n            }\n\n            /**\n             * Compile a node and return a nodeLinkFn based on the\n             * node type.\n             *\n             * @param {Node} node\n             * @param {Object} options\n             * @return {Function|null}\n             */\n\n            function compileNode (node, options) {\n                var type = node.nodeType\n                if (type === 1 && node.tagName !== 'SCRIPT') {\n                    return compileElement(node, options)\n                } else if (type === 3 && config.interpolate && node.data.trim()) {\n                    return compileTextNode(node, options)\n                } else {\n                    return null\n                }\n            }\n\n            /**\n             * Compile an element and return a nodeLinkFn.\n             *\n             * @param {Element} el\n             * @param {Object} options\n             * @return {Function|null}\n             */\n\n            function compileElement (el, options) {\n                if (checkTransclusion(el)) {\n                    // unwrap textNode\n                    if (el.hasAttribute('__vue__wrap')) {\n                        el = el.firstChild\n                    }\n                    return compile(el, options._parent.$options, true, true)\n                }\n                var linkFn, tag, component\n                // check custom element component, but only on non-root\n                if (!el.__vue__) {\n                    tag = el.tagName.toLowerCase()\n                    component =\n                        tag.indexOf('-') > 0 &&\n                        options.components[tag]\n                    if (component) {\n                        el.setAttribute(config.prefix + 'component', tag)\n                    }\n                }\n                if (component || el.hasAttributes()) {\n                    // check terminal direcitves\n                    linkFn = checkTerminalDirectives(el, options)\n                    // if not terminal, build normal link function\n                    if (!linkFn) {\n                        var dirs = collectDirectives(el, options)\n                        linkFn = dirs.length\n                            ? makeNodeLinkFn(dirs)\n                            : null\n                    }\n                }\n                // if the element is a textarea, we need to interpolate\n                // its content on initial render.\n                if (el.tagName === 'TEXTAREA') {\n                    var realLinkFn = linkFn\n                    linkFn = function (vm, el) {\n                        el.value = vm.$interpolate(el.value)\n                        if (realLinkFn) realLinkFn(vm, el)\n                    }\n                    linkFn.terminal = true\n                }\n                return linkFn\n            }\n\n            /**\n             * Build a link function for all directives on a single node.\n             *\n             * @param {Array} directives\n             * @return {Function} directivesLinkFn\n             */\n\n            function makeNodeLinkFn (directives) {\n                return function nodeLinkFn (vm, el, host) {\n                    // reverse apply because it's sorted low to high\n                    var i = directives.length\n                    var dir, j, k, target\n                    while (i--) {\n                        dir = directives[i]\n                        // a directive can be transcluded if it's written\n                        // on a component's container in its parent tempalte.\n                        target = dir.transcluded\n                            ? vm.$parent\n                            : vm\n                        if (dir._link) {\n                            // custom link fn\n                            dir._link(target, el)\n                        } else {\n                            k = dir.descriptors.length\n                            for (j = 0; j < k; j++) {\n                                target._bindDir(dir.name, el,\n                                    dir.descriptors[j], dir.def, host)\n                            }\n                        }\n                    }\n                }\n            }\n\n            /**\n             * Compile a textNode and return a nodeLinkFn.\n             *\n             * @param {TextNode} node\n             * @param {Object} options\n             * @return {Function|null} textNodeLinkFn\n             */\n\n            function compileTextNode (node, options) {\n                var tokens = textParser.parse(node.data)\n                if (!tokens) {\n                    return null\n                }\n                var frag = document.createDocumentFragment()\n                var el, token\n                for (var i = 0, l = tokens.length; i < l; i++) {\n                    token = tokens[i]\n                    el = token.tag\n                        ? processTextToken(token, options)\n                        : document.createTextNode(token.value)\n                    frag.appendChild(el)\n                }\n                return makeTextNodeLinkFn(tokens, frag, options)\n            }\n\n            /**\n             * Process a single text token.\n             *\n             * @param {Object} token\n             * @param {Object} options\n             * @return {Node}\n             */\n\n            function processTextToken (token, options) {\n                var el\n                if (token.oneTime) {\n                    el = document.createTextNode(token.value)\n                } else {\n                    if (token.html) {\n                        el = document.createComment('v-html')\n                        setTokenType('html')\n                    } else if (token.partial) {\n                        el = document.createComment('v-partial')\n                        setTokenType('partial')\n                    } else {\n                        // IE will clean up empty textNodes during\n                        // frag.cloneNode(true), so we have to give it\n                        // something here...\n                        el = document.createTextNode(' ')\n                        setTokenType('text')\n                    }\n                }\n                function setTokenType (type) {\n                    token.type = type\n                    token.def = options.directives[type]\n                    token.descriptor = dirParser.parse(token.value)[0]\n                }\n                return el\n            }\n\n            /**\n             * Build a function that processes a textNode.\n             *\n             * @param {Array<Object>} tokens\n             * @param {DocumentFragment} frag\n             */\n\n            function makeTextNodeLinkFn (tokens, frag) {\n                return function textNodeLinkFn (vm, el) {\n                    var fragClone = frag.cloneNode(true)\n                    var childNodes = _.toArray(fragClone.childNodes)\n                    var token, value, node\n                    for (var i = 0, l = tokens.length; i < l; i++) {\n                        token = tokens[i]\n                        value = token.value\n                        if (token.tag) {\n                            node = childNodes[i]\n                            if (token.oneTime) {\n                                value = vm.$eval(value)\n                                if (token.html) {\n                                    _.replace(node, templateParser.parse(value, true))\n                                } else {\n                                    node.data = value\n                                }\n                            } else {\n                                vm._bindDir(token.type, node,\n                                    token.descriptor, token.def)\n                            }\n                        }\n                    }\n                    _.replace(el, fragClone)\n                }\n            }\n\n            /**\n             * Compile a node list and return a childLinkFn.\n             *\n             * @param {NodeList} nodeList\n             * @param {Object} options\n             * @return {Function|undefined}\n             */\n\n            function compileNodeList (nodeList, options) {\n                var linkFns = []\n                var nodeLinkFn, childLinkFn, node\n                for (var i = 0, l = nodeList.length; i < l; i++) {\n                    node = nodeList[i]\n                    nodeLinkFn = compileNode(node, options)\n                    childLinkFn =\n                        !(nodeLinkFn && nodeLinkFn.terminal) &&\n                        node.tagName !== 'SCRIPT' &&\n                        node.hasChildNodes()\n                            ? compileNodeList(node.childNodes, options)\n                            : null\n                    linkFns.push(nodeLinkFn, childLinkFn)\n                }\n                return linkFns.length\n                    ? makeChildLinkFn(linkFns)\n                    : null\n            }\n\n            /**\n             * Make a child link function for a node's childNodes.\n             *\n             * @param {Array<Function>} linkFns\n             * @return {Function} childLinkFn\n             */\n\n            function makeChildLinkFn (linkFns) {\n                return function childLinkFn (vm, nodes, host) {\n                    var node, nodeLinkFn, childrenLinkFn\n                    for (var i = 0, n = 0, l = linkFns.length; i < l; n++) {\n                        node = nodes[n]\n                        nodeLinkFn = linkFns[i++]\n                        childrenLinkFn = linkFns[i++]\n                        // cache childNodes before linking parent, fix #657\n                        var childNodes = _.toArray(node.childNodes)\n                        if (nodeLinkFn) {\n                            nodeLinkFn(vm, node, host)\n                        }\n                        if (childrenLinkFn) {\n                            childrenLinkFn(vm, childNodes, host)\n                        }\n                    }\n                }\n            }\n\n            /**\n             * Compile param attributes on a root element and return\n             * a paramAttributes link function.\n             *\n             * @param {Element|Object} el\n             * @param {Array} attrs\n             * @param {Object} options\n             * @return {Function} paramsLinkFn\n             */\n\n            function compileParamAttributes (el, attrs, options) {\n                var params = []\n                var isEl = el.nodeType\n                var i = attrs.length\n                var name, value, param\n                while (i--) {\n                    name = attrs[i]\n                    if (/[A-Z]/.test(name)) {\n                        _.warn(\n                            'You seem to be using camelCase for a paramAttribute, ' +\n                            'but HTML doesn\\'t differentiate between upper and ' +\n                            'lower case. You should use hyphen-delimited ' +\n                            'attribute names. For more info see ' +\n                            'http://vuejs.org/api/options.html#paramAttributes'\n                        )\n                    }\n                    value = isEl ? el.getAttribute(name) : el[name]\n                    if (value !== null) {\n                        param = {\n                            name: name,\n                            value: value\n                        }\n                        var tokens = textParser.parse(value)\n                        if (tokens) {\n                            if (isEl) el.removeAttribute(name)\n                            if (tokens.length > 1) {\n                                _.warn(\n                                    'Invalid param attribute binding: \"' +\n                                    name + '=\"' + value + '\"' +\n                                    '\\nDon\\'t mix binding tags with plain text ' +\n                                    'in param attribute bindings.'\n                                )\n                                continue\n                            } else {\n                                param.dynamic = true\n                                param.value = tokens[0].value\n                            }\n                        }\n                        params.push(param)\n                    }\n                }\n                return makeParamsLinkFn(params, options)\n            }\n\n            /**\n             * Build a function that applies param attributes to a vm.\n             *\n             * @param {Array} params\n             * @param {Object} options\n             * @return {Function} paramsLinkFn\n             */\n\n            var dataAttrRE = /^data-/\n\n            function makeParamsLinkFn (params, options) {\n                var def = options.directives['with']\n                return function paramsLinkFn (vm, el) {\n                    var i = params.length\n                    var param, path\n                    while (i--) {\n                        param = params[i]\n                        // params could contain dashes, which will be\n                        // interpreted as minus calculations by the parser\n                        // so we need to wrap the path here\n                        path = _.camelize(param.name.replace(dataAttrRE, ''))\n                        if (param.dynamic) {\n                            // dynamic param attribtues are bound as v-with.\n                            // we can directly duck the descriptor here beacuse\n                            // param attributes cannot use expressions or\n                            // filters.\n                            vm._bindDir('with', el, {\n                                arg: path,\n                                expression: param.value\n                            }, def)\n                        } else {\n                            // just set once\n                            vm.$set(path, param.value)\n                        }\n                    }\n                }\n            }\n\n            /**\n             * Check an element for terminal directives in fixed order.\n             * If it finds one, return a terminal link function.\n             *\n             * @param {Element} el\n             * @param {Object} options\n             * @return {Function} terminalLinkFn\n             */\n\n            var terminalDirectives = [\n                'repeat',\n                'if',\n                'component'\n            ]\n\n            function skip () {}\n            skip.terminal = true\n\n            function checkTerminalDirectives (el, options) {\n                if (_.attr(el, 'pre') !== null) {\n                    return skip\n                }\n                var value, dirName\n                /* jshint boss: true */\n                for (var i = 0; i < 3; i++) {\n                    dirName = terminalDirectives[i]\n                    if (value = _.attr(el, dirName)) {\n                        return makeTerminalNodeLinkFn(el, dirName, value, options)\n                    }\n                }\n            }\n\n            /**\n             * Build a node link function for a terminal directive.\n             * A terminal link function terminates the current\n             * compilation recursion and handles compilation of the\n             * subtree in the directive.\n             *\n             * @param {Element} el\n             * @param {String} dirName\n             * @param {String} value\n             * @param {Object} options\n             * @return {Function} terminalLinkFn\n             */\n\n            function makeTerminalNodeLinkFn (el, dirName, value, options) {\n                var descriptor = dirParser.parse(value)[0]\n                var def = options.directives[dirName]\n                var fn = function terminalNodeLinkFn (vm, el, host) {\n                    vm._bindDir(dirName, el, descriptor, def, host)\n                }\n                fn.terminal = true\n                return fn\n            }\n\n            /**\n             * Collect the directives on an element.\n             *\n             * @param {Element} el\n             * @param {Object} options\n             * @return {Array}\n             */\n\n            function collectDirectives (el, options) {\n                var attrs = _.toArray(el.attributes)\n                var i = attrs.length\n                var dirs = []\n                var attr, attrName, dir, dirName, dirDef, transcluded\n                while (i--) {\n                    attr = attrs[i]\n                    attrName = attr.name\n                    transcluded =\n                        options._transcludedAttrs &&\n                        options._transcludedAttrs[attrName]\n                    if (attrName.indexOf(config.prefix) === 0) {\n                        dirName = attrName.slice(config.prefix.length)\n                        dirDef = options.directives[dirName]\n                        _.assertAsset(dirDef, 'directive', dirName)\n                        if (dirDef) {\n                            dirs.push({\n                                name: dirName,\n                                descriptors: dirParser.parse(attr.value),\n                                def: dirDef,\n                                transcluded: transcluded\n                            })\n                        }\n                    } else if (config.interpolate) {\n                        dir = collectAttrDirective(el, attrName, attr.value,\n                            options)\n                        if (dir) {\n                            dir.transcluded = transcluded\n                            dirs.push(dir)\n                        }\n                    }\n                }\n                // sort by priority, LOW to HIGH\n                dirs.sort(directiveComparator)\n                return dirs\n            }\n\n            /**\n             * Check an attribute for potential dynamic bindings,\n             * and return a directive object.\n             *\n             * @param {Element} el\n             * @param {String} name\n             * @param {String} value\n             * @param {Object} options\n             * @return {Object}\n             */\n\n            function collectAttrDirective (el, name, value, options) {\n                var tokens = textParser.parse(value)\n                if (tokens) {\n                    var def = options.directives.attr\n                    var i = tokens.length\n                    var allOneTime = true\n                    while (i--) {\n                        var token = tokens[i]\n                        if (token.tag && !token.oneTime) {\n                            allOneTime = false\n                        }\n                    }\n                    return {\n                        def: def,\n                        _link: allOneTime\n                            ? function (vm, el) {\n                            el.setAttribute(name, vm.$interpolate(value))\n                        }\n                            : function (vm, el) {\n                            var value = textParser.tokensToExp(tokens, vm)\n                            var desc = dirParser.parse(name + ':' + value)[0]\n                            vm._bindDir('attr', el, desc, def)\n                        }\n                    }\n                }\n            }\n\n            /**\n             * Directive priority sort comparator\n             *\n             * @param {Object} a\n             * @param {Object} b\n             */\n\n            function directiveComparator (a, b) {\n                a = a.def.priority || 0\n                b = b.def.priority || 0\n                return a > b ? 1 : -1\n            }\n\n            /**\n             * Check whether an element is transcluded\n             *\n             * @param {Element} el\n             * @return {Boolean}\n             */\n\n            var transcludedFlagAttr = '__vue__transcluded'\n            function checkTransclusion (el) {\n                if (el.nodeType === 1 && el.hasAttribute(transcludedFlagAttr)) {\n                    el.removeAttribute(transcludedFlagAttr)\n                    return true\n                }\n            }\n\n            /***/ },\n        /* 17 */\n        /***/ function(module, exports, __webpack_require__) {\n\n            var _ = __webpack_require__(11)\n            var config = __webpack_require__(15)\n            var templateParser = __webpack_require__(20)\n            var transcludedFlagAttr = '__vue__transcluded'\n\n            /**\n             * Process an element or a DocumentFragment based on a\n             * instance option object. This allows us to transclude\n             * a template node/fragment before the instance is created,\n             * so the processed fragment can then be cloned and reused\n             * in v-repeat.\n             *\n             * @param {Element} el\n             * @param {Object} options\n             * @return {Element|DocumentFragment}\n             */\n\n            module.exports = function transclude (el, options) {\n                if (options && options._asComponent) {\n                    // mutating the options object here assuming the same\n                    // object will be used for compile right after this\n                    options._transcludedAttrs = extractAttrs(el.attributes)\n                    // Mark content nodes and attrs so that the compiler\n                    // knows they should be compiled in parent scope.\n                    var i = el.childNodes.length\n                    while (i--) {\n                        var node = el.childNodes[i]\n                        if (node.nodeType === 1) {\n                            node.setAttribute(transcludedFlagAttr, '')\n                        } else if (node.nodeType === 3 && node.data.trim()) {\n                            // wrap transcluded textNodes in spans, because\n                            // raw textNodes can't be persisted through clones\n                            // by attaching attributes.\n                            var wrapper = document.createElement('span')\n                            wrapper.textContent = node.data\n                            wrapper.setAttribute('__vue__wrap', '')\n                            wrapper.setAttribute(transcludedFlagAttr, '')\n                            el.replaceChild(wrapper, node)\n                        }\n                    }\n                }\n                // for template tags, what we want is its content as\n                // a documentFragment (for block instances)\n                if (el.tagName === 'TEMPLATE') {\n                    el = templateParser.parse(el)\n                }\n                if (options && options.template) {\n                    el = transcludeTemplate(el, options)\n                }\n                if (el instanceof DocumentFragment) {\n                    _.prepend(document.createComment('v-start'), el)\n                    el.appendChild(document.createComment('v-end'))\n                }\n                return el\n            }\n\n            /**\n             * Process the template option.\n             * If the replace option is true this will swap the $el.\n             *\n             * @param {Element} el\n             * @param {Object} options\n             * @return {Element|DocumentFragment}\n             */\n\n            function transcludeTemplate (el, options) {\n                var template = options.template\n                var frag = templateParser.parse(template, true)\n                if (!frag) {\n                    _.warn('Invalid template option: ' + template)\n                } else {\n                    var rawContent = options._content || _.extractContent(el)\n                    if (options.replace) {\n                        if (frag.childNodes.length > 1) {\n                            // this is a block instance which has no root node.\n                            // however, the container in the parent template\n                            // (which is replaced here) may contain v-with and\n                            // paramAttributes that still need to be compiled\n                            // for the child. we store all the container\n                            // attributes on the options object and pass it down\n                            // to the compiler.\n                            var containerAttrs = options._containerAttrs = {}\n                            var i = el.attributes.length\n                            while (i--) {\n                                var attr = el.attributes[i]\n                                containerAttrs[attr.name] = attr.value\n                            }\n                            transcludeContent(frag, rawContent)\n                            return frag\n                        } else {\n                            var replacer = frag.firstChild\n                            _.copyAttributes(el, replacer)\n                            transcludeContent(replacer, rawContent)\n                            return replacer\n                        }\n                    } else {\n                        el.appendChild(frag)\n                        transcludeContent(el, rawContent)\n                        return el\n                    }\n                }\n            }\n\n            /**\n             * Resolve <content> insertion points mimicking the behavior\n             * of the Shadow DOM spec:\n             *\n             *   http://w3c.github.io/webcomponents/spec/shadow/#insertion-points\n             *\n             * @param {Element|DocumentFragment} el\n             * @param {Element} raw\n             */\n\n            function transcludeContent (el, raw) {\n                var outlets = getOutlets(el)\n                var i = outlets.length\n                if (!i) return\n                var outlet, select, selected, j, main\n\n                function isDirectChild (node) {\n                    return node.parentNode === raw\n                }\n\n                // first pass, collect corresponding content\n                // for each outlet.\n                while (i--) {\n                    outlet = outlets[i]\n                    if (raw) {\n                        select = outlet.getAttribute('select')\n                        if (select) {  // select content\n                            selected = raw.querySelectorAll(select)\n                            if (selected.length) {\n                                // according to Shadow DOM spec, `select` can\n                                // only select direct children of the host node.\n                                // enforcing this also fixes #786.\n                                selected = [].filter.call(selected, isDirectChild)\n                            }\n                            outlet.content = selected.length\n                                ? selected\n                                : _.toArray(outlet.childNodes)\n                        } else { // default content\n                            main = outlet\n                        }\n                    } else { // fallback content\n                        outlet.content = _.toArray(outlet.childNodes)\n                    }\n                }\n                // second pass, actually insert the contents\n                for (i = 0, j = outlets.length; i < j; i++) {\n                    outlet = outlets[i]\n                    if (outlet !== main) {\n                        insertContentAt(outlet, outlet.content)\n                    }\n                }\n                // finally insert the main content\n                if (main) {\n                    insertContentAt(main, _.toArray(raw.childNodes))\n                }\n            }\n\n            /**\n             * Get <content> outlets from the element/list\n             *\n             * @param {Element|Array} el\n             * @return {Array}\n             */\n\n            var concat = [].concat\n            function getOutlets (el) {\n                return _.isArray(el)\n                    ? concat.apply([], el.map(getOutlets))\n                    : el.querySelectorAll\n                    ? _.toArray(el.querySelectorAll('content'))\n                    : []\n            }\n\n            /**\n             * Insert an array of nodes at outlet,\n             * then remove the outlet.\n             *\n             * @param {Element} outlet\n             * @param {Array} contents\n             */\n\n            function insertContentAt (outlet, contents) {\n                // not using util DOM methods here because\n                // parentNode can be cached\n                var parent = outlet.parentNode\n                for (var i = 0, j = contents.length; i < j; i++) {\n                    parent.insertBefore(contents[i], outlet)\n                }\n                parent.removeChild(outlet)\n            }\n\n            /**\n             * Helper to extract a component container's attribute names\n             * into a map, and filtering out `v-with` in the process.\n             * The resulting map will be used in compiler/compile to\n             * determine whether an attribute is transcluded.\n             *\n             * @param {NameNodeMap} attrs\n             */\n\n            function extractAttrs (attrs) {\n                if (!attrs) return null\n                var res = {}\n                var vwith = config.prefix + 'with'\n                var i = attrs.length\n                while (i--) {\n                    var name = attrs[i].name\n                    if (name !== vwith) res[name] = true\n                }\n                return res\n            }\n\n            /***/ },\n        /* 18 */\n        /***/ function(module, exports, __webpack_require__) {\n\n            var _ = __webpack_require__(11)\n            var Cache = __webpack_require__(52)\n            var pathCache = new Cache(1000)\n            var identRE = /^[$_a-zA-Z]+[\\w$]*$/\n\n            /**\n             * Path-parsing algorithm scooped from Polymer/observe-js\n             */\n\n            var pathStateMachine = {\n                'beforePath': {\n                    'ws': ['beforePath'],\n                    'ident': ['inIdent', 'append'],\n                    '[': ['beforeElement'],\n                    'eof': ['afterPath']\n                },\n\n                'inPath': {\n                    'ws': ['inPath'],\n                    '.': ['beforeIdent'],\n                    '[': ['beforeElement'],\n                    'eof': ['afterPath']\n                },\n\n                'beforeIdent': {\n                    'ws': ['beforeIdent'],\n                    'ident': ['inIdent', 'append']\n                },\n\n                'inIdent': {\n                    'ident': ['inIdent', 'append'],\n                    '0': ['inIdent', 'append'],\n                    'number': ['inIdent', 'append'],\n                    'ws': ['inPath', 'push'],\n                    '.': ['beforeIdent', 'push'],\n                    '[': ['beforeElement', 'push'],\n                    'eof': ['afterPath', 'push']\n                },\n\n                'beforeElement': {\n                    'ws': ['beforeElement'],\n                    '0': ['afterZero', 'append'],\n                    'number': ['inIndex', 'append'],\n                    \"'\": ['inSingleQuote', 'append', ''],\n                    '\"': ['inDoubleQuote', 'append', '']\n                },\n\n                'afterZero': {\n                    'ws': ['afterElement', 'push'],\n                    ']': ['inPath', 'push']\n                },\n\n                'inIndex': {\n                    '0': ['inIndex', 'append'],\n                    'number': ['inIndex', 'append'],\n                    'ws': ['afterElement'],\n                    ']': ['inPath', 'push']\n                },\n\n                'inSingleQuote': {\n                    \"'\": ['afterElement'],\n                    'eof': 'error',\n                    'else': ['inSingleQuote', 'append']\n                },\n\n                'inDoubleQuote': {\n                    '\"': ['afterElement'],\n                    'eof': 'error',\n                    'else': ['inDoubleQuote', 'append']\n                },\n\n                'afterElement': {\n                    'ws': ['afterElement'],\n                    ']': ['inPath', 'push']\n                }\n            }\n\n            function noop () {}\n\n            /**\n             * Determine the type of a character in a keypath.\n             *\n             * @param {Char} char\n             * @return {String} type\n             */\n\n            function getPathCharType (char) {\n                if (char === undefined) {\n                    return 'eof'\n                }\n\n                var code = char.charCodeAt(0)\n\n                switch(code) {\n                    case 0x5B: // [\n                    case 0x5D: // ]\n                    case 0x2E: // .\n                    case 0x22: // \"\n                    case 0x27: // '\n                    case 0x30: // 0\n                        return char\n\n                    case 0x5F: // _\n                    case 0x24: // $\n                        return 'ident'\n\n                    case 0x20: // Space\n                    case 0x09: // Tab\n                    case 0x0A: // Newline\n                    case 0x0D: // Return\n                    case 0xA0:  // No-break space\n                    case 0xFEFF:  // Byte Order Mark\n                    case 0x2028:  // Line Separator\n                    case 0x2029:  // Paragraph Separator\n                        return 'ws'\n                }\n\n                // a-z, A-Z\n                if ((0x61 <= code && code <= 0x7A) ||\n                    (0x41 <= code && code <= 0x5A)) {\n                    return 'ident'\n                }\n\n                // 1-9\n                if (0x31 <= code && code <= 0x39) {\n                    return 'number'\n                }\n\n                return 'else'\n            }\n\n            /**\n             * Parse a string path into an array of segments\n             * Todo implement cache\n             *\n             * @param {String} path\n             * @return {Array|undefined}\n             */\n\n            function parsePath (path) {\n                var keys = []\n                var index = -1\n                var mode = 'beforePath'\n                var c, newChar, key, type, transition, action, typeMap\n\n                var actions = {\n                    push: function() {\n                        if (key === undefined) {\n                            return\n                        }\n                        keys.push(key)\n                        key = undefined\n                    },\n                    append: function() {\n                        if (key === undefined) {\n                            key = newChar\n                        } else {\n                            key += newChar\n                        }\n                    }\n                }\n\n                function maybeUnescapeQuote () {\n                    var nextChar = path[index + 1]\n                    if ((mode === 'inSingleQuote' && nextChar === \"'\") ||\n                        (mode === 'inDoubleQuote' && nextChar === '\"')) {\n                        index++\n                        newChar = nextChar\n                        actions.append()\n                        return true\n                    }\n                }\n\n                while (mode) {\n                    index++\n                    c = path[index]\n\n                    if (c === '\\\\' && maybeUnescapeQuote()) {\n                        continue\n                    }\n\n                    type = getPathCharType(c)\n                    typeMap = pathStateMachine[mode]\n                    transition = typeMap[type] || typeMap['else'] || 'error'\n\n                    if (transition === 'error') {\n                        return // parse error\n                    }\n\n                    mode = transition[0]\n                    action = actions[transition[1]] || noop\n                    newChar = transition[2] === undefined\n                        ? c\n                        : transition[2]\n                    action()\n\n                    if (mode === 'afterPath') {\n                        return keys\n                    }\n                }\n            }\n\n            /**\n             * Format a accessor segment based on its type.\n             *\n             * @param {String} key\n             * @return {Boolean}\n             */\n\n            function formatAccessor(key) {\n                if (identRE.test(key)) { // identifier\n                    return '.' + key\n                } else if (+key === key >>> 0) { // bracket index\n                    return '[' + key + ']'\n                } else { // bracket string\n                    return '[\"' + key.replace(/\"/g, '\\\\\"') + '\"]'\n                }\n            }\n\n            /**\n             * Compiles a getter function with a fixed path.\n             *\n             * @param {Array} path\n             * @return {Function}\n             */\n\n            exports.compileGetter = function (path) {\n                var body = 'return o' + path.map(formatAccessor).join('')\n                return new Function('o', body)\n            }\n\n            /**\n             * External parse that check for a cache hit first\n             *\n             * @param {String} path\n             * @return {Array|undefined}\n             */\n\n            exports.parse = function (path) {\n                var hit = pathCache.get(path)\n                if (!hit) {\n                    hit = parsePath(path)\n                    if (hit) {\n                        hit.get = exports.compileGetter(hit)\n                        pathCache.put(path, hit)\n                    }\n                }\n                return hit\n            }\n\n            /**\n             * Get from an object from a path string\n             *\n             * @param {Object} obj\n             * @param {String} path\n             */\n\n            exports.get = function (obj, path) {\n                path = exports.parse(path)\n                if (path) {\n                    return path.get(obj)\n                }\n            }\n\n            /**\n             * Set on an object from a path\n             *\n             * @param {Object} obj\n             * @param {String | Array} path\n             * @param {*} val\n             */\n\n            exports.set = function (obj, path, val) {\n                if (typeof path === 'string') {\n                    path = exports.parse(path)\n                }\n                if (!path || !_.isObject(obj)) {\n                    return false\n                }\n                var last, key\n                for (var i = 0, l = path.length - 1; i < l; i++) {\n                    last = obj\n                    key = path[i]\n                    obj = obj[key]\n                    if (!_.isObject(obj)) {\n                        obj = {}\n                        last.$add(key, obj)\n                    }\n                }\n                key = path[i]\n                if (key in obj) {\n                    obj[key] = val\n                } else {\n                    obj.$add(key, val)\n                }\n                return true\n            }\n\n            /***/ },\n        /* 19 */\n        /***/ function(module, exports, __webpack_require__) {\n\n            var Cache = __webpack_require__(52)\n            var config = __webpack_require__(15)\n            var dirParser = __webpack_require__(21)\n            var regexEscapeRE = /[-.*+?^${}()|[\\]\\/\\\\]/g\n            var cache, tagRE, htmlRE, firstChar, lastChar\n\n            /**\n             * Escape a string so it can be used in a RegExp\n             * constructor.\n             *\n             * @param {String} str\n             */\n\n            function escapeRegex (str) {\n                return str.replace(regexEscapeRE, '\\\\$&')\n            }\n\n            /**\n             * Compile the interpolation tag regex.\n             *\n             * @return {RegExp}\n             */\n\n            function compileRegex () {\n                config._delimitersChanged = false\n                var open = config.delimiters[0]\n                var close = config.delimiters[1]\n                firstChar = open.charAt(0)\n                lastChar = close.charAt(close.length - 1)\n                var firstCharRE = escapeRegex(firstChar)\n                var lastCharRE = escapeRegex(lastChar)\n                var openRE = escapeRegex(open)\n                var closeRE = escapeRegex(close)\n                tagRE = new RegExp(\n                    firstCharRE + '?' + openRE +\n                    '(.+?)' +\n                    closeRE + lastCharRE + '?',\n                    'g'\n                )\n                htmlRE = new RegExp(\n                    '^' + firstCharRE + openRE +\n                    '.*' +\n                    closeRE + lastCharRE + '$'\n                )\n                // reset cache\n                cache = new Cache(1000)\n            }\n\n            /**\n             * Parse a template text string into an array of tokens.\n             *\n             * @param {String} text\n             * @return {Array<Object> | null}\n             *               - {String} type\n             *               - {String} value\n             *               - {Boolean} [html]\n             *               - {Boolean} [oneTime]\n             */\n\n            exports.parse = function (text) {\n                if (config._delimitersChanged) {\n                    compileRegex()\n                }\n                var hit = cache.get(text)\n                if (hit) {\n                    return hit\n                }\n                if (!tagRE.test(text)) {\n                    return null\n                }\n                var tokens = []\n                var lastIndex = tagRE.lastIndex = 0\n                var match, index, value, first, oneTime, partial\n                /* jshint boss:true */\n                while (match = tagRE.exec(text)) {\n                    index = match.index\n                    // push text token\n                    if (index > lastIndex) {\n                        tokens.push({\n                            value: text.slice(lastIndex, index)\n                        })\n                    }\n                    // tag token\n                    first = match[1].charCodeAt(0)\n                    oneTime = first === 0x2A // *\n                    partial = first === 0x3E // >\n                    value = (oneTime || partial)\n                        ? match[1].slice(1)\n                        : match[1]\n                    tokens.push({\n                        tag: true,\n                        value: value.trim(),\n                        html: htmlRE.test(match[0]),\n                        oneTime: oneTime,\n                        partial: partial\n                    })\n                    lastIndex = index + match[0].length\n                }\n                if (lastIndex < text.length) {\n                    tokens.push({\n                        value: text.slice(lastIndex)\n                    })\n                }\n                cache.put(text, tokens)\n                return tokens\n            }\n\n            /**\n             * Format a list of tokens into an expression.\n             * e.g. tokens parsed from 'a {{b}} c' can be serialized\n             * into one single expression as '\"a \" + b + \" c\"'.\n             *\n             * @param {Array} tokens\n             * @param {Vue} [vm]\n             * @return {String}\n             */\n\n            exports.tokensToExp = function (tokens, vm) {\n                return tokens.length > 1\n                    ? tokens.map(function (token) {\n                    return formatToken(token, vm)\n                }).join('+')\n                    : formatToken(tokens[0], vm, true)\n            }\n\n            /**\n             * Format a single token.\n             *\n             * @param {Object} token\n             * @param {Vue} [vm]\n             * @param {Boolean} single\n             * @return {String}\n             */\n\n            function formatToken (token, vm, single) {\n                return token.tag\n                    ? vm && token.oneTime\n                    ? '\"' + vm.$eval(token.value) + '\"'\n                    : single\n                    ? token.value\n                    : inlineFilters(token.value)\n                    : '\"' + token.value + '\"'\n            }\n\n            /**\n             * For an attribute with multiple interpolation tags,\n             * e.g. attr=\"some-{{thing | filter}}\", in order to combine\n             * the whole thing into a single watchable expression, we\n             * have to inline those filters. This function does exactly\n             * that. This is a bit hacky but it avoids heavy changes\n             * to directive parser and watcher mechanism.\n             *\n             * @param {String} exp\n             * @return {String}\n             */\n\n            var filterRE = /[^|]\\|[^|]/\n            function inlineFilters (exp) {\n                if (!filterRE.test(exp)) {\n                    return '(' + exp + ')'\n                } else {\n                    var dir = dirParser.parse(exp)[0]\n                    if (!dir.filters) {\n                        return '(' + exp + ')'\n                    } else {\n                        exp = dir.expression\n                        for (var i = 0, l = dir.filters.length; i < l; i++) {\n                            var filter = dir.filters[i]\n                            var args = filter.args\n                                ? ',\"' + filter.args.join('\",\"') + '\"'\n                                : ''\n                            filter = 'this.$options.filters[\"' + filter.name + '\"]'\n                            exp = '(' + filter + '.read||' + filter + ')' +\n                            '.apply(this,[' + exp + args + '])'\n                        }\n                        return exp\n                    }\n                }\n            }\n\n            /***/ },\n        /* 20 */\n        /***/ function(module, exports, __webpack_require__) {\n\n            var _ = __webpack_require__(11)\n            var Cache = __webpack_require__(52)\n            var templateCache = new Cache(1000)\n            var idSelectorCache = new Cache(1000)\n\n            var map = {\n                _default : [0, '', ''],\n                legend   : [1, '<fieldset>', '</fieldset>'],\n                tr       : [2, '<table><tbody>', '</tbody></table>'],\n                col      : [\n                    2,\n                    '<table><tbody></tbody><colgroup>',\n                    '</colgroup></table>'\n                ]\n            }\n\n            map.td =\n                map.th = [\n                    3,\n                    '<table><tbody><tr>',\n                    '</tr></tbody></table>'\n                ]\n\n            map.option =\n                map.optgroup = [\n                    1,\n                    '<select multiple=\"multiple\">',\n                    '</select>'\n                ]\n\n            map.thead =\n                map.tbody =\n                    map.colgroup =\n                        map.caption =\n                            map.tfoot = [1, '<table>', '</table>']\n\n            map.g =\n                map.defs =\n                    map.symbol =\n                        map.use =\n                            map.image =\n                                map.text =\n                                    map.circle =\n                                        map.ellipse =\n                                            map.line =\n                                                map.path =\n                                                    map.polygon =\n                                                        map.polyline =\n                                                            map.rect = [\n                                                                1,\n                                                                '<svg ' +\n                                                                'xmlns=\"http://www.w3.org/2000/svg\" ' +\n                                                                'xmlns:xlink=\"http://www.w3.org/1999/xlink\" ' +\n                                                                'xmlns:ev=\"http://www.w3.org/2001/xml-events\"' +\n                                                                'version=\"1.1\">',\n                                                                '</svg>'\n                                                            ]\n\n            var tagRE = /<([\\w:]+)/\n            var entityRE = /&\\w+;/\n\n            /**\n             * Convert a string template to a DocumentFragment.\n             * Determines correct wrapping by tag types. Wrapping\n             * strategy found in jQuery & component/domify.\n             *\n             * @param {String} templateString\n             * @return {DocumentFragment}\n             */\n\n            function stringToFragment (templateString) {\n                // try a cache hit first\n                var hit = templateCache.get(templateString)\n                if (hit) {\n                    return hit\n                }\n\n                var frag = document.createDocumentFragment()\n                var tagMatch = templateString.match(tagRE)\n                var entityMatch = entityRE.test(templateString)\n\n                if (!tagMatch && !entityMatch) {\n                    // text only, return a single text node.\n                    frag.appendChild(\n                        document.createTextNode(templateString)\n                    )\n                } else {\n\n                    var tag    = tagMatch && tagMatch[1]\n                    var wrap   = map[tag] || map._default\n                    var depth  = wrap[0]\n                    var prefix = wrap[1]\n                    var suffix = wrap[2]\n                    var node   = document.createElement('div')\n\n                    node.innerHTML = prefix + templateString.trim() + suffix\n                    while (depth--) {\n                        node = node.lastChild\n                    }\n\n                    var child\n                    /* jshint boss:true */\n                    while (child = node.firstChild) {\n                        frag.appendChild(child)\n                    }\n                }\n\n                templateCache.put(templateString, frag)\n                return frag\n            }\n\n            /**\n             * Convert a template node to a DocumentFragment.\n             *\n             * @param {Node} node\n             * @return {DocumentFragment}\n             */\n\n            function nodeToFragment (node) {\n                var tag = node.tagName\n                // if its a template tag and the browser supports it,\n                // its content is already a document fragment.\n                if (\n                    tag === 'TEMPLATE' &&\n                    node.content instanceof DocumentFragment\n                ) {\n                    return node.content\n                }\n                // script template\n                if (tag === 'SCRIPT') {\n                    return stringToFragment(node.textContent)\n                }\n                // normal node, clone it to avoid mutating the original\n                var clone = exports.clone(node)\n                var frag = document.createDocumentFragment()\n                var child\n                /* jshint boss:true */\n                while (child = clone.firstChild) {\n                    frag.appendChild(child)\n                }\n                return frag\n            }\n\n            // Test for the presence of the Safari template cloning bug\n            // https://bugs.webkit.org/show_bug.cgi?id=137755\n            var hasBrokenTemplate = _.inBrowser\n                ? (function () {\n                var a = document.createElement('div')\n                a.innerHTML = '<template>1</template>'\n                return !a.cloneNode(true).firstChild.innerHTML\n            })()\n                : false\n\n            // Test for IE10/11 textarea placeholder clone bug\n            var hasTextareaCloneBug = _.inBrowser\n                ? (function () {\n                var t = document.createElement('textarea')\n                t.placeholder = 't'\n                return t.cloneNode(true).value === 't'\n            })()\n                : false\n\n            /**\n             * 1. Deal with Safari cloning nested <template> bug by\n             *    manually cloning all template instances.\n             * 2. Deal with IE10/11 textarea placeholder bug by setting\n             *    the correct value after cloning.\n             *\n             * @param {Element|DocumentFragment} node\n             * @return {Element|DocumentFragment}\n             */\n\n            exports.clone = function (node) {\n                var res = node.cloneNode(true)\n                var i, original, cloned\n                /* istanbul ignore if */\n                if (hasBrokenTemplate) {\n                    original = node.querySelectorAll('template')\n                    if (original.length) {\n                        cloned = res.querySelectorAll('template')\n                        i = cloned.length\n                        while (i--) {\n                            cloned[i].parentNode.replaceChild(\n                                original[i].cloneNode(true),\n                                cloned[i]\n                            )\n                        }\n                    }\n                }\n                /* istanbul ignore if */\n                if (hasTextareaCloneBug) {\n                    if (node.tagName === 'TEXTAREA') {\n                        res.value = node.value\n                    } else {\n                        original = node.querySelectorAll('textarea')\n                        if (original.length) {\n                            cloned = res.querySelectorAll('textarea')\n                            i = cloned.length\n                            while (i--) {\n                                cloned[i].value = original[i].value\n                            }\n                        }\n                    }\n                }\n                return res\n            }\n\n            /**\n             * Process the template option and normalizes it into a\n             * a DocumentFragment that can be used as a partial or a\n             * instance template.\n             *\n             * @param {*} template\n             *    Possible values include:\n             *    - DocumentFragment object\n             *    - Node object of type Template\n             *    - id selector: '#some-template-id'\n             *    - template string: '<div><span>{{msg}}</span></div>'\n             * @param {Boolean} clone\n             * @param {Boolean} noSelector\n             * @return {DocumentFragment|undefined}\n             */\n\n            exports.parse = function (template, clone, noSelector) {\n                var node, frag\n\n                // if the template is already a document fragment,\n                // do nothing\n                if (template instanceof DocumentFragment) {\n                    return clone\n                        ? template.cloneNode(true)\n                        : template\n                }\n\n                if (typeof template === 'string') {\n                    // id selector\n                    if (!noSelector && template.charAt(0) === '#') {\n                        // id selector can be cached too\n                        frag = idSelectorCache.get(template)\n                        if (!frag) {\n                            node = document.getElementById(template.slice(1))\n                            if (node) {\n                                frag = nodeToFragment(node)\n                                // save selector to cache\n                                idSelectorCache.put(template, frag)\n                            }\n                        }\n                    } else {\n                        // normal string template\n                        frag = stringToFragment(template)\n                    }\n                } else if (template.nodeType) {\n                    // a direct node\n                    frag = nodeToFragment(template)\n                }\n\n                return frag && clone\n                    ? exports.clone(frag)\n                    : frag\n            }\n\n            /***/ },\n        /* 21 */\n        /***/ function(module, exports, __webpack_require__) {\n\n            var _ = __webpack_require__(11)\n            var Cache = __webpack_require__(52)\n            var cache = new Cache(1000)\n            var argRE = /^[^\\{\\?]+$|^'[^']*'$|^\"[^\"]*\"$/\n            var filterTokenRE = /[^\\s'\"]+|'[^']+'|\"[^\"]+\"/g\n\n            /**\n             * Parser state\n             */\n\n            var str\n            var c, i, l\n            var inSingle\n            var inDouble\n            var curly\n            var square\n            var paren\n            var begin\n            var argIndex\n            var dirs\n            var dir\n            var lastFilterIndex\n            var arg\n\n            /**\n             * Push a directive object into the result Array\n             */\n\n            function pushDir () {\n                dir.raw = str.slice(begin, i).trim()\n                if (dir.expression === undefined) {\n                    dir.expression = str.slice(argIndex, i).trim()\n                } else if (lastFilterIndex !== begin) {\n                    pushFilter()\n                }\n                if (i === 0 || dir.expression) {\n                    dirs.push(dir)\n                }\n            }\n\n            /**\n             * Push a filter to the current directive object\n             */\n\n            function pushFilter () {\n                var exp = str.slice(lastFilterIndex, i).trim()\n                var filter\n                if (exp) {\n                    filter = {}\n                    var tokens = exp.match(filterTokenRE)\n                    filter.name = tokens[0]\n                    filter.args = tokens.length > 1 ? tokens.slice(1) : null\n                }\n                if (filter) {\n                    (dir.filters = dir.filters || []).push(filter)\n                }\n                lastFilterIndex = i + 1\n            }\n\n            /**\n             * Parse a directive string into an Array of AST-like\n             * objects representing directives.\n             *\n             * Example:\n             *\n             * \"click: a = a + 1 | uppercase\" will yield:\n             * {\n\t *   arg: 'click',\n\t *   expression: 'a = a + 1',\n\t *   filters: [\n\t *     { name: 'uppercase', args: null }\n\t *   ]\n\t * }\n             *\n             * @param {String} str\n             * @return {Array<Object>}\n             */\n\n            exports.parse = function (s) {\n\n                var hit = cache.get(s)\n                if (hit) {\n                    return hit\n                }\n\n                // reset parser state\n                str = s\n                inSingle = inDouble = false\n                curly = square = paren = begin = argIndex = 0\n                lastFilterIndex = 0\n                dirs = []\n                dir = {}\n                arg = null\n\n                for (i = 0, l = str.length; i < l; i++) {\n                    c = str.charCodeAt(i)\n                    if (inSingle) {\n                        // check single quote\n                        if (c === 0x27) inSingle = !inSingle\n                    } else if (inDouble) {\n                        // check double quote\n                        if (c === 0x22) inDouble = !inDouble\n                    } else if (\n                        c === 0x2C && // comma\n                        !paren && !curly && !square\n                    ) {\n                        // reached the end of a directive\n                        pushDir()\n                        // reset & skip the comma\n                        dir = {}\n                        begin = argIndex = lastFilterIndex = i + 1\n                    } else if (\n                        c === 0x3A && // colon\n                        !dir.expression &&\n                        !dir.arg\n                    ) {\n                        // argument\n                        arg = str.slice(begin, i).trim()\n                        // test for valid argument here\n                        // since we may have caught stuff like first half of\n                        // an object literal or a ternary expression.\n                        if (argRE.test(arg)) {\n                            argIndex = i + 1\n                            dir.arg = _.stripQuotes(arg) || arg\n                        }\n                    } else if (\n                        c === 0x7C && // pipe\n                        str.charCodeAt(i + 1) !== 0x7C &&\n                        str.charCodeAt(i - 1) !== 0x7C\n                    ) {\n                        if (dir.expression === undefined) {\n                            // first filter, end of expression\n                            lastFilterIndex = i + 1\n                            dir.expression = str.slice(argIndex, i).trim()\n                        } else {\n                            // already has filter\n                            pushFilter()\n                        }\n                    } else {\n                        switch (c) {\n                            case 0x22: inDouble = true; break // \"\n                            case 0x27: inSingle = true; break // '\n                            case 0x28: paren++; break         // (\n                            case 0x29: paren--; break         // )\n                            case 0x5B: square++; break        // [\n                            case 0x5D: square--; break        // ]\n                            case 0x7B: curly++; break         // {\n                            case 0x7D: curly--; break         // }\n                        }\n                    }\n                }\n\n                if (i === 0 || begin !== i) {\n                    pushDir()\n                }\n\n                cache.put(s, dirs)\n                return dirs\n            }\n\n            /***/ },\n        /* 22 */\n        /***/ function(module, exports, __webpack_require__) {\n\n            var _ = __webpack_require__(11)\n            var Path = __webpack_require__(18)\n            var Cache = __webpack_require__(52)\n            var expressionCache = new Cache(1000)\n\n            var allowedKeywords =\n                'Math,Date,this,true,false,null,undefined,Infinity,NaN,' +\n                'isNaN,isFinite,decodeURI,decodeURIComponent,encodeURI,' +\n                'encodeURIComponent,parseInt,parseFloat'\n            var allowedKeywordsRE =\n                new RegExp('^(' + allowedKeywords.replace(/,/g, '\\\\b|') + '\\\\b)')\n\n            // keywords that don't make sense inside expressions\n            var improperKeywords =\n                'break,case,class,catch,const,continue,debugger,default,' +\n                'delete,do,else,export,extends,finally,for,function,if,' +\n                'import,in,instanceof,let,return,super,switch,throw,try,' +\n                'var,while,with,yield,enum,await,implements,package,' +\n                'proctected,static,interface,private,public'\n            var improperKeywordsRE =\n                new RegExp('^(' + improperKeywords.replace(/,/g, '\\\\b|') + '\\\\b)')\n\n            var wsRE = /\\s/g\n            var newlineRE = /\\n/g\n            var saveRE = /[\\{,]\\s*[\\w\\$_]+\\s*:|('[^']*'|\"[^\"]*\")|new |typeof |void /g\n            var restoreRE = /\"(\\d+)\"/g\n            var pathTestRE = /^[A-Za-z_$][\\w$]*(\\.[A-Za-z_$][\\w$]*|\\['.*?'\\]|\\[\".*?\"\\]|\\[\\d+\\])*$/\n            var pathReplaceRE = /[^\\w$\\.]([A-Za-z_$][\\w$]*(\\.[A-Za-z_$][\\w$]*|\\['.*?'\\]|\\[\".*?\"\\])*)/g\n            var booleanLiteralRE = /^(true|false)$/\n\n            /**\n             * Save / Rewrite / Restore\n             *\n             * When rewriting paths found in an expression, it is\n             * possible for the same letter sequences to be found in\n             * strings and Object literal property keys. Therefore we\n             * remove and store these parts in a temporary array, and\n             * restore them after the path rewrite.\n             */\n\n            var saved = []\n\n            /**\n             * Save replacer\n             *\n             * The save regex can match two possible cases:\n             * 1. An opening object literal\n             * 2. A string\n             * If matched as a plain string, we need to escape its\n             * newlines, since the string needs to be preserved when\n             * generating the function body.\n             *\n             * @param {String} str\n             * @param {String} isString - str if matched as a string\n             * @return {String} - placeholder with index\n             */\n\n            function save (str, isString) {\n                var i = saved.length\n                saved[i] = isString\n                    ? str.replace(newlineRE, '\\\\n')\n                    : str\n                return '\"' + i + '\"'\n            }\n\n            /**\n             * Path rewrite replacer\n             *\n             * @param {String} raw\n             * @return {String}\n             */\n\n            function rewrite (raw) {\n                var c = raw.charAt(0)\n                var path = raw.slice(1)\n                if (allowedKeywordsRE.test(path)) {\n                    return raw\n                } else {\n                    path = path.indexOf('\"') > -1\n                        ? path.replace(restoreRE, restore)\n                        : path\n                    return c + 'scope.' + path\n                }\n            }\n\n            /**\n             * Restore replacer\n             *\n             * @param {String} str\n             * @param {String} i - matched save index\n             * @return {String}\n             */\n\n            function restore (str, i) {\n                return saved[i]\n            }\n\n            /**\n             * Rewrite an expression, prefixing all path accessors with\n             * `scope.` and generate getter/setter functions.\n             *\n             * @param {String} exp\n             * @param {Boolean} needSet\n             * @return {Function}\n             */\n\n            function compileExpFns (exp, needSet) {\n                if (improperKeywordsRE.test(exp)) {\n                    _.warn(\n                        'Avoid using reserved keywords in expression: '\n                        + exp\n                    )\n                }\n                // reset state\n                saved.length = 0\n                // save strings and object literal keys\n                var body = exp\n                    .replace(saveRE, save)\n                    .replace(wsRE, '')\n                // rewrite all paths\n                // pad 1 space here becaue the regex matches 1 extra char\n                body = (' ' + body)\n                    .replace(pathReplaceRE, rewrite)\n                    .replace(restoreRE, restore)\n                var getter = makeGetter(body)\n                if (getter) {\n                    return {\n                        get: getter,\n                        body: body,\n                        set: needSet\n                            ? makeSetter(body)\n                            : null\n                    }\n                }\n            }\n\n            /**\n             * Compile getter setters for a simple path.\n             *\n             * @param {String} exp\n             * @return {Function}\n             */\n\n            function compilePathFns (exp) {\n                var getter, path\n                if (exp.indexOf('[') < 0) {\n                    // really simple path\n                    path = exp.split('.')\n                    getter = Path.compileGetter(path)\n                } else {\n                    // do the real parsing\n                    path = Path.parse(exp)\n                    getter = path.get\n                }\n                return {\n                    get: getter,\n                    // always generate setter for simple paths\n                    set: function (obj, val) {\n                        Path.set(obj, path, val)\n                    }\n                }\n            }\n\n            /**\n             * Build a getter function. Requires eval.\n             *\n             * We isolate the try/catch so it doesn't affect the\n             * optimization of the parse function when it is not called.\n             *\n             * @param {String} body\n             * @return {Function|undefined}\n             */\n\n            function makeGetter (body) {\n                try {\n                    return new Function('scope', 'return ' + body + ';')\n                } catch (e) {\n                    _.warn(\n                        'Invalid expression. ' +\n                        'Generated function body: ' + body\n                    )\n                }\n            }\n\n            /**\n             * Build a setter function.\n             *\n             * This is only needed in rare situations like \"a[b]\" where\n             * a settable path requires dynamic evaluation.\n             *\n             * This setter function may throw error when called if the\n             * expression body is not a valid left-hand expression in\n             * assignment.\n             *\n             * @param {String} body\n             * @return {Function|undefined}\n             */\n\n            function makeSetter (body) {\n                try {\n                    return new Function('scope', 'value', body + '=value;')\n                } catch (e) {\n                    _.warn('Invalid setter function body: ' + body)\n                }\n            }\n\n            /**\n             * Check for setter existence on a cache hit.\n             *\n             * @param {Function} hit\n             */\n\n            function checkSetter (hit) {\n                if (!hit.set) {\n                    hit.set = makeSetter(hit.body)\n                }\n            }\n\n            /**\n             * Parse an expression into re-written getter/setters.\n             *\n             * @param {String} exp\n             * @param {Boolean} needSet\n             * @return {Function}\n             */\n\n            exports.parse = function (exp, needSet) {\n                exp = exp.trim()\n                // try cache\n                var hit = expressionCache.get(exp)\n                if (hit) {\n                    if (needSet) {\n                        checkSetter(hit)\n                    }\n                    return hit\n                }\n                // we do a simple path check to optimize for them.\n                // the check fails valid paths with unusal whitespaces,\n                // but that's too rare and we don't care.\n                // also skip boolean literals and paths that start with\n                // global \"Math\"\n                var res =\n                    pathTestRE.test(exp) &&\n                        // don't treat true/false as paths\n                    !booleanLiteralRE.test(exp) &&\n                        // Math constants e.g. Math.PI, Math.E etc.\n                    exp.slice(0, 5) !== 'Math.'\n                        ? compilePathFns(exp)\n                        : compileExpFns(exp, needSet)\n                expressionCache.put(exp, res)\n                return res\n            }\n\n            // Export the pathRegex for external use\n            exports.pathTestRE = pathTestRE\n\n            /***/ },\n        /* 23 */\n        /***/ function(module, exports, __webpack_require__) {\n\n            var uid = 0\n            var _ = __webpack_require__(11)\n\n            /**\n             * A dep is an observable that can have multiple\n             * directives subscribing to it.\n             *\n             * @constructor\n             */\n\n            function Dep () {\n                this.id = ++uid\n                this.subs = []\n            }\n\n            var p = Dep.prototype\n\n            /**\n             * Add a directive subscriber.\n             *\n             * @param {Directive} sub\n             */\n\n            p.addSub = function (sub) {\n                this.subs.push(sub)\n            }\n\n            /**\n             * Remove a directive subscriber.\n             *\n             * @param {Directive} sub\n             */\n\n            p.removeSub = function (sub) {\n                if (this.subs.length) {\n                    var i = this.subs.indexOf(sub)\n                    if (i > -1) this.subs.splice(i, 1)\n                }\n            }\n\n            /**\n             * Notify all subscribers of a new value.\n             */\n\n            p.notify = function () {\n                // stablize the subscriber list first\n                var subs = _.toArray(this.subs)\n                for (var i = 0, l = subs.length; i < l; i++) {\n                    subs[i].update()\n                }\n            }\n\n            module.exports = Dep\n\n            /***/ },\n        /* 24 */\n        /***/ function(module, exports, __webpack_require__) {\n\n            var _ = __webpack_require__(11)\n            var config = __webpack_require__(15)\n            var Watcher = __webpack_require__(25)\n            var textParser = __webpack_require__(19)\n            var expParser = __webpack_require__(22)\n\n            /**\n             * A directive links a DOM element with a piece of data,\n             * which is the result of evaluating an expression.\n             * It registers a watcher with the expression and calls\n             * the DOM update function when a change is triggered.\n             *\n             * @param {String} name\n             * @param {Node} el\n             * @param {Vue} vm\n             * @param {Object} descriptor\n             *                 - {String} expression\n             *                 - {String} [arg]\n             *                 - {Array<Object>} [filters]\n             * @param {Object} def - directive definition object\n             * @param {Vue|undefined} host - transclusion host target\n             * @constructor\n             */\n\n            function Directive (name, el, vm, descriptor, def, host) {\n                // public\n                this.name = name\n                this.el = el\n                this.vm = vm\n                // copy descriptor props\n                this.raw = descriptor.raw\n                this.expression = descriptor.expression\n                this.arg = descriptor.arg\n                this.filters = _.resolveFilters(vm, descriptor.filters)\n                // private\n                this._host = host\n                this._locked = false\n                this._bound = false\n                // init\n                this._bind(def)\n            }\n\n            var p = Directive.prototype\n\n            /**\n             * Initialize the directive, mixin definition properties,\n             * setup the watcher, call definition bind() and update()\n             * if present.\n             *\n             * @param {Object} def\n             */\n\n            p._bind = function (def) {\n                if (this.name !== 'cloak' && this.el && this.el.removeAttribute) {\n                    this.el.removeAttribute(config.prefix + this.name)\n                }\n                if (typeof def === 'function') {\n                    this.update = def\n                } else {\n                    _.extend(this, def)\n                }\n                this._watcherExp = this.expression\n                this._checkDynamicLiteral()\n                if (this.bind) {\n                    this.bind()\n                }\n                if (this._watcherExp &&\n                    (this.update || this.twoWay) &&\n                    (!this.isLiteral || this._isDynamicLiteral) &&\n                    !this._checkStatement()) {\n                    // wrapped updater for context\n                    var dir = this\n                    var update = this._update = this.update\n                        ? function (val, oldVal) {\n                        if (!dir._locked) {\n                            dir.update(val, oldVal)\n                        }\n                    }\n                        : function () {} // noop if no update is provided\n                    // use raw expression as identifier because filters\n                    // make them different watchers\n                    var watcher = this.vm._watchers[this.raw]\n                    // v-repeat always creates a new watcher because it has\n                    // a special filter that's bound to its directive\n                    // instance.\n                    if (!watcher || this.name === 'repeat') {\n                        watcher = this.vm._watchers[this.raw] = new Watcher(\n                            this.vm,\n                            this._watcherExp,\n                            update, // callback\n                            {\n                                filters: this.filters,\n                                twoWay: this.twoWay,\n                                deep: this.deep\n                            }\n                        )\n                    } else {\n                        watcher.addCb(update)\n                    }\n                    this._watcher = watcher\n                    if (this._initValue != null) {\n                        watcher.set(this._initValue)\n                    } else if (this.update) {\n                        this.update(watcher.value)\n                    }\n                }\n                this._bound = true\n            }\n\n            /**\n             * check if this is a dynamic literal binding.\n             *\n             * e.g. v-component=\"{{currentView}}\"\n             */\n\n            p._checkDynamicLiteral = function () {\n                var expression = this.expression\n                if (expression && this.isLiteral) {\n                    var tokens = textParser.parse(expression)\n                    if (tokens) {\n                        var exp = textParser.tokensToExp(tokens)\n                        this.expression = this.vm.$get(exp)\n                        this._watcherExp = exp\n                        this._isDynamicLiteral = true\n                    }\n                }\n            }\n\n            /**\n             * Check if the directive is a function caller\n             * and if the expression is a callable one. If both true,\n             * we wrap up the expression and use it as the event\n             * handler.\n             *\n             * e.g. v-on=\"click: a++\"\n             *\n             * @return {Boolean}\n             */\n\n            p._checkStatement = function () {\n                var expression = this.expression\n                if (\n                    expression && this.acceptStatement &&\n                    !expParser.pathTestRE.test(expression)\n                ) {\n                    var fn = expParser.parse(expression).get\n                    var vm = this.vm\n                    var handler = function () {\n                        fn.call(vm, vm)\n                    }\n                    if (this.filters) {\n                        handler = _.applyFilters(\n                            handler,\n                            this.filters.read,\n                            vm\n                        )\n                    }\n                    this.update(handler)\n                    return true\n                }\n            }\n\n            /**\n             * Check for an attribute directive param, e.g. lazy\n             *\n             * @param {String} name\n             * @return {String}\n             */\n\n            p._checkParam = function (name) {\n                var param = this.el.getAttribute(name)\n                if (param !== null) {\n                    this.el.removeAttribute(name)\n                }\n                return param\n            }\n\n            /**\n             * Teardown the watcher and call unbind.\n             */\n\n            p._teardown = function () {\n                if (this._bound) {\n                    if (this.unbind) {\n                        this.unbind()\n                    }\n                    var watcher = this._watcher\n                    if (watcher && watcher.active) {\n                        watcher.removeCb(this._update)\n                        if (!watcher.active) {\n                            this.vm._watchers[this.raw] = null\n                        }\n                    }\n                    this._bound = false\n                    this.vm = this.el = this._watcher = null\n                }\n            }\n\n            /**\n             * Set the corresponding value with the setter.\n             * This should only be used in two-way directives\n             * e.g. v-model.\n             *\n             * @param {*} value\n             * @param {Boolean} lock - prevent wrtie triggering update.\n             * @public\n             */\n\n            p.set = function (value, lock) {\n                if (this.twoWay) {\n                    if (lock) {\n                        this._locked = true\n                    }\n                    this._watcher.set(value)\n                    if (lock) {\n                        var self = this\n                        _.nextTick(function () {\n                            self._locked = false\n                        })\n                    }\n                }\n            }\n\n            module.exports = Directive\n\n            /***/ },\n        /* 25 */\n        /***/ function(module, exports, __webpack_require__) {\n\n            var _ = __webpack_require__(11)\n            var config = __webpack_require__(15)\n            var Observer = __webpack_require__(49)\n            var expParser = __webpack_require__(22)\n            var batcher = __webpack_require__(53)\n            var uid = 0\n\n            /**\n             * A watcher parses an expression, collects dependencies,\n             * and fires callback when the expression value changes.\n             * This is used for both the $watch() api and directives.\n             *\n             * @param {Vue} vm\n             * @param {String} expression\n             * @param {Function} cb\n             * @param {Object} options\n             *                 - {Array} filters\n             *                 - {Boolean} twoWay\n             *                 - {Boolean} deep\n             *                 - {Boolean} user\n             * @constructor\n             */\n\n            function Watcher (vm, expression, cb, options) {\n                this.vm = vm\n                vm._watcherList.push(this)\n                this.expression = expression\n                this.cbs = [cb]\n                this.id = ++uid // uid for batching\n                this.active = true\n                options = options || {}\n                this.deep = !!options.deep\n                this.user = !!options.user\n                this.deps = Object.create(null)\n                // setup filters if any.\n                // We delegate directive filters here to the watcher\n                // because they need to be included in the dependency\n                // collection process.\n                if (options.filters) {\n                    this.readFilters = options.filters.read\n                    this.writeFilters = options.filters.write\n                }\n                // parse expression for getter/setter\n                var res = expParser.parse(expression, options.twoWay)\n                this.getter = res.get\n                this.setter = res.set\n                this.value = this.get()\n            }\n\n            var p = Watcher.prototype\n\n            /**\n             * Add a dependency to this directive.\n             *\n             * @param {Dep} dep\n             */\n\n            p.addDep = function (dep) {\n                var id = dep.id\n                if (!this.newDeps[id]) {\n                    this.newDeps[id] = dep\n                    if (!this.deps[id]) {\n                        this.deps[id] = dep\n                        dep.addSub(this)\n                    }\n                }\n            }\n\n            /**\n             * Evaluate the getter, and re-collect dependencies.\n             */\n\n            p.get = function () {\n                this.beforeGet()\n                var vm = this.vm\n                var value\n                try {\n                    value = this.getter.call(vm, vm)\n                } catch (e) {\n                    if (config.warnExpressionErrors) {\n                        _.warn(\n                            'Error when evaluating expression \"' +\n                            this.expression + '\":\\n   ' + e\n                        )\n                    }\n                }\n                // \"touch\" every property so they are all tracked as\n                // dependencies for deep watching\n                if (this.deep) {\n                    traverse(value)\n                }\n                value = _.applyFilters(value, this.readFilters, vm)\n                this.afterGet()\n                return value\n            }\n\n            /**\n             * Set the corresponding value with the setter.\n             *\n             * @param {*} value\n             */\n\n            p.set = function (value) {\n                var vm = this.vm\n                value = _.applyFilters(\n                    value, this.writeFilters, vm, this.value\n                )\n                try {\n                    this.setter.call(vm, vm, value)\n                } catch (e) {\n                    if (config.warnExpressionErrors) {\n                        _.warn(\n                            'Error when evaluating setter \"' +\n                            this.expression + '\":\\n   ' + e\n                        )\n                    }\n                }\n            }\n\n            /**\n             * Prepare for dependency collection.\n             */\n\n            p.beforeGet = function () {\n                Observer.target = this\n                this.newDeps = {}\n            }\n\n            /**\n             * Clean up for dependency collection.\n             */\n\n            p.afterGet = function () {\n                Observer.target = null\n                for (var id in this.deps) {\n                    if (!this.newDeps[id]) {\n                        this.deps[id].removeSub(this)\n                    }\n                }\n                this.deps = this.newDeps\n            }\n\n            /**\n             * Subscriber interface.\n             * Will be called when a dependency changes.\n             */\n\n            p.update = function () {\n                if (!config.async || config.debug) {\n                    this.run()\n                } else {\n                    batcher.push(this)\n                }\n            }\n\n            /**\n             * Batcher job interface.\n             * Will be called by the batcher.\n             */\n\n            p.run = function () {\n                if (this.active) {\n                    var value = this.get()\n                    if (\n                        value !== this.value ||\n                        Array.isArray(value) ||\n                        this.deep\n                    ) {\n                        var oldValue = this.value\n                        this.value = value\n                        var cbs = this.cbs\n                        for (var i = 0, l = cbs.length; i < l; i++) {\n                            cbs[i](value, oldValue)\n                            // if a callback also removed other callbacks,\n                            // we need to adjust the loop accordingly.\n                            var removed = l - cbs.length\n                            if (removed) {\n                                i -= removed\n                                l -= removed\n                            }\n                        }\n                    }\n                }\n            }\n\n            /**\n             * Add a callback.\n             *\n             * @param {Function} cb\n             */\n\n            p.addCb = function (cb) {\n                this.cbs.push(cb)\n            }\n\n            /**\n             * Remove a callback.\n             *\n             * @param {Function} cb\n             */\n\n            p.removeCb = function (cb) {\n                var cbs = this.cbs\n                if (cbs.length > 1) {\n                    var i = cbs.indexOf(cb)\n                    if (i > -1) {\n                        cbs.splice(i, 1)\n                    }\n                } else if (cb === cbs[0]) {\n                    this.teardown()\n                }\n            }\n\n            /**\n             * Remove self from all dependencies' subcriber list.\n             */\n\n            p.teardown = function () {\n                if (this.active) {\n                    // remove self from vm's watcher list\n                    // we can skip this if the vm if being destroyed\n                    // which can improve teardown performance.\n                    if (!this.vm._isBeingDestroyed) {\n                        var list = this.vm._watcherList\n                        var i = list.indexOf(this)\n                        if (i > -1) {\n                            list.splice(i, 1)\n                        }\n                    }\n                    for (var id in this.deps) {\n                        this.deps[id].removeSub(this)\n                    }\n                    this.active = false\n                    this.vm = this.cbs = this.value = null\n                }\n            }\n\n\n            /**\n             * Recrusively traverse an object to evoke all converted\n             * getters, so that every nested property inside the object\n             * is collected as a \"deep\" dependency.\n             *\n             * @param {Object} obj\n             */\n\n            function traverse (obj) {\n                var key, val, i\n                for (key in obj) {\n                    val = obj[key]\n                    if (_.isArray(val)) {\n                        i = val.length\n                        while (i--) traverse(val[i])\n                    } else if (_.isObject(val)) {\n                        traverse(val)\n                    }\n                }\n            }\n\n            module.exports = Watcher\n\n            /***/ },\n        /* 26 */\n        /***/ function(module, exports, __webpack_require__) {\n\n            /**\n             * Check is a string starts with $ or _\n             *\n             * @param {String} str\n             * @return {Boolean}\n             */\n\n            exports.isReserved = function (str) {\n                var c = (str + '').charCodeAt(0)\n                return c === 0x24 || c === 0x5F\n            }\n\n            /**\n             * Guard text output, make sure undefined outputs\n             * empty string\n             *\n             * @param {*} value\n             * @return {String}\n             */\n\n            exports.toString = function (value) {\n                return value == null\n                    ? ''\n                    : value.toString()\n            }\n\n            /**\n             * Check and convert possible numeric numbers before\n             * setting back to data\n             *\n             * @param {*} value\n             * @return {*|Number}\n             */\n\n            exports.toNumber = function (value) {\n                return (\n                isNaN(value) ||\n                value === null ||\n                typeof value === 'boolean'\n                ) ? value\n                    : Number(value)\n            }\n\n            /**\n             * Strip quotes from a string\n             *\n             * @param {String} str\n             * @return {String | false}\n             */\n\n            exports.stripQuotes = function (str) {\n                var a = str.charCodeAt(0)\n                var b = str.charCodeAt(str.length - 1)\n                return a === b && (a === 0x22 || a === 0x27)\n                    ? str.slice(1, -1)\n                    : false\n            }\n\n            /**\n             * Replace helper\n             *\n             * @param {String} _ - matched delimiter\n             * @param {String} c - matched char\n             * @return {String}\n             */\n            function toUpper (_, c) {\n                return c ? c.toUpperCase () : ''\n            }\n\n            /**\n             * Camelize a hyphen-delmited string.\n             *\n             * @param {String} str\n             * @return {String}\n             */\n\n            var camelRE = /-(\\w)/g\n            exports.camelize = function (str) {\n                return str.replace(camelRE, toUpper)\n            }\n\n            /**\n             * Converts hyphen/underscore/slash delimitered names into\n             * camelized classNames.\n             *\n             * e.g. my-component => MyComponent\n             *      some_else    => SomeElse\n             *      some/comp    => SomeComp\n             *\n             * @param {String} str\n             * @return {String}\n             */\n\n            var classifyRE = /(?:^|[-_\\/])(\\w)/g\n            exports.classify = function (str) {\n                return str.replace(classifyRE, toUpper)\n            }\n\n            /**\n             * Simple bind, faster than native\n             *\n             * @param {Function} fn\n             * @param {Object} ctx\n             * @return {Function}\n             */\n\n            exports.bind = function (fn, ctx) {\n                return function () {\n                    return fn.apply(ctx, arguments)\n                }\n            }\n\n            /**\n             * Convert an Array-like object to a real Array.\n             *\n             * @param {Array-like} list\n             * @param {Number} [start] - start index\n             * @return {Array}\n             */\n\n            exports.toArray = function (list, start) {\n                start = start || 0\n                var i = list.length - start\n                var ret = new Array(i)\n                while (i--) {\n                    ret[i] = list[i + start]\n                }\n                return ret\n            }\n\n            /**\n             * Mix properties into target object.\n             *\n             * @param {Object} to\n             * @param {Object} from\n             */\n\n            exports.extend = function (to, from) {\n                for (var key in from) {\n                    to[key] = from[key]\n                }\n                return to\n            }\n\n            /**\n             * Quick object check - this is primarily used to tell\n             * Objects from primitive values when we know the value\n             * is a JSON-compliant type.\n             *\n             * @param {*} obj\n             * @return {Boolean}\n             */\n\n            exports.isObject = function (obj) {\n                return obj && typeof obj === 'object'\n            }\n\n            /**\n             * Strict object type check. Only returns true\n             * for plain JavaScript objects.\n             *\n             * @param {*} obj\n             * @return {Boolean}\n             */\n\n            var toString = Object.prototype.toString\n            exports.isPlainObject = function (obj) {\n                return toString.call(obj) === '[object Object]'\n            }\n\n            /**\n             * Array type check.\n             *\n             * @param {*} obj\n             * @return {Boolean}\n             */\n\n            exports.isArray = function (obj) {\n                return Array.isArray(obj)\n            }\n\n            /**\n             * Define a non-enumerable property\n             *\n             * @param {Object} obj\n             * @param {String} key\n             * @param {*} val\n             * @param {Boolean} [enumerable]\n             */\n\n            exports.define = function (obj, key, val, enumerable) {\n                Object.defineProperty(obj, key, {\n                    value        : val,\n                    enumerable   : !!enumerable,\n                    writable     : true,\n                    configurable : true\n                })\n            }\n\n            /**\n             * Debounce a function so it only gets called after the\n             * input stops arriving after the given wait period.\n             *\n             * @param {Function} func\n             * @param {Number} wait\n             * @return {Function} - the debounced function\n             */\n\n            exports.debounce = function(func, wait) {\n                var timeout, args, context, timestamp, result\n                var later = function() {\n                    var last = Date.now() - timestamp\n                    if (last < wait && last >= 0) {\n                        timeout = setTimeout(later, wait - last)\n                    } else {\n                        timeout = null\n                        result = func.apply(context, args)\n                        if (!timeout) context = args = null\n                    }\n                }\n                return function() {\n                    context = this\n                    args = arguments\n                    timestamp = Date.now()\n                    if (!timeout) {\n                        timeout = setTimeout(later, wait)\n                    }\n                    return result\n                }\n            }\n\n            /***/ },\n        /* 27 */\n        /***/ function(module, exports, __webpack_require__) {\n\n            /**\n             * Can we use __proto__?\n             *\n             * @type {Boolean}\n             */\n\n            exports.hasProto = '__proto__' in {}\n\n            /**\n             * Indicates we have a window\n             *\n             * @type {Boolean}\n             */\n\n            var toString = Object.prototype.toString\n            var inBrowser = exports.inBrowser =\n                typeof window !== 'undefined' &&\n                toString.call(window) !== '[object Object]'\n\n            /**\n             * Defer a task to execute it asynchronously. Ideally this\n             * should be executed as a microtask, so we leverage\n             * MutationObserver if it's available, and fallback to\n             * setTimeout(0).\n             *\n             * @param {Function} cb\n             * @param {Object} ctx\n             */\n\n            exports.nextTick = (function () {\n                var callbacks = []\n                var pending = false\n                var timerFunc\n                function handle () {\n                    pending = false\n                    var copies = callbacks.slice(0)\n                    callbacks = []\n                    for (var i = 0; i < copies.length; i++) {\n                        copies[i]()\n                    }\n                }\n                /* istanbul ignore if */\n                if (typeof MutationObserver !== 'undefined') {\n                    var counter = 1\n                    var observer = new MutationObserver(handle)\n                    var textNode = document.createTextNode(counter)\n                    observer.observe(textNode, {\n                        characterData: true\n                    })\n                    timerFunc = function () {\n                        counter = (counter + 1) % 2\n                        textNode.data = counter\n                    }\n                } else {\n                    timerFunc = setTimeout\n                }\n                return function (cb, ctx) {\n                    var func = ctx\n                        ? function () { cb.call(ctx) }\n                        : cb\n                    callbacks.push(func)\n                    if (pending) return\n                    pending = true\n                    timerFunc(handle, 0)\n                }\n            })()\n\n            /**\n             * Detect if we are in IE9...\n             *\n             * @type {Boolean}\n             */\n\n            exports.isIE9 =\n                inBrowser &&\n                navigator.userAgent.indexOf('MSIE 9.0') > 0\n\n            /**\n             * Sniff transition/animation events\n             */\n\n            if (inBrowser && !exports.isIE9) {\n                var isWebkitTrans =\n                    window.ontransitionend === undefined &&\n                    window.onwebkittransitionend !== undefined\n                var isWebkitAnim =\n                    window.onanimationend === undefined &&\n                    window.onwebkitanimationend !== undefined\n                exports.transitionProp = isWebkitTrans\n                    ? 'WebkitTransition'\n                    : 'transition'\n                exports.transitionEndEvent = isWebkitTrans\n                    ? 'webkitTransitionEnd'\n                    : 'transitionend'\n                exports.animationProp = isWebkitAnim\n                    ? 'WebkitAnimation'\n                    : 'animation'\n                exports.animationEndEvent = isWebkitAnim\n                    ? 'webkitAnimationEnd'\n                    : 'animationend'\n            }\n\n            /***/ },\n        /* 28 */\n        /***/ function(module, exports, __webpack_require__) {\n\n            var config = __webpack_require__(15)\n\n            /**\n             * Check if a node is in the document.\n             * Note: document.documentElement.contains should work here\n             * but always returns false for comment nodes in phantomjs,\n             * making unit tests difficult. This is fixed byy doing the\n             * contains() check on the node's parentNode instead of\n             * the node itself.\n             *\n             * @param {Node} node\n             * @return {Boolean}\n             */\n\n            var doc =\n                typeof document !== 'undefined' &&\n                document.documentElement\n\n            exports.inDoc = function (node) {\n                var parent = node && node.parentNode\n                return doc === node ||\n                    doc === parent ||\n                    !!(parent && parent.nodeType === 1 && (doc.contains(parent)))\n            }\n\n            /**\n             * Extract an attribute from a node.\n             *\n             * @param {Node} node\n             * @param {String} attr\n             */\n\n            exports.attr = function (node, attr) {\n                attr = config.prefix + attr\n                var val = node.getAttribute(attr)\n                if (val !== null) {\n                    node.removeAttribute(attr)\n                }\n                return val\n            }\n\n            /**\n             * Insert el before target\n             *\n             * @param {Element} el\n             * @param {Element} target\n             */\n\n            exports.before = function (el, target) {\n                target.parentNode.insertBefore(el, target)\n            }\n\n            /**\n             * Insert el after target\n             *\n             * @param {Element} el\n             * @param {Element} target\n             */\n\n            exports.after = function (el, target) {\n                if (target.nextSibling) {\n                    exports.before(el, target.nextSibling)\n                } else {\n                    target.parentNode.appendChild(el)\n                }\n            }\n\n            /**\n             * Remove el from DOM\n             *\n             * @param {Element} el\n             */\n\n            exports.remove = function (el) {\n                el.parentNode.removeChild(el)\n            }\n\n            /**\n             * Prepend el to target\n             *\n             * @param {Element} el\n             * @param {Element} target\n             */\n\n            exports.prepend = function (el, target) {\n                if (target.firstChild) {\n                    exports.before(el, target.firstChild)\n                } else {\n                    target.appendChild(el)\n                }\n            }\n\n            /**\n             * Replace target with el\n             *\n             * @param {Element} target\n             * @param {Element} el\n             */\n\n            exports.replace = function (target, el) {\n                var parent = target.parentNode\n                if (parent) {\n                    parent.replaceChild(el, target)\n                }\n            }\n\n            /**\n             * Copy attributes from one element to another.\n             *\n             * @param {Element} from\n             * @param {Element} to\n             */\n\n            exports.copyAttributes = function (from, to) {\n                if (from.hasAttributes()) {\n                    var attrs = from.attributes\n                    for (var i = 0, l = attrs.length; i < l; i++) {\n                        var attr = attrs[i]\n                        to.setAttribute(attr.name, attr.value)\n                    }\n                }\n            }\n\n            /**\n             * Add event listener shorthand.\n             *\n             * @param {Element} el\n             * @param {String} event\n             * @param {Function} cb\n             */\n\n            exports.on = function (el, event, cb) {\n                el.addEventListener(event, cb)\n            }\n\n            /**\n             * Remove event listener shorthand.\n             *\n             * @param {Element} el\n             * @param {String} event\n             * @param {Function} cb\n             */\n\n            exports.off = function (el, event, cb) {\n                el.removeEventListener(event, cb)\n            }\n\n            /**\n             * Add class with compatibility for IE & SVG\n             *\n             * @param {Element} el\n             * @param {Strong} cls\n             */\n\n            exports.addClass = function (el, cls) {\n                if (el.classList) {\n                    el.classList.add(cls)\n                } else {\n                    var cur = ' ' + (el.getAttribute('class') || '') + ' '\n                    if (cur.indexOf(' ' + cls + ' ') < 0) {\n                        el.setAttribute('class', (cur + cls).trim())\n                    }\n                }\n            }\n\n            /**\n             * Remove class with compatibility for IE & SVG\n             *\n             * @param {Element} el\n             * @param {Strong} cls\n             */\n\n            exports.removeClass = function (el, cls) {\n                if (el.classList) {\n                    el.classList.remove(cls)\n                } else {\n                    var cur = ' ' + (el.getAttribute('class') || '') + ' '\n                    var tar = ' ' + cls + ' '\n                    while (cur.indexOf(tar) >= 0) {\n                        cur = cur.replace(tar, ' ')\n                    }\n                    el.setAttribute('class', cur.trim())\n                }\n            }\n\n            /**\n             * Extract raw content inside an element into a temporary\n             * container div\n             *\n             * @param {Element} el\n             * @param {Boolean} asFragment\n             * @return {Element}\n             */\n\n            exports.extractContent = function (el, asFragment) {\n                var child\n                var rawContent\n                if (el.hasChildNodes()) {\n                    rawContent = asFragment\n                        ? document.createDocumentFragment()\n                        : document.createElement('div')\n                    /* jshint boss:true */\n                    while (child = el.firstChild) {\n                        rawContent.appendChild(child)\n                    }\n                }\n                return rawContent\n            }\n\n\n            /***/ },\n        /* 29 */\n        /***/ function(module, exports, __webpack_require__) {\n\n            var _ = __webpack_require__(30)\n\n            /**\n             * Resolve read & write filters for a vm instance. The\n             * filters descriptor Array comes from the directive parser.\n             *\n             * This is extracted into its own utility so it can\n             * be used in multiple scenarios.\n             *\n             * @param {Vue} vm\n             * @param {Array<Object>} filters\n             * @param {Object} [target]\n             * @return {Object}\n             */\n\n            exports.resolveFilters = function (vm, filters, target) {\n                if (!filters) {\n                    return\n                }\n                var res = target || {}\n                // var registry = vm.$options.filters\n                filters.forEach(function (f) {\n                    var def = vm.$options.filters[f.name]\n                    _.assertAsset(def, 'filter', f.name)\n                    if (!def) return\n                    var args = f.args\n                    var reader, writer\n                    if (typeof def === 'function') {\n                        reader = def\n                    } else {\n                        reader = def.read\n                        writer = def.write\n                    }\n                    if (reader) {\n                        if (!res.read) res.read = []\n                        res.read.push(function (value) {\n                            return args\n                                ? reader.apply(vm, [value].concat(args))\n                                : reader.call(vm, value)\n                        })\n                    }\n                    if (writer) {\n                        if (!res.write) res.write = []\n                        res.write.push(function (value, oldVal) {\n                            return args\n                                ? writer.apply(vm, [value, oldVal].concat(args))\n                                : writer.call(vm, value, oldVal)\n                        })\n                    }\n                })\n                return res\n            }\n\n            /**\n             * Apply filters to a value\n             *\n             * @param {*} value\n             * @param {Array} filters\n             * @param {Vue} vm\n             * @param {*} oldVal\n             * @return {*}\n             */\n\n            exports.applyFilters = function (value, filters, vm, oldVal) {\n                if (!filters) {\n                    return value\n                }\n                for (var i = 0, l = filters.length; i < l; i++) {\n                    value = filters[i].call(vm, value, oldVal)\n                }\n                return value\n            }\n\n            /***/ },\n        /* 30 */\n        /***/ function(module, exports, __webpack_require__) {\n\n            var config = __webpack_require__(15)\n\n            /**\n             * Enable debug utilities. The enableDebug() function and\n             * all _.log() & _.warn() calls will be dropped in the\n             * minified production build.\n             */\n\n            enableDebug()\n\n            function enableDebug () {\n\n                var hasConsole = typeof console !== 'undefined'\n\n                /**\n                 * Log a message.\n                 *\n                 * @param {String} msg\n                 */\n\n                exports.log = function (msg) {\n                    if (hasConsole && config.debug) {\n                        console.log('[Vue info]: ' + msg)\n                    }\n                }\n\n                /**\n                 * We've got a problem here.\n                 *\n                 * @param {String} msg\n                 */\n\n                exports.warn = function (msg) {\n                    if (hasConsole && (!config.silent || config.debug)) {\n                        console.warn('[Vue warn]: ' + msg)\n                        /* istanbul ignore if */\n                        if (config.debug) {\n                            /* jshint debug: true */\n                            debugger\n                        }\n                    }\n                }\n\n                /**\n                 * Assert asset exists\n                 */\n\n                exports.assertAsset = function (val, type, id) {\n                    if (!val) {\n                        exports.warn('Failed to resolve ' + type + ': ' + id)\n                    }\n                }\n            }\n\n            /***/ },\n        /* 31 */\n        /***/ function(module, exports, __webpack_require__) {\n\n            var _ = __webpack_require__(11)\n\n            module.exports = {\n\n                bind: function () {\n                    this.attr = this.el.nodeType === 3\n                        ? 'nodeValue'\n                        : 'textContent'\n                },\n\n                update: function (value) {\n                    this.el[this.attr] = _.toString(value)\n                }\n\n            }\n\n            /***/ },\n        /* 32 */\n        /***/ function(module, exports, __webpack_require__) {\n\n            var _ = __webpack_require__(11)\n            var templateParser = __webpack_require__(20)\n\n            module.exports = {\n\n                bind: function () {\n                    // a comment node means this is a binding for\n                    // {{{ inline unescaped html }}}\n                    if (this.el.nodeType === 8) {\n                        // hold nodes\n                        this.nodes = []\n                    }\n                },\n\n                update: function (value) {\n                    value = _.toString(value)\n                    if (this.nodes) {\n                        this.swap(value)\n                    } else {\n                        this.el.innerHTML = value\n                    }\n                },\n\n                swap: function (value) {\n                    // remove old nodes\n                    var i = this.nodes.length\n                    while (i--) {\n                        _.remove(this.nodes[i])\n                    }\n                    // convert new value to a fragment\n                    // do not attempt to retrieve from id selector\n                    var frag = templateParser.parse(value, true, true)\n                    // save a reference to these nodes so we can remove later\n                    this.nodes = _.toArray(frag.childNodes)\n                    _.before(frag, this.el)\n                }\n\n            }\n\n            /***/ },\n        /* 33 */\n        /***/ function(module, exports, __webpack_require__) {\n\n            // xlink\n            var xlinkNS = 'http://www.w3.org/1999/xlink'\n            var xlinkRE = /^xlink:/\n\n            module.exports = {\n\n                priority: 850,\n\n                bind: function () {\n                    var name = this.arg\n                    this.update = xlinkRE.test(name)\n                        ? xlinkHandler\n                        : defaultHandler\n                }\n\n            }\n\n            function defaultHandler (value) {\n                if (value || value === 0) {\n                    this.el.setAttribute(this.arg, value)\n                } else {\n                    this.el.removeAttribute(this.arg)\n                }\n            }\n\n            function xlinkHandler (value) {\n                if (value != null) {\n                    this.el.setAttributeNS(xlinkNS, this.arg, value)\n                } else {\n                    this.el.removeAttributeNS(xlinkNS, 'href')\n                }\n            }\n\n            /***/ },\n        /* 34 */\n        /***/ function(module, exports, __webpack_require__) {\n\n            var transition = __webpack_require__(50)\n\n            module.exports = function (value) {\n                var el = this.el\n                transition.apply(el, value ? 1 : -1, function () {\n                    el.style.display = value ? '' : 'none'\n                }, this.vm)\n            }\n\n            /***/ },\n        /* 35 */\n        /***/ function(module, exports, __webpack_require__) {\n\n            var _ = __webpack_require__(11)\n            var addClass = _.addClass\n            var removeClass = _.removeClass\n\n            module.exports = function (value) {\n                if (this.arg) {\n                    var method = value ? addClass : removeClass\n                    method(this.el, this.arg)\n                } else {\n                    if (this.lastVal) {\n                        removeClass(this.el, this.lastVal)\n                    }\n                    if (value) {\n                        addClass(this.el, value)\n                        this.lastVal = value\n                    }\n                }\n            }\n\n            /***/ },\n        /* 36 */\n        /***/ function(module, exports, __webpack_require__) {\n\n            module.exports = {\n\n                isLiteral: true,\n\n                bind: function () {\n                    this.vm.$$[this.expression] = this.el\n                },\n\n                unbind: function () {\n                    delete this.vm.$$[this.expression]\n                }\n\n            }\n\n            /***/ },\n        /* 37 */\n        /***/ function(module, exports, __webpack_require__) {\n\n            var _ = __webpack_require__(11)\n\n            module.exports = {\n\n                isLiteral: true,\n\n                bind: function () {\n                    var vm = this.el.__vue__\n                    if (!vm) {\n                        _.warn(\n                            'v-ref should only be used on a component root element.'\n                        )\n                        return\n                    }\n                    // If we get here, it means this is a `v-ref` on a\n                    // child, because parent scope `v-ref` is stripped in\n                    // `v-component` already. So we just record our own ref\n                    // here - it will overwrite parent ref in `v-component`,\n                    // if any.\n                    vm._refID = this.expression\n                }\n\n            }\n\n            /***/ },\n        /* 38 */\n        /***/ function(module, exports, __webpack_require__) {\n\n            var config = __webpack_require__(15)\n\n            module.exports = {\n\n                bind: function () {\n                    var el = this.el\n                    this.vm.$once('hook:compiled', function () {\n                        el.removeAttribute(config.prefix + 'cloak')\n                    })\n                }\n\n            }\n\n            /***/ },\n        /* 39 */\n        /***/ function(module, exports, __webpack_require__) {\n\n            var _ = __webpack_require__(11)\n            var prefixes = ['-webkit-', '-moz-', '-ms-']\n            var camelPrefixes = ['Webkit', 'Moz', 'ms']\n            var importantRE = /!important;?$/\n            var camelRE = /([a-z])([A-Z])/g\n            var testEl = null\n            var propCache = {}\n\n            module.exports = {\n\n                deep: true,\n\n                update: function (value) {\n                    if (this.arg) {\n                        this.setProp(this.arg, value)\n                    } else {\n                        if (typeof value === 'object') {\n                            // cache object styles so that only changed props\n                            // are actually updated.\n                            if (!this.cache) this.cache = {}\n                            for (var prop in value) {\n                                this.setProp(prop, value[prop])\n                                /* jshint eqeqeq: false */\n                                if (value[prop] != this.cache[prop]) {\n                                    this.cache[prop] = value[prop]\n                                    this.setProp(prop, value[prop])\n                                }\n                            }\n                        } else {\n                            this.el.style.cssText = value\n                        }\n                    }\n                },\n\n                setProp: function (prop, value) {\n                    prop = normalize(prop)\n                    if (!prop) return // unsupported prop\n                    // cast possible numbers/booleans into strings\n                    if (value != null) value += ''\n                    if (value) {\n                        var isImportant = importantRE.test(value)\n                            ? 'important'\n                            : ''\n                        if (isImportant) {\n                            value = value.replace(importantRE, '').trim()\n                        }\n                        this.el.style.setProperty(prop, value, isImportant)\n                    } else {\n                        this.el.style.removeProperty(prop)\n                    }\n                }\n\n            }\n\n            /**\n             * Normalize a CSS property name.\n             * - cache result\n             * - auto prefix\n             * - camelCase -> dash-case\n             *\n             * @param {String} prop\n             * @return {String}\n             */\n\n            function normalize (prop) {\n                if (propCache[prop]) {\n                    return propCache[prop]\n                }\n                var res = prefix(prop)\n                propCache[prop] = propCache[res] = res\n                return res\n            }\n\n            /**\n             * Auto detect the appropriate prefix for a CSS property.\n             * https://gist.github.com/paulirish/523692\n             *\n             * @param {String} prop\n             * @return {String}\n             */\n\n            function prefix (prop) {\n                prop = prop.replace(camelRE, '$1-$2').toLowerCase()\n                var camel = _.camelize(prop)\n                var upper = camel.charAt(0).toUpperCase() + camel.slice(1)\n                if (!testEl) {\n                    testEl = document.createElement('div')\n                }\n                if (camel in testEl.style) {\n                    return prop\n                }\n                var i = prefixes.length\n                var prefixed\n                while (i--) {\n                    prefixed = camelPrefixes[i] + upper\n                    if (prefixed in testEl.style) {\n                        return prefixes[i] + prop\n                    }\n                }\n            }\n\n            /***/ },\n        /* 40 */\n        /***/ function(module, exports, __webpack_require__) {\n\n            var _ = __webpack_require__(11)\n            var templateParser = __webpack_require__(20)\n            var vIf = __webpack_require__(45)\n\n            module.exports = {\n\n                isLiteral: true,\n\n                // same logic reuse from v-if\n                compile: vIf.compile,\n                teardown: vIf.teardown,\n                getContainedComponents: vIf.getContainedComponents,\n                unbind: vIf.unbind,\n\n                bind: function () {\n                    var el = this.el\n                    this.start = document.createComment('v-partial-start')\n                    this.end = document.createComment('v-partial-end')\n                    if (el.nodeType !== 8) {\n                        el.innerHTML = ''\n                    }\n                    if (el.tagName === 'TEMPLATE' || el.nodeType === 8) {\n                        _.replace(el, this.end)\n                    } else {\n                        el.appendChild(this.end)\n                    }\n                    _.before(this.start, this.end)\n                    if (!this._isDynamicLiteral) {\n                        this.insert(this.expression)\n                    }\n                },\n\n                update: function (id) {\n                    this.teardown()\n                    this.insert(id)\n                },\n\n                insert: function (id) {\n                    var partial = this.vm.$options.partials[id]\n                    _.assertAsset(partial, 'partial', id)\n                    if (partial) {\n                        var filters = this.filters && this.filters.read\n                        if (filters) {\n                            partial = _.applyFilters(partial, filters, this.vm)\n                        }\n                        this.compile(templateParser.parse(partial, true))\n                    }\n                }\n\n            }\n\n            /***/ },\n        /* 41 */\n        /***/ function(module, exports, __webpack_require__) {\n\n            module.exports = {\n\n                priority: 1000,\n                isLiteral: true,\n\n                bind: function () {\n                    if (!this._isDynamicLiteral) {\n                        this.update(this.expression)\n                    }\n                },\n\n                update: function (id) {\n                    var vm = this.el.__vue__ || this.vm\n                    this.el.__v_trans = {\n                        id: id,\n                        // resolve the custom transition functions now\n                        // so the transition module knows this is a\n                        // javascript transition without having to check\n                        // computed CSS.\n                        fns: vm.$options.transitions[id]\n                    }\n                }\n\n            }\n\n            /***/ },\n        /* 42 */\n        /***/ function(module, exports, __webpack_require__) {\n\n            var _ = __webpack_require__(11)\n\n            module.exports = {\n\n                acceptStatement: true,\n                priority: 700,\n\n                bind: function () {\n                    // deal with iframes\n                    if (\n                        this.el.tagName === 'IFRAME' &&\n                        this.arg !== 'load'\n                    ) {\n                        var self = this\n                        this.iframeBind = function () {\n                            _.on(self.el.contentWindow, self.arg, self.handler)\n                        }\n                        _.on(this.el, 'load', this.iframeBind)\n                    }\n                },\n\n                update: function (handler) {\n                    if (typeof handler !== 'function') {\n                        _.warn(\n                            'Directive \"v-on:' + this.expression + '\" ' +\n                            'expects a function value.'\n                        )\n                        return\n                    }\n                    this.reset()\n                    var vm = this.vm\n                    this.handler = function (e) {\n                        e.targetVM = vm\n                        vm.$event = e\n                        var res = handler(e)\n                        vm.$event = null\n                        return res\n                    }\n                    if (this.iframeBind) {\n                        this.iframeBind()\n                    } else {\n                        _.on(this.el, this.arg, this.handler)\n                    }\n                },\n\n                reset: function () {\n                    var el = this.iframeBind\n                        ? this.el.contentWindow\n                        : this.el\n                    if (this.handler) {\n                        _.off(el, this.arg, this.handler)\n                    }\n                },\n\n                unbind: function () {\n                    this.reset()\n                    _.off(this.el, 'load', this.iframeBind)\n                }\n            }\n\n            /***/ },\n        /* 43 */\n        /***/ function(module, exports, __webpack_require__) {\n\n            var _ = __webpack_require__(11)\n            var templateParser = __webpack_require__(20)\n\n            module.exports = {\n\n                isLiteral: true,\n\n                /**\n                 * Setup. Two possible usages:\n                 *\n                 * - static:\n                 *   v-component=\"comp\"\n                 *\n                 * - dynamic:\n                 *   v-component=\"{{currentView}}\"\n                 */\n\n                bind: function () {\n                    if (!this.el.__vue__) {\n                        // create a ref anchor\n                        this.ref = document.createComment('v-component')\n                        _.replace(this.el, this.ref)\n                        // check keep-alive options.\n                        // If yes, instead of destroying the active vm when\n                        // hiding (v-if) or switching (dynamic literal) it,\n                        // we simply remove it from the DOM and save it in a\n                        // cache object, with its constructor id as the key.\n                        this.keepAlive = this._checkParam('keep-alive') != null\n                        // check ref\n                        this.refID = _.attr(this.el, 'ref')\n                        if (this.keepAlive) {\n                            this.cache = {}\n                        }\n                        // check inline-template\n                        if (this._checkParam('inline-template') !== null) {\n                            // extract inline template as a DocumentFragment\n                            this.template = _.extractContent(this.el, true)\n                        }\n                        // if static, build right now.\n                        if (!this._isDynamicLiteral) {\n                            this.resolveCtor(this.expression)\n                            var child = this.build()\n                            child.$before(this.ref)\n                            this.setCurrent(child)\n                        } else {\n                            // check dynamic component params\n                            this.readyEvent = this._checkParam('wait-for')\n                            this.transMode = this._checkParam('transition-mode')\n                        }\n                    } else {\n                        _.warn(\n                            'v-component=\"' + this.expression + '\" cannot be ' +\n                            'used on an already mounted instance.'\n                        )\n                    }\n                },\n\n                /**\n                 * Resolve the component constructor to use when creating\n                 * the child vm.\n                 */\n\n                resolveCtor: function (id) {\n                    this.ctorId = id\n                    this.Ctor = this.vm.$options.components[id]\n                    _.assertAsset(this.Ctor, 'component', id)\n                },\n\n                /**\n                 * Instantiate/insert a new child vm.\n                 * If keep alive and has cached instance, insert that\n                 * instance; otherwise build a new one and cache it.\n                 *\n                 * @return {Vue} - the created instance\n                 */\n\n                build: function () {\n                    if (this.keepAlive) {\n                        var cached = this.cache[this.ctorId]\n                        if (cached) {\n                            return cached\n                        }\n                    }\n                    var vm = this.vm\n                    var el = templateParser.clone(this.el)\n                    if (this.Ctor) {\n                        var child = vm.$addChild({\n                            el: el,\n                            template: this.template,\n                            _asComponent: true,\n                            _host: this._host\n                        }, this.Ctor)\n                        if (this.keepAlive) {\n                            this.cache[this.ctorId] = child\n                        }\n                        return child\n                    }\n                },\n\n                /**\n                 * Teardown the current child, but defers cleanup so\n                 * that we can separate the destroy and removal steps.\n                 */\n\n                unbuild: function () {\n                    var child = this.childVM\n                    if (!child || this.keepAlive) {\n                        return\n                    }\n                    // the sole purpose of `deferCleanup` is so that we can\n                    // \"deactivate\" the vm right now and perform DOM removal\n                    // later.\n                    child.$destroy(false, true)\n                },\n\n                /**\n                 * Remove current destroyed child and manually do\n                 * the cleanup after removal.\n                 *\n                 * @param {Function} cb\n                 */\n\n                remove: function (child, cb) {\n                    var keepAlive = this.keepAlive\n                    if (child) {\n                        child.$remove(function () {\n                            if (!keepAlive) child._cleanup()\n                            if (cb) cb()\n                        })\n                    } else if (cb) {\n                        cb()\n                    }\n                },\n\n                /**\n                 * Update callback for the dynamic literal scenario,\n                 * e.g. v-component=\"{{view}}\"\n                 */\n\n                update: function (value) {\n                    if (!value) {\n                        // just destroy and remove current\n                        this.unbuild()\n                        this.remove(this.childVM)\n                        this.unsetCurrent()\n                    } else {\n                        this.resolveCtor(value)\n                        this.unbuild()\n                        var newComponent = this.build()\n                        var self = this\n                        if (this.readyEvent) {\n                            newComponent.$once(this.readyEvent, function () {\n                                self.swapTo(newComponent)\n                            })\n                        } else {\n                            this.swapTo(newComponent)\n                        }\n                    }\n                },\n\n                /**\n                 * Actually swap the components, depending on the\n                 * transition mode. Defaults to simultaneous.\n                 *\n                 * @param {Vue} target\n                 */\n\n                swapTo: function (target) {\n                    var self = this\n                    var current = this.childVM\n                    this.unsetCurrent()\n                    this.setCurrent(target)\n                    switch (self.transMode) {\n                        case 'in-out':\n                            target.$before(self.ref, function () {\n                                self.remove(current)\n                            })\n                            break\n                        case 'out-in':\n                            self.remove(current, function () {\n                                target.$before(self.ref)\n                            })\n                            break\n                        default:\n                            self.remove(current)\n                            target.$before(self.ref)\n                    }\n                },\n\n                /**\n                 * Set childVM and parent ref\n                 */\n\n                setCurrent: function (child) {\n                    this.childVM = child\n                    var refID = child._refID || this.refID\n                    if (refID) {\n                        this.vm.$[refID] = child\n                    }\n                },\n\n                /**\n                 * Unset childVM and parent ref\n                 */\n\n                unsetCurrent: function () {\n                    var child = this.childVM\n                    this.childVM = null\n                    var refID = (child && child._refID) || this.refID\n                    if (refID) {\n                        this.vm.$[refID] = null\n                    }\n                },\n\n                /**\n                 * Unbind.\n                 */\n\n                unbind: function () {\n                    this.unbuild()\n                    // destroy all keep-alive cached instances\n                    if (this.cache) {\n                        for (var key in this.cache) {\n                            this.cache[key].$destroy()\n                        }\n                        this.cache = null\n                    }\n                }\n\n            }\n\n            /***/ },\n        /* 44 */\n        /***/ function(module, exports, __webpack_require__) {\n\n            var _ = __webpack_require__(11)\n            var isObject = _.isObject\n            var isPlainObject = _.isPlainObject\n            var textParser = __webpack_require__(19)\n            var expParser = __webpack_require__(22)\n            var templateParser = __webpack_require__(20)\n            var compile = __webpack_require__(16)\n            var transclude = __webpack_require__(17)\n            var mergeOptions = __webpack_require__(14)\n            var uid = 0\n\n            module.exports = {\n\n                /**\n                 * Setup.\n                 */\n\n                bind: function () {\n                    // uid as a cache identifier\n                    this.id = '__v_repeat_' + (++uid)\n                    // we need to insert the objToArray converter\n                    // as the first read filter, because it has to be invoked\n                    // before any user filters. (can't do it in `update`)\n                    if (!this.filters) {\n                        this.filters = {}\n                    }\n                    // add the object -> array convert filter\n                    var objectConverter = _.bind(objToArray, this)\n                    if (!this.filters.read) {\n                        this.filters.read = [objectConverter]\n                    } else {\n                        this.filters.read.unshift(objectConverter)\n                    }\n                    // setup ref node\n                    this.ref = document.createComment('v-repeat')\n                    _.replace(this.el, this.ref)\n                    // check if this is a block repeat\n                    this.template = this.el.tagName === 'TEMPLATE'\n                        ? templateParser.parse(this.el, true)\n                        : this.el\n                    // check other directives that need to be handled\n                    // at v-repeat level\n                    this.checkIf()\n                    this.checkRef()\n                    this.checkComponent()\n                    // check for trackby param\n                    this.idKey =\n                        this._checkParam('track-by') ||\n                        this._checkParam('trackby') // 0.11.0 compat\n                    this.cache = Object.create(null)\n                },\n\n                /**\n                 * Warn against v-if usage.\n                 */\n\n                checkIf: function () {\n                    if (_.attr(this.el, 'if') !== null) {\n                        _.warn(\n                            'Don\\'t use v-if with v-repeat. ' +\n                            'Use v-show or the \"filterBy\" filter instead.'\n                        )\n                    }\n                },\n\n                /**\n                 * Check if v-ref/ v-el is also present.\n                 */\n\n                checkRef: function () {\n                    var refID = _.attr(this.el, 'ref')\n                    this.refID = refID\n                        ? this.vm.$interpolate(refID)\n                        : null\n                    var elId = _.attr(this.el, 'el')\n                    this.elId = elId\n                        ? this.vm.$interpolate(elId)\n                        : null\n                },\n\n                /**\n                 * Check the component constructor to use for repeated\n                 * instances. If static we resolve it now, otherwise it\n                 * needs to be resolved at build time with actual data.\n                 */\n\n                checkComponent: function () {\n                    var id = _.attr(this.el, 'component')\n                    var options = this.vm.$options\n                    if (!id) {\n                        // default constructor\n                        this.Ctor = _.Vue\n                        // inline repeats should inherit\n                        this.inherit = true\n                        // important: transclude with no options, just\n                        // to ensure block start and block end\n                        this.template = transclude(this.template)\n                        this._linkFn = compile(this.template, options)\n                    } else {\n                        this.asComponent = true\n                        // check inline-template\n                        if (this._checkParam('inline-template') !== null) {\n                            // extract inline template as a DocumentFragment\n                            this.inlineTempalte = _.extractContent(this.el, true)\n                        }\n                        var tokens = textParser.parse(id)\n                        if (!tokens) { // static component\n                            var Ctor = this.Ctor = options.components[id]\n                            _.assertAsset(Ctor, 'component', id)\n                            var merged = mergeOptions(Ctor.options, {}, {\n                                $parent: this.vm\n                            })\n                            merged.template = this.inlineTempalte || merged.template\n                            merged._asComponent = true\n                            merged._parent = this.vm\n                            this.template = transclude(this.template, merged)\n                            // Important: mark the template as a root node so that\n                            // custom element components don't get compiled twice.\n                            // fixes #822\n                            this.template.__vue__ = true\n                            this._linkFn = compile(this.template, merged)\n                        } else {\n                            // to be resolved later\n                            var ctorExp = textParser.tokensToExp(tokens)\n                            this.ctorGetter = expParser.parse(ctorExp).get\n                        }\n                    }\n                },\n\n                /**\n                 * Update.\n                 * This is called whenever the Array mutates.\n                 *\n                 * @param {Array|Number|String} data\n                 */\n\n                update: function (data) {\n                    data = data || []\n                    var type = typeof data\n                    if (type === 'number') {\n                        data = range(data)\n                    } else if (type === 'string') {\n                        data = _.toArray(data)\n                    }\n                    this.vms = this.diff(data, this.vms)\n                    // update v-ref\n                    if (this.refID) {\n                        this.vm.$[this.refID] = this.vms\n                    }\n                    if (this.elId) {\n                        this.vm.$$[this.elId] = this.vms.map(function (vm) {\n                            return vm.$el\n                        })\n                    }\n                },\n\n                /**\n                 * Diff, based on new data and old data, determine the\n                 * minimum amount of DOM manipulations needed to make the\n                 * DOM reflect the new data Array.\n                 *\n                 * The algorithm diffs the new data Array by storing a\n                 * hidden reference to an owner vm instance on previously\n                 * seen data. This allows us to achieve O(n) which is\n                 * better than a levenshtein distance based algorithm,\n                 * which is O(m * n).\n                 *\n                 * @param {Array} data\n                 * @param {Array} oldVms\n                 * @return {Array}\n                 */\n\n                diff: function (data, oldVms) {\n                    var idKey = this.idKey\n                    var converted = this.converted\n                    var ref = this.ref\n                    var alias = this.arg\n                    var init = !oldVms\n                    var vms = new Array(data.length)\n                    var obj, raw, vm, i, l\n                    // First pass, go through the new Array and fill up\n                    // the new vms array. If a piece of data has a cached\n                    // instance for it, we reuse it. Otherwise build a new\n                    // instance.\n                    for (i = 0, l = data.length; i < l; i++) {\n                        obj = data[i]\n                        raw = converted ? obj.$value : obj\n                        vm = !init && this.getVm(raw)\n                        if (vm) { // reusable instance\n                            vm._reused = true\n                            vm.$index = i // update $index\n                            if (converted) {\n                                vm.$key = obj.$key // update $key\n                            }\n                            if (idKey) { // swap track by id data\n                                if (alias) {\n                                    vm[alias] = raw\n                                } else {\n                                    vm._setData(raw)\n                                }\n                            }\n                        } else { // new instance\n                            vm = this.build(obj, i, true)\n                            vm._new = true\n                            vm._reused = false\n                        }\n                        vms[i] = vm\n                        // insert if this is first run\n                        if (init) {\n                            vm.$before(ref)\n                        }\n                    }\n                    // if this is the first run, we're done.\n                    if (init) {\n                        return vms\n                    }\n                    // Second pass, go through the old vm instances and\n                    // destroy those who are not reused (and remove them\n                    // from cache)\n                    for (i = 0, l = oldVms.length; i < l; i++) {\n                        vm = oldVms[i]\n                        if (!vm._reused) {\n                            this.uncacheVm(vm)\n                            vm.$destroy(true)\n                        }\n                    }\n                    // final pass, move/insert new instances into the\n                    // right place. We're going in reverse here because\n                    // insertBefore relies on the next sibling to be\n                    // resolved.\n                    var targetNext, currentNext\n                    i = vms.length\n                    while (i--) {\n                        vm = vms[i]\n                        // this is the vm that we should be in front of\n                        targetNext = vms[i + 1]\n                        if (!targetNext) {\n                            // This is the last item. If it's reused then\n                            // everything else will eventually be in the right\n                            // place, so no need to touch it. Otherwise, insert\n                            // it.\n                            if (!vm._reused) {\n                                vm.$before(ref)\n                            }\n                        } else {\n                            var nextEl = targetNext.$el\n                            if (vm._reused) {\n                                // this is the vm we are actually in front of\n                                currentNext = findNextVm(vm, ref)\n                                // we only need to move if we are not in the right\n                                // place already.\n                                if (currentNext !== targetNext) {\n                                    vm.$before(nextEl, null, false)\n                                }\n                            } else {\n                                // new instance, insert to existing next\n                                vm.$before(nextEl)\n                            }\n                        }\n                        vm._new = false\n                        vm._reused = false\n                    }\n                    return vms\n                },\n\n                /**\n                 * Build a new instance and cache it.\n                 *\n                 * @param {Object} data\n                 * @param {Number} index\n                 * @param {Boolean} needCache\n                 */\n\n                build: function (data, index, needCache) {\n                    var meta = { $index: index }\n                    if (this.converted) {\n                        meta.$key = data.$key\n                    }\n                    var raw = this.converted ? data.$value : data\n                    var alias = this.arg\n                    if (alias) {\n                        data = {}\n                        data[alias] = raw\n                    } else if (!isPlainObject(raw)) {\n                        // non-object values\n                        data = {}\n                        meta.$value = raw\n                    } else {\n                        // default\n                        data = raw\n                    }\n                    // resolve constructor\n                    var Ctor = this.Ctor || this.resolveCtor(data, meta)\n                    var vm = this.vm.$addChild({\n                        el: templateParser.clone(this.template),\n                        _asComponent: this.asComponent,\n                        _host: this._host,\n                        _linkFn: this._linkFn,\n                        _meta: meta,\n                        data: data,\n                        inherit: this.inherit,\n                        template: this.inlineTempalte\n                    }, Ctor)\n                    // flag this instance as a repeat instance\n                    // so that we can skip it in vm._digest\n                    vm._repeat = true\n                    // cache instance\n                    if (needCache) {\n                        this.cacheVm(raw, vm)\n                    }\n                    // sync back changes for $value, particularly for\n                    // two-way bindings of primitive values\n                    var self = this\n                    vm.$watch('$value', function (val) {\n                        if (self.converted) {\n                            self.rawValue[vm.$key] = val\n                        } else {\n                            self.rawValue.$set(vm.$index, val)\n                        }\n                    })\n                    return vm\n                },\n\n                /**\n                 * Resolve a contructor to use for an instance.\n                 * The tricky part here is that there could be dynamic\n                 * components depending on instance data.\n                 *\n                 * @param {Object} data\n                 * @param {Object} meta\n                 * @return {Function}\n                 */\n\n                resolveCtor: function (data, meta) {\n                    // create a temporary context object and copy data\n                    // and meta properties onto it.\n                    // use _.define to avoid accidentally overwriting scope\n                    // properties.\n                    var context = Object.create(this.vm)\n                    var key\n                    for (key in data) {\n                        _.define(context, key, data[key])\n                    }\n                    for (key in meta) {\n                        _.define(context, key, meta[key])\n                    }\n                    var id = this.ctorGetter.call(context, context)\n                    var Ctor = this.vm.$options.components[id]\n                    _.assertAsset(Ctor, 'component', id)\n                    return Ctor\n                },\n\n                /**\n                 * Unbind, teardown everything\n                 */\n\n                unbind: function () {\n                    if (this.refID) {\n                        this.vm.$[this.refID] = null\n                    }\n                    if (this.vms) {\n                        var i = this.vms.length\n                        var vm\n                        while (i--) {\n                            vm = this.vms[i]\n                            this.uncacheVm(vm)\n                            vm.$destroy()\n                        }\n                    }\n                },\n\n                /**\n                 * Cache a vm instance based on its data.\n                 *\n                 * If the data is an object, we save the vm's reference on\n                 * the data object as a hidden property. Otherwise we\n                 * cache them in an object and for each primitive value\n                 * there is an array in case there are duplicates.\n                 *\n                 * @param {Object} data\n                 * @param {Vue} vm\n                 */\n\n                cacheVm: function (data, vm) {\n                    var idKey = this.idKey\n                    var cache = this.cache\n                    var id\n                    if (idKey) {\n                        id = data[idKey]\n                        if (!cache[id]) {\n                            cache[id] = vm\n                        } else {\n                            _.warn('Duplicate track-by key in v-repeat: ' + id)\n                        }\n                    } else if (isObject(data)) {\n                        id = this.id\n                        if (data.hasOwnProperty(id)) {\n                            if (data[id] === null) {\n                                data[id] = vm\n                            } else {\n                                _.warn(\n                                    'Duplicate objects are not supported in v-repeat ' +\n                                    'when using components or transitions.'\n                                )\n                            }\n                        } else {\n                            _.define(data, this.id, vm)\n                        }\n                    } else {\n                        if (!cache[data]) {\n                            cache[data] = [vm]\n                        } else {\n                            cache[data].push(vm)\n                        }\n                    }\n                    vm._raw = data\n                },\n\n                /**\n                 * Try to get a cached instance from a piece of data.\n                 *\n                 * @param {Object} data\n                 * @return {Vue|undefined}\n                 */\n\n                getVm: function (data) {\n                    if (this.idKey) {\n                        return this.cache[data[this.idKey]]\n                    } else if (isObject(data)) {\n                        return data[this.id]\n                    } else {\n                        var cached = this.cache[data]\n                        if (cached) {\n                            var i = 0\n                            var vm = cached[i]\n                            // since duplicated vm instances might be a reused\n                            // one OR a newly created one, we need to return the\n                            // first instance that is neither of these.\n                            while (vm && (vm._reused || vm._new)) {\n                                vm = cached[++i]\n                            }\n                            return vm\n                        }\n                    }\n                },\n\n                /**\n                 * Delete a cached vm instance.\n                 *\n                 * @param {Vue} vm\n                 */\n\n                uncacheVm: function (vm) {\n                    var data = vm._raw\n                    if (this.idKey) {\n                        this.cache[data[this.idKey]] = null\n                    } else if (isObject(data)) {\n                        data[this.id] = null\n                        vm._raw = null\n                    } else {\n                        this.cache[data].pop()\n                    }\n                }\n\n            }\n\n            /**\n             * Helper to find the next element that is an instance\n             * root node. This is necessary because a destroyed vm's\n             * element could still be lingering in the DOM before its\n             * leaving transition finishes, but its __vue__ reference\n             * should have been removed so we can skip them.\n             *\n             * @param {Vue} vm\n             * @param {CommentNode} ref\n             * @return {Vue}\n             */\n\n            function findNextVm (vm, ref) {\n                var el = (vm._blockEnd || vm.$el).nextSibling\n                while (!el.__vue__ && el !== ref) {\n                    el = el.nextSibling\n                }\n                return el.__vue__\n            }\n\n            /**\n             * Attempt to convert non-Array objects to array.\n             * This is the default filter installed to every v-repeat\n             * directive.\n             *\n             * It will be called with **the directive** as `this`\n             * context so that we can mark the repeat array as converted\n             * from an object.\n             *\n             * @param {*} obj\n             * @return {Array}\n             * @private\n             */\n\n            function objToArray (obj) {\n                // regardless of type, store the un-filtered raw value.\n                this.rawValue = obj\n                if (!isPlainObject(obj)) {\n                    return obj\n                }\n                var keys = Object.keys(obj)\n                var i = keys.length\n                var res = new Array(i)\n                var key\n                while (i--) {\n                    key = keys[i]\n                    res[i] = {\n                        $key: key,\n                        $value: obj[key]\n                    }\n                }\n                // `this` points to the repeat directive instance\n                this.converted = true\n                return res\n            }\n\n            /**\n             * Create a range array from given number.\n             *\n             * @param {Number} n\n             * @return {Array}\n             */\n\n            function range (n) {\n                var i = -1\n                var ret = new Array(n)\n                while (++i < n) {\n                    ret[i] = i\n                }\n                return ret\n            }\n\n            /***/ },\n        /* 45 */\n        /***/ function(module, exports, __webpack_require__) {\n\n            var _ = __webpack_require__(11)\n            var compile = __webpack_require__(16)\n            var templateParser = __webpack_require__(20)\n            var transition = __webpack_require__(50)\n\n            module.exports = {\n\n                bind: function () {\n                    var el = this.el\n                    if (!el.__vue__) {\n                        this.start = document.createComment('v-if-start')\n                        this.end = document.createComment('v-if-end')\n                        _.replace(el, this.end)\n                        _.before(this.start, this.end)\n                        if (el.tagName === 'TEMPLATE') {\n                            this.template = templateParser.parse(el, true)\n                        } else {\n                            this.template = document.createDocumentFragment()\n                            this.template.appendChild(templateParser.clone(el))\n                        }\n                        // compile the nested partial\n                        this.linker = compile(\n                            this.template,\n                            this.vm.$options,\n                            true\n                        )\n                    } else {\n                        this.invalid = true\n                        _.warn(\n                            'v-if=\"' + this.expression + '\" cannot be ' +\n                            'used on an already mounted instance.'\n                        )\n                    }\n                },\n\n                update: function (value) {\n                    if (this.invalid) return\n                    if (value) {\n                        // avoid duplicate compiles, since update() can be\n                        // called with different truthy values\n                        if (!this.unlink) {\n                            var frag = templateParser.clone(this.template)\n                            this.compile(frag)\n                        }\n                    } else {\n                        this.teardown()\n                    }\n                },\n\n                // NOTE: this function is shared in v-partial\n                compile: function (frag) {\n                    var vm = this.vm\n                    // the linker is not guaranteed to be present because\n                    // this function might get called by v-partial \n                    this.unlink = this.linker\n                        ? this.linker(vm, frag)\n                        : vm.$compile(frag)\n                    transition.blockAppend(frag, this.end, vm)\n                    // call attached for all the child components created\n                    // during the compilation\n                    if (_.inDoc(vm.$el)) {\n                        var children = this.getContainedComponents()\n                        if (children) children.forEach(callAttach)\n                    }\n                },\n\n                // NOTE: this function is shared in v-partial\n                teardown: function () {\n                    if (!this.unlink) return\n                    // collect children beforehand\n                    var children\n                    if (_.inDoc(this.vm.$el)) {\n                        children = this.getContainedComponents()\n                    }\n                    transition.blockRemove(this.start, this.end, this.vm)\n                    if (children) children.forEach(callDetach)\n                    this.unlink()\n                    this.unlink = null\n                },\n\n                // NOTE: this function is shared in v-partial\n                getContainedComponents: function () {\n                    var vm = this.vm\n                    var start = this.start.nextSibling\n                    var end = this.end\n                    var selfCompoents =\n                        vm._children.length &&\n                        vm._children.filter(contains)\n                    var transComponents =\n                        vm._transCpnts &&\n                        vm._transCpnts.filter(contains)\n\n                    function contains (c) {\n                        var cur = start\n                        var next\n                        while (next !== end) {\n                            next = cur.nextSibling\n                            if (cur.contains(c.$el)) {\n                                return true\n                            }\n                            cur = next\n                        }\n                        return false\n                    }\n\n                    return selfCompoents\n                        ? transComponents\n                        ? selfCompoents.concat(transComponents)\n                        : selfCompoents\n                        : transComponents\n                },\n\n                // NOTE: this function is shared in v-partial\n                unbind: function () {\n                    if (this.unlink) this.unlink()\n                }\n\n            }\n\n            function callAttach (child) {\n                if (!child._isAttached) {\n                    child._callHook('attached')\n                }\n            }\n\n            function callDetach (child) {\n                if (child._isAttached) {\n                    child._callHook('detached')\n                }\n            }\n\n            /***/ },\n        /* 46 */\n        /***/ function(module, exports, __webpack_require__) {\n\n            var _ = __webpack_require__(11)\n            var Watcher = __webpack_require__(25)\n            var expParser = __webpack_require__(22)\n            var literalRE = /^(true|false|\\s?('[^']*'|\"[^\"]\")\\s?)$/\n\n            module.exports = {\n\n                priority: 900,\n\n                bind: function () {\n\n                    var child = this.vm\n                    var parent = child.$parent\n                    var childKey = this.arg || '$data'\n                    var parentKey = this.expression\n\n                    if (this.el && this.el !== child.$el) {\n                        _.warn(\n                            'v-with can only be used on instance root elements.'\n                        )\n                    } else if (!parent) {\n                        _.warn(\n                            'v-with must be used on an instance with a parent.'\n                        )\n                    } else if (literalRE.test(parentKey)) {\n                        // no need to setup watchers for literal bindings\n                        if (!this.arg) {\n                            _.warn(\n                                'v-with cannot bind literal value as $data: ' +\n                                parentKey\n                            )\n                        } else {\n                            var value = expParser.parse(parentKey).get()\n                            child.$set(childKey, value)\n                        }\n                    } else {\n\n                        // simple lock to avoid circular updates.\n                        // without this it would stabilize too, but this makes\n                        // sure it doesn't cause other watchers to re-evaluate.\n                        var locked = false\n                        var lock = function () {\n                            locked = true\n                            _.nextTick(unlock)\n                        }\n                        var unlock = function () {\n                            locked = false\n                        }\n\n                        this.parentWatcher = new Watcher(\n                            parent,\n                            parentKey,\n                            function (val) {\n                                if (!locked) {\n                                    lock()\n                                    child.$set(childKey, val)\n                                }\n                            }\n                        )\n\n                        // set the child initial value first, before setting\n                        // up the child watcher to avoid triggering it\n                        // immediately.\n                        child.$set(childKey, this.parentWatcher.value)\n\n                        this.childWatcher = new Watcher(\n                            child,\n                            childKey,\n                            function (val) {\n                                if (!locked) {\n                                    lock()\n                                    parent.$set(parentKey, val)\n                                }\n                            }\n                        )\n                    }\n                },\n\n                unbind: function () {\n                    if (this.parentWatcher) {\n                        this.parentWatcher.teardown()\n                        this.childWatcher.teardown()\n                    }\n                }\n\n            }\n\n            /***/ },\n        /* 47 */\n        /***/ function(module, exports, __webpack_require__) {\n\n            var _ = __webpack_require__(11)\n\n            module.exports = {\n\n                acceptStatement: true,\n\n                bind: function () {\n                    var child = this.el.__vue__\n                    if (!child || this.vm !== child.$parent) {\n                        _.warn(\n                            '`v-events` should only be used on a child component ' +\n                            'from the parent template.'\n                        )\n                        return\n                    }\n                },\n\n                update: function (handler, oldHandler) {\n                    if (typeof handler !== 'function') {\n                        _.warn(\n                            'Directive \"v-events:' + this.expression + '\" ' +\n                            'expects a function value.'\n                        )\n                        return\n                    }\n                    var child = this.el.__vue__\n                    if (oldHandler) {\n                        child.$off(this.arg, oldHandler)\n                    }\n                    child.$on(this.arg, handler)\n                }\n\n                // when child is destroyed, all events are turned off,\n                // so no need for unbind here.\n\n            }\n\n            /***/ },\n        /* 48 */\n        /***/ function(module, exports, __webpack_require__) {\n\n            var _ = __webpack_require__(11)\n            var Path = __webpack_require__(18)\n\n            /**\n             * Filter filter for v-repeat\n             *\n             * @param {String} searchKey\n             * @param {String} [delimiter]\n             * @param {String} dataKey\n             */\n\n            exports.filterBy = function (arr, searchKey, delimiter, dataKey) {\n                // allow optional `in` delimiter\n                // because why not\n                if (delimiter && delimiter !== 'in') {\n                    dataKey = delimiter\n                }\n                // get the search string\n                var search =\n                    _.stripQuotes(searchKey) ||\n                    this.$get(searchKey)\n                if (!search) {\n                    return arr\n                }\n                search = ('' + search).toLowerCase()\n                // get the optional dataKey\n                dataKey =\n                    dataKey &&\n                    (_.stripQuotes(dataKey) || this.$get(dataKey))\n                return arr.filter(function (item) {\n                    return dataKey\n                        ? contains(Path.get(item, dataKey), search)\n                        : contains(item, search)\n                })\n            }\n\n            /**\n             * Filter filter for v-repeat\n             *\n             * @param {String} sortKey\n             * @param {String} reverseKey\n             */\n\n            exports.orderBy = function (arr, sortKey, reverseKey) {\n                var key =\n                    _.stripQuotes(sortKey) ||\n                    this.$get(sortKey)\n                if (!key) {\n                    return arr\n                }\n                var order = 1\n                if (reverseKey) {\n                    if (reverseKey === '-1') {\n                        order = -1\n                    } else if (reverseKey.charCodeAt(0) === 0x21) { // !\n                        reverseKey = reverseKey.slice(1)\n                        order = this.$get(reverseKey) ? 1 : -1\n                    } else {\n                        order = this.$get(reverseKey) ? -1 : 1\n                    }\n                }\n                // sort on a copy to avoid mutating original array\n                return arr.slice().sort(function (a, b) {\n                    a = _.isObject(a) ? Path.get(a, key) : a\n                    b = _.isObject(b) ? Path.get(b, key) : b\n                    return a === b ? 0 : a > b ? order : -order\n                })\n            }\n\n            /**\n             * String contain helper\n             *\n             * @param {*} val\n             * @param {String} search\n             */\n\n            function contains (val, search) {\n                if (_.isObject(val)) {\n                    for (var key in val) {\n                        if (contains(val[key], search)) {\n                            return true\n                        }\n                    }\n                } else if (val != null) {\n                    return val.toString().toLowerCase().indexOf(search) > -1\n                }\n            }\n\n            /***/ },\n        /* 49 */\n        /***/ function(module, exports, __webpack_require__) {\n\n            var _ = __webpack_require__(11)\n            var config = __webpack_require__(15)\n            var Dep = __webpack_require__(23)\n            var arrayMethods = __webpack_require__(54)\n            var arrayKeys = Object.getOwnPropertyNames(arrayMethods)\n            __webpack_require__(55)\n\n            var uid = 0\n\n            /**\n             * Type enums\n             */\n\n            var ARRAY  = 0\n            var OBJECT = 1\n\n            /**\n             * Augment an target Object or Array by intercepting\n             * the prototype chain using __proto__\n             *\n             * @param {Object|Array} target\n             * @param {Object} proto\n             */\n\n            function protoAugment (target, src) {\n                target.__proto__ = src\n            }\n\n            /**\n             * Augment an target Object or Array by defining\n             * hidden properties.\n             *\n             * @param {Object|Array} target\n             * @param {Object} proto\n             */\n\n            function copyAugment (target, src, keys) {\n                var i = keys.length\n                var key\n                while (i--) {\n                    key = keys[i]\n                    _.define(target, key, src[key])\n                }\n            }\n\n            /**\n             * Observer class that are attached to each observed\n             * object. Once attached, the observer converts target\n             * object's property keys into getter/setters that\n             * collect dependencies and dispatches updates.\n             *\n             * @param {Array|Object} value\n             * @param {Number} type\n             * @constructor\n             */\n\n            function Observer (value, type) {\n                this.id = ++uid\n                this.value = value\n                this.active = true\n                this.deps = []\n                _.define(value, '__ob__', this)\n                if (type === ARRAY) {\n                    var augment = config.proto && _.hasProto\n                        ? protoAugment\n                        : copyAugment\n                    augment(value, arrayMethods, arrayKeys)\n                    this.observeArray(value)\n                } else if (type === OBJECT) {\n                    this.walk(value)\n                }\n            }\n\n            Observer.target = null\n\n            var p = Observer.prototype\n\n            /**\n             * Attempt to create an observer instance for a value,\n             * returns the new observer if successfully observed,\n             * or the existing observer if the value already has one.\n             *\n             * @param {*} value\n             * @return {Observer|undefined}\n             * @static\n             */\n\n            Observer.create = function (value) {\n                if (\n                    value &&\n                    value.hasOwnProperty('__ob__') &&\n                    value.__ob__ instanceof Observer\n                ) {\n                    return value.__ob__\n                } else if (_.isArray(value)) {\n                    return new Observer(value, ARRAY)\n                } else if (\n                    _.isPlainObject(value) &&\n                    !value._isVue // avoid Vue instance\n                ) {\n                    return new Observer(value, OBJECT)\n                }\n            }\n\n            /**\n             * Walk through each property and convert them into\n             * getter/setters. This method should only be called when\n             * value type is Object. Properties prefixed with `$` or `_`\n             * and accessor properties are ignored.\n             *\n             * @param {Object} obj\n             */\n\n            p.walk = function (obj) {\n                var keys = Object.keys(obj)\n                var i = keys.length\n                var key, prefix\n                while (i--) {\n                    key = keys[i]\n                    prefix = key.charCodeAt(0)\n                    if (prefix !== 0x24 && prefix !== 0x5F) { // skip $ or _\n                        this.convert(key, obj[key])\n                    }\n                }\n            }\n\n            /**\n             * Try to carete an observer for a child value,\n             * and if value is array, link dep to the array.\n             *\n             * @param {*} val\n             * @return {Dep|undefined}\n             */\n\n            p.observe = function (val) {\n                return Observer.create(val)\n            }\n\n            /**\n             * Observe a list of Array items.\n             *\n             * @param {Array} items\n             */\n\n            p.observeArray = function (items) {\n                var i = items.length\n                while (i--) {\n                    this.observe(items[i])\n                }\n            }\n\n            /**\n             * Convert a property into getter/setter so we can emit\n             * the events when the property is accessed/changed.\n             *\n             * @param {String} key\n             * @param {*} val\n             */\n\n            p.convert = function (key, val) {\n                var ob = this\n                var childOb = ob.observe(val)\n                var dep = new Dep()\n                if (childOb) {\n                    childOb.deps.push(dep)\n                }\n                Object.defineProperty(ob.value, key, {\n                    enumerable: true,\n                    configurable: true,\n                    get: function () {\n                        // Observer.target is a watcher whose getter is\n                        // currently being evaluated.\n                        if (ob.active && Observer.target) {\n                            Observer.target.addDep(dep)\n                        }\n                        return val\n                    },\n                    set: function (newVal) {\n                        if (newVal === val) return\n                        // remove dep from old value\n                        var oldChildOb = val && val.__ob__\n                        if (oldChildOb) {\n                            var oldDeps = oldChildOb.deps\n                            oldDeps.splice(oldDeps.indexOf(dep), 1)\n                        }\n                        val = newVal\n                        // add dep to new value\n                        var newChildOb = ob.observe(newVal)\n                        if (newChildOb) {\n                            newChildOb.deps.push(dep)\n                        }\n                        dep.notify()\n                    }\n                })\n            }\n\n            /**\n             * Notify change on all self deps on an observer.\n             * This is called when a mutable value mutates. e.g.\n             * when an Array's mutating methods are called, or an\n             * Object's $add/$delete are called.\n             */\n\n            p.notify = function () {\n                var deps = this.deps\n                for (var i = 0, l = deps.length; i < l; i++) {\n                    deps[i].notify()\n                }\n            }\n\n            /**\n             * Add an owner vm, so that when $add/$delete mutations\n             * happen we can notify owner vms to proxy the keys and\n             * digest the watchers. This is only called when the object\n             * is observed as an instance's root $data.\n             *\n             * @param {Vue} vm\n             */\n\n            p.addVm = function (vm) {\n                (this.vms = this.vms || []).push(vm)\n            }\n\n            /**\n             * Remove an owner vm. This is called when the object is\n             * swapped out as an instance's $data object.\n             *\n             * @param {Vue} vm\n             */\n\n            p.removeVm = function (vm) {\n                this.vms.splice(this.vms.indexOf(vm), 1)\n            }\n\n            module.exports = Observer\n\n\n            /***/ },\n        /* 50 */\n        /***/ function(module, exports, __webpack_require__) {\n\n            var _ = __webpack_require__(11)\n            var applyCSSTransition = __webpack_require__(56)\n            var applyJSTransition = __webpack_require__(57)\n            var doc = typeof document === 'undefined' ? null : document\n\n            /**\n             * Append with transition.\n             *\n             * @oaram {Element} el\n             * @param {Element} target\n             * @param {Vue} vm\n             * @param {Function} [cb]\n             */\n\n            exports.append = function (el, target, vm, cb) {\n                apply(el, 1, function () {\n                    target.appendChild(el)\n                }, vm, cb)\n            }\n\n            /**\n             * InsertBefore with transition.\n             *\n             * @oaram {Element} el\n             * @param {Element} target\n             * @param {Vue} vm\n             * @param {Function} [cb]\n             */\n\n            exports.before = function (el, target, vm, cb) {\n                apply(el, 1, function () {\n                    _.before(el, target)\n                }, vm, cb)\n            }\n\n            /**\n             * Remove with transition.\n             *\n             * @oaram {Element} el\n             * @param {Vue} vm\n             * @param {Function} [cb]\n             */\n\n            exports.remove = function (el, vm, cb) {\n                apply(el, -1, function () {\n                    _.remove(el)\n                }, vm, cb)\n            }\n\n            /**\n             * Remove by appending to another parent with transition.\n             * This is only used in block operations.\n             *\n             * @oaram {Element} el\n             * @param {Element} target\n             * @param {Vue} vm\n             * @param {Function} [cb]\n             */\n\n            exports.removeThenAppend = function (el, target, vm, cb) {\n                apply(el, -1, function () {\n                    target.appendChild(el)\n                }, vm, cb)\n            }\n\n            /**\n             * Append the childNodes of a fragment to target.\n             *\n             * @param {DocumentFragment} block\n             * @param {Node} target\n             * @param {Vue} vm\n             */\n\n            exports.blockAppend = function (block, target, vm) {\n                var nodes = _.toArray(block.childNodes)\n                for (var i = 0, l = nodes.length; i < l; i++) {\n                    exports.before(nodes[i], target, vm)\n                }\n            }\n\n            /**\n             * Remove a block of nodes between two edge nodes.\n             *\n             * @param {Node} start\n             * @param {Node} end\n             * @param {Vue} vm\n             */\n\n            exports.blockRemove = function (start, end, vm) {\n                var node = start.nextSibling\n                var next\n                while (node !== end) {\n                    next = node.nextSibling\n                    exports.remove(node, vm)\n                    node = next\n                }\n            }\n\n            /**\n             * Apply transitions with an operation callback.\n             *\n             * @oaram {Element} el\n             * @param {Number} direction\n             *                  1: enter\n             *                 -1: leave\n             * @param {Function} op - the actual DOM operation\n             * @param {Vue} vm\n             * @param {Function} [cb]\n             */\n\n            var apply = exports.apply = function (el, direction, op, vm, cb) {\n                var transData = el.__v_trans\n                if (\n                    !transData ||\n                    !vm._isCompiled ||\n                        // if the vm is being manipulated by a parent directive\n                        // during the parent's compilation phase, skip the\n                        // animation.\n                    (vm.$parent && !vm.$parent._isCompiled)\n                ) {\n                    op()\n                    if (cb) cb()\n                    return\n                }\n                // determine the transition type on the element\n                var jsTransition = transData.fns\n                if (jsTransition) {\n                    // js\n                    applyJSTransition(\n                        el,\n                        direction,\n                        op,\n                        transData,\n                        jsTransition,\n                        vm,\n                        cb\n                    )\n                } else if (\n                    _.transitionEndEvent &&\n                        // skip CSS transitions if page is not visible -\n                        // this solves the issue of transitionend events not\n                        // firing until the page is visible again.\n                        // pageVisibility API is supported in IE10+, same as\n                        // CSS transitions.\n                    !(doc && doc.hidden)\n                ) {\n                    // css\n                    applyCSSTransition(\n                        el,\n                        direction,\n                        op,\n                        transData,\n                        cb\n                    )\n                } else {\n                    // not applicable\n                    op()\n                    if (cb) cb()\n                }\n            }\n\n            /***/ },\n        /* 51 */\n        /***/ function(module, exports, __webpack_require__) {\n\n            var _ = __webpack_require__(11)\n\n            var handlers = {\n                _default: __webpack_require__(58),\n                radio: __webpack_require__(59),\n                select: __webpack_require__(60),\n                checkbox: __webpack_require__(61)\n            }\n\n            module.exports = {\n\n                priority: 800,\n                twoWay: true,\n                handlers: handlers,\n\n                /**\n                 * Possible elements:\n                 *   <select>\n                 *   <textarea>\n                 *   <input type=\"*\">\n                 *     - text\n                 *     - checkbox\n                 *     - radio\n                 *     - number\n                 *     - TODO: more types may be supplied as a plugin\n                 */\n\n                bind: function () {\n                    // friendly warning...\n                    var filters = this.filters\n                    if (filters && filters.read && !filters.write) {\n                        _.warn(\n                            'It seems you are using a read-only filter with ' +\n                            'v-model. You might want to use a two-way filter ' +\n                            'to ensure correct behavior.'\n                        )\n                    }\n                    var el = this.el\n                    var tag = el.tagName\n                    var handler\n                    if (tag === 'INPUT') {\n                        handler = handlers[el.type] || handlers._default\n                    } else if (tag === 'SELECT') {\n                        handler = handlers.select\n                    } else if (tag === 'TEXTAREA') {\n                        handler = handlers._default\n                    } else {\n                        _.warn(\"v-model doesn't support element type: \" + tag)\n                        return\n                    }\n                    handler.bind.call(this)\n                    this.update = handler.update\n                    this.unbind = handler.unbind\n                }\n\n            }\n\n            /***/ },\n        /* 52 */\n        /***/ function(module, exports, __webpack_require__) {\n\n            /**\n             * A doubly linked list-based Least Recently Used (LRU)\n             * cache. Will keep most recently used items while\n             * discarding least recently used items when its limit is\n             * reached. This is a bare-bone version of\n             * Rasmus Andersson's js-lru:\n             *\n             *   https://github.com/rsms/js-lru\n             *\n             * @param {Number} limit\n             * @constructor\n             */\n\n            function Cache (limit) {\n                this.size = 0\n                this.limit = limit\n                this.head = this.tail = undefined\n                this._keymap = {}\n            }\n\n            var p = Cache.prototype\n\n            /**\n             * Put <value> into the cache associated with <key>.\n             * Returns the entry which was removed to make room for\n             * the new entry. Otherwise undefined is returned.\n             * (i.e. if there was enough room already).\n             *\n             * @param {String} key\n             * @param {*} value\n             * @return {Entry|undefined}\n             */\n\n            p.put = function (key, value) {\n                var entry = {\n                    key:key,\n                    value:value\n                }\n                this._keymap[key] = entry\n                if (this.tail) {\n                    this.tail.newer = entry\n                    entry.older = this.tail\n                } else {\n                    this.head = entry\n                }\n                this.tail = entry\n                if (this.size === this.limit) {\n                    return this.shift()\n                } else {\n                    this.size++\n                }\n            }\n\n            /**\n             * Purge the least recently used (oldest) entry from the\n             * cache. Returns the removed entry or undefined if the\n             * cache was empty.\n             */\n\n            p.shift = function () {\n                var entry = this.head\n                if (entry) {\n                    this.head = this.head.newer\n                    this.head.older = undefined\n                    entry.newer = entry.older = undefined\n                    this._keymap[entry.key] = undefined\n                }\n                return entry\n            }\n\n            /**\n             * Get and register recent use of <key>. Returns the value\n             * associated with <key> or undefined if not in cache.\n             *\n             * @param {String} key\n             * @param {Boolean} returnEntry\n             * @return {Entry|*}\n             */\n\n            p.get = function (key, returnEntry) {\n                var entry = this._keymap[key]\n                if (entry === undefined) return\n                if (entry === this.tail) {\n                    return returnEntry\n                        ? entry\n                        : entry.value\n                }\n                // HEAD--------------TAIL\n                //   <.older   .newer>\n                //  <--- add direction --\n                //   A  B  C  <D>  E\n                if (entry.newer) {\n                    if (entry === this.head) {\n                        this.head = entry.newer\n                    }\n                    entry.newer.older = entry.older // C <-- E.\n                }\n                if (entry.older) {\n                    entry.older.newer = entry.newer // C. --> E\n                }\n                entry.newer = undefined // D --x\n                entry.older = this.tail // D. --> E\n                if (this.tail) {\n                    this.tail.newer = entry // E. <-- D\n                }\n                this.tail = entry\n                return returnEntry\n                    ? entry\n                    : entry.value\n            }\n\n            module.exports = Cache\n\n            /***/ },\n        /* 53 */\n        /***/ function(module, exports, __webpack_require__) {\n\n            var _ = __webpack_require__(11)\n            var MAX_UPDATE_COUNT = 10\n\n            // we have two separate queues: one for directive updates\n            // and one for user watcher registered via $watch().\n            // we want to guarantee directive updates to be called\n            // before user watchers so that when user watchers are\n            // triggered, the DOM would have already been in updated\n            // state.\n            var queue = []\n            var userQueue = []\n            var has = {}\n            var waiting = false\n            var flushing = false\n\n            /**\n             * Reset the batcher's state.\n             */\n\n            function reset () {\n                queue = []\n                userQueue = []\n                has = {}\n                waiting = false\n                flushing = false\n            }\n\n            /**\n             * Flush both queues and run the jobs.\n             */\n\n            function flush () {\n                flushing = true\n                run(queue)\n                run(userQueue)\n                reset()\n            }\n\n            /**\n             * Run the jobs in a single queue.\n             *\n             * @param {Array} queue\n             */\n\n            function run (queue) {\n                // do not cache length because more jobs might be pushed\n                // as we run existing jobs\n                for (var i = 0; i < queue.length; i++) {\n                    queue[i].run()\n                }\n            }\n\n            /**\n             * Push a job into the job queue.\n             * Jobs with duplicate IDs will be skipped unless it's\n             * pushed when the queue is being flushed.\n             *\n             * @param {Object} job\n             *   properties:\n             *   - {String|Number} id\n             *   - {Function}      run\n             */\n\n            exports.push = function (job) {\n                var id = job.id\n                if (!id || !has[id] || flushing) {\n                    if (!has[id]) {\n                        has[id] = 1\n                    } else {\n                        has[id]++\n                        // detect possible infinite update loops\n                        if (has[id] > MAX_UPDATE_COUNT) {\n                            _.warn(\n                                'You may have an infinite update loop for the ' +\n                                'watcher with expression: \"' + job.expression + '\".'\n                            )\n                            return\n                        }\n                    }\n                    // A user watcher callback could trigger another\n                    // directive update during the flushing; at that time\n                    // the directive queue would already have been run, so\n                    // we call that update immediately as it is pushed.\n                    if (flushing && !job.user) {\n                        job.run()\n                        return\n                    }\n                    ;(job.user ? userQueue : queue).push(job)\n                    if (!waiting) {\n                        waiting = true\n                        _.nextTick(flush)\n                    }\n                }\n            }\n\n            /***/ },\n        /* 54 */\n        /***/ function(module, exports, __webpack_require__) {\n\n            var _ = __webpack_require__(11)\n            var arrayProto = Array.prototype\n            var arrayMethods = Object.create(arrayProto)\n\n            /**\n             * Intercept mutating methods and emit events\n             */\n\n                ;[\n                'push',\n                'pop',\n                'shift',\n                'unshift',\n                'splice',\n                'sort',\n                'reverse'\n            ]\n                .forEach(function (method) {\n                    // cache original method\n                    var original = arrayProto[method]\n                    _.define(arrayMethods, method, function mutator () {\n                        // avoid leaking arguments:\n                        // http://jsperf.com/closure-with-arguments\n                        var i = arguments.length\n                        var args = new Array(i)\n                        while (i--) {\n                            args[i] = arguments[i]\n                        }\n                        var result = original.apply(this, args)\n                        var ob = this.__ob__\n                        var inserted\n                        switch (method) {\n                            case 'push':\n                                inserted = args\n                                break\n                            case 'unshift':\n                                inserted = args\n                                break\n                            case 'splice':\n                                inserted = args.slice(2)\n                                break\n                        }\n                        if (inserted) ob.observeArray(inserted)\n                        // notify change\n                        ob.notify()\n                        return result\n                    })\n                })\n\n            /**\n             * Swap the element at the given index with a new value\n             * and emits corresponding event.\n             *\n             * @param {Number} index\n             * @param {*} val\n             * @return {*} - replaced element\n             */\n\n            _.define(\n                arrayProto,\n                '$set',\n                function $set (index, val) {\n                    if (index >= this.length) {\n                        this.length = index + 1\n                    }\n                    return this.splice(index, 1, val)[0]\n                }\n            )\n\n            /**\n             * Convenience method to remove the element at given index.\n             *\n             * @param {Number} index\n             * @param {*} val\n             */\n\n            _.define(\n                arrayProto,\n                '$remove',\n                function $remove (index) {\n                    if (typeof index !== 'number') {\n                        index = this.indexOf(index)\n                    }\n                    if (index > -1) {\n                        return this.splice(index, 1)[0]\n                    }\n                }\n            )\n\n            module.exports = arrayMethods\n\n            /***/ },\n        /* 55 */\n        /***/ function(module, exports, __webpack_require__) {\n\n            var _ = __webpack_require__(11)\n            var objProto = Object.prototype\n\n            /**\n             * Add a new property to an observed object\n             * and emits corresponding event\n             *\n             * @param {String} key\n             * @param {*} val\n             * @public\n             */\n\n            _.define(\n                objProto,\n                '$add',\n                function $add (key, val) {\n                    if (this.hasOwnProperty(key)) return\n                    var ob = this.__ob__\n                    if (!ob || _.isReserved(key)) {\n                        this[key] = val\n                        return\n                    }\n                    ob.convert(key, val)\n                    if (ob.vms) {\n                        var i = ob.vms.length\n                        while (i--) {\n                            var vm = ob.vms[i]\n                            vm._proxy(key)\n                            vm._digest()\n                        }\n                    } else {\n                        ob.notify()\n                    }\n                }\n            )\n\n            /**\n             * Set a property on an observed object, calling add to\n             * ensure the property is observed.\n             *\n             * @param {String} key\n             * @param {*} val\n             * @public\n             */\n\n            _.define(\n                objProto,\n                '$set',\n                function $set (key, val) {\n                    this.$add(key, val)\n                    this[key] = val\n                }\n            )\n\n            /**\n             * Deletes a property from an observed object\n             * and emits corresponding event\n             *\n             * @param {String} key\n             * @public\n             */\n\n            _.define(\n                objProto,\n                '$delete',\n                function $delete (key) {\n                    if (!this.hasOwnProperty(key)) return\n                    delete this[key]\n                    var ob = this.__ob__\n                    if (!ob || _.isReserved(key)) {\n                        return\n                    }\n                    if (ob.vms) {\n                        var i = ob.vms.length\n                        while (i--) {\n                            var vm = ob.vms[i]\n                            vm._unproxy(key)\n                            vm._digest()\n                        }\n                    } else {\n                        ob.notify()\n                    }\n                }\n            )\n\n            /***/ },\n        /* 56 */\n        /***/ function(module, exports, __webpack_require__) {\n\n            var _ = __webpack_require__(11)\n            var addClass = _.addClass\n            var removeClass = _.removeClass\n            var transDurationProp = _.transitionProp + 'Duration'\n            var animDurationProp = _.animationProp + 'Duration'\n\n            var queue = []\n            var queued = false\n\n            /**\n             * Push a job into the transition queue, which is to be\n             * executed on next frame.\n             *\n             * @param {Element} el    - target element\n             * @param {Number} dir    - 1: enter, -1: leave\n             * @param {Function} op   - the actual dom operation\n             * @param {String} cls    - the className to remove when the\n             *                          transition is done.\n             * @param {Function} [cb] - user supplied callback.\n             */\n\n            function push (el, dir, op, cls, cb) {\n                queue.push({\n                    el  : el,\n                    dir : dir,\n                    cb  : cb,\n                    cls : cls,\n                    op  : op\n                })\n                if (!queued) {\n                    queued = true\n                    _.nextTick(flush)\n                }\n            }\n\n            /**\n             * Flush the queue, and do one forced reflow before\n             * triggering transitions.\n             */\n\n            function flush () {\n                /* jshint unused: false */\n                var f = document.documentElement.offsetHeight\n                queue.forEach(run)\n                queue = []\n                queued = false\n            }\n\n            /**\n             * Run a transition job.\n             *\n             * @param {Object} job\n             */\n\n            function run (job) {\n\n                var el = job.el\n                var data = el.__v_trans\n                var cls = job.cls\n                var cb = job.cb\n                var op = job.op\n                var transitionType = getTransitionType(el, data, cls)\n\n                if (job.dir > 0) { // ENTER\n                    if (transitionType === 1) {\n                        // trigger transition by removing enter class\n                        removeClass(el, cls)\n                        // only need to listen for transitionend if there's\n                        // a user callback\n                        if (cb) setupTransitionCb(_.transitionEndEvent)\n                    } else if (transitionType === 2) {\n                        // animations are triggered when class is added\n                        // so we just listen for animationend to remove it.\n                        setupTransitionCb(_.animationEndEvent, function () {\n                            removeClass(el, cls)\n                        })\n                    } else {\n                        // no transition applicable\n                        removeClass(el, cls)\n                        if (cb) cb()\n                    }\n                } else { // LEAVE\n                    if (transitionType) {\n                        // leave transitions/animations are both triggered\n                        // by adding the class, just remove it on end event.\n                        var event = transitionType === 1\n                            ? _.transitionEndEvent\n                            : _.animationEndEvent\n                        setupTransitionCb(event, function () {\n                            op()\n                            removeClass(el, cls)\n                        })\n                    } else {\n                        op()\n                        removeClass(el, cls)\n                        if (cb) cb()\n                    }\n                }\n\n                /**\n                 * Set up a transition end callback, store the callback\n                 * on the element's __v_trans data object, so we can\n                 * clean it up if another transition is triggered before\n                 * the callback is fired.\n                 *\n                 * @param {String} event\n                 * @param {Function} [cleanupFn]\n                 */\n\n                function setupTransitionCb (event, cleanupFn) {\n                    data.event = event\n                    var onEnd = data.callback = function transitionCb (e) {\n                        if (e.target === el) {\n                            _.off(el, event, onEnd)\n                            data.event = data.callback = null\n                            if (cleanupFn) cleanupFn()\n                            if (cb) cb()\n                        }\n                    }\n                    _.on(el, event, onEnd)\n                }\n            }\n\n            /**\n             * Get an element's transition type based on the\n             * calculated styles\n             *\n             * @param {Element} el\n             * @param {Object} data\n             * @param {String} className\n             * @return {Number}\n             *         1 - transition\n             *         2 - animation\n             */\n\n            function getTransitionType (el, data, className) {\n                var type = data.cache && data.cache[className]\n                if (type) return type\n                var inlineStyles = el.style\n                var computedStyles = window.getComputedStyle(el)\n                var transDuration =\n                    inlineStyles[transDurationProp] ||\n                    computedStyles[transDurationProp]\n                if (transDuration && transDuration !== '0s') {\n                    type = 1\n                } else {\n                    var animDuration =\n                        inlineStyles[animDurationProp] ||\n                        computedStyles[animDurationProp]\n                    if (animDuration && animDuration !== '0s') {\n                        type = 2\n                    }\n                }\n                if (type) {\n                    if (!data.cache) data.cache = {}\n                    data.cache[className] = type\n                }\n                return type\n            }\n\n            /**\n             * Apply CSS transition to an element.\n             *\n             * @param {Element} el\n             * @param {Number} direction - 1: enter, -1: leave\n             * @param {Function} op - the actual DOM operation\n             * @param {Object} data - target element's transition data\n             */\n\n            module.exports = function (el, direction, op, data, cb) {\n                var prefix = data.id || 'v'\n                var enterClass = prefix + '-enter'\n                var leaveClass = prefix + '-leave'\n                // clean up potential previous unfinished transition\n                if (data.callback) {\n                    _.off(el, data.event, data.callback)\n                    removeClass(el, enterClass)\n                    removeClass(el, leaveClass)\n                    data.event = data.callback = null\n                }\n                if (direction > 0) { // enter\n                    addClass(el, enterClass)\n                    op()\n                    push(el, direction, null, enterClass, cb)\n                } else { // leave\n                    addClass(el, leaveClass)\n                    push(el, direction, op, leaveClass, cb)\n                }\n            }\n\n            /***/ },\n        /* 57 */\n        /***/ function(module, exports, __webpack_require__) {\n\n            /**\n             * Apply JavaScript enter/leave functions.\n             *\n             * @param {Element} el\n             * @param {Number} direction - 1: enter, -1: leave\n             * @param {Function} op - the actual DOM operation\n             * @param {Object} data - target element's transition data\n             * @param {Object} def - transition definition object\n             * @param {Vue} vm - the owner vm of the element\n             * @param {Function} [cb]\n             */\n\n            module.exports = function (el, direction, op, data, def, vm, cb) {\n                // if the element is the root of an instance,\n                // use that instance as the transition function context\n                vm = el.__vue__ || vm\n                if (data.cancel) {\n                    data.cancel()\n                    data.cancel = null\n                }\n                if (direction > 0) { // enter\n                    if (def.beforeEnter) {\n                        def.beforeEnter.call(vm, el)\n                    }\n                    op()\n                    if (def.enter) {\n                        data.cancel = def.enter.call(vm, el, function () {\n                            data.cancel = null\n                            if (cb) cb()\n                        })\n                    } else if (cb) {\n                        cb()\n                    }\n                } else { // leave\n                    if (def.leave) {\n                        data.cancel = def.leave.call(vm, el, function () {\n                            data.cancel = null\n                            op()\n                            if (cb) cb()\n                        })\n                    } else {\n                        op()\n                        if (cb) cb()\n                    }\n                }\n            }\n\n            /***/ },\n        /* 58 */\n        /***/ function(module, exports, __webpack_require__) {\n\n            var _ = __webpack_require__(11)\n\n            module.exports = {\n\n                bind: function () {\n                    var self = this\n                    var el = this.el\n\n                    // check params\n                    // - lazy: update model on \"change\" instead of \"input\"\n                    var lazy = this._checkParam('lazy') != null\n                    // - number: cast value into number when updating model.\n                    var number = this._checkParam('number') != null\n                    // - debounce: debounce the input listener\n                    var debounce = parseInt(this._checkParam('debounce'), 10)\n\n                    // handle composition events.\n                    // http://blog.evanyou.me/2014/01/03/composition-event/\n                    var cpLocked = false\n                    this.cpLock = function () {\n                        cpLocked = true\n                    }\n                    this.cpUnlock = function () {\n                        cpLocked = false\n                        // in IE11 the \"compositionend\" event fires AFTER\n                        // the \"input\" event, so the input handler is blocked\n                        // at the end... have to call it here.\n                        set()\n                    }\n                    _.on(el,'compositionstart', this.cpLock)\n                    _.on(el,'compositionend', this.cpUnlock)\n\n                    // shared setter\n                    function set () {\n                        self.set(\n                            number ? _.toNumber(el.value) : el.value,\n                            true\n                        )\n                    }\n\n                    // if the directive has filters, we need to\n                    // record cursor position and restore it after updating\n                    // the input with the filtered value.\n                    // also force update for type=\"range\" inputs to enable\n                    // \"lock in range\" (see #506)\n                    var hasReadFilter = this.filters && this.filters.read\n                    this.listener = hasReadFilter || el.type === 'range'\n                        ? function textInputListener () {\n                        if (cpLocked) return\n                        var charsOffset\n                        // some HTML5 input types throw error here\n                        try {\n                            // record how many chars from the end of input\n                            // the cursor was at\n                            charsOffset = el.value.length - el.selectionStart\n                        } catch (e) {}\n                        // Fix IE10/11 infinite update cycle\n                        // https://github.com/yyx990803/vue/issues/592\n                        /* istanbul ignore if */\n                        if (charsOffset < 0) {\n                            return\n                        }\n                        set()\n                        _.nextTick(function () {\n                            // force a value update, because in\n                            // certain cases the write filters output the\n                            // same result for different input values, and\n                            // the Observer set events won't be triggered.\n                            var newVal = self._watcher.value\n                            self.update(newVal)\n                            if (charsOffset != null) {\n                                var cursorPos =\n                                    _.toString(newVal).length - charsOffset\n                                el.setSelectionRange(cursorPos, cursorPos)\n                            }\n                        })\n                    }\n                        : function textInputListener () {\n                        if (cpLocked) return\n                        set()\n                    }\n\n                    if (debounce) {\n                        this.listener = _.debounce(this.listener, debounce)\n                    }\n                    this.event = lazy ? 'change' : 'input'\n                    // Support jQuery events, since jQuery.trigger() doesn't\n                    // trigger native events in some cases and some plugins\n                    // rely on $.trigger()\n                    // \n                    // We want to make sure if a listener is attached using\n                    // jQuery, it is also removed with jQuery, that's why\n                    // we do the check for each directive instance and\n                    // store that check result on itself. This also allows\n                    // easier test coverage control by unsetting the global\n                    // jQuery variable in tests.\n                    this.hasjQuery = typeof jQuery === 'function'\n                    if (this.hasjQuery) {\n                        jQuery(el).on(this.event, this.listener)\n                    } else {\n                        _.on(el, this.event, this.listener)\n                    }\n\n                    // IE9 doesn't fire input event on backspace/del/cut\n                    if (!lazy && _.isIE9) {\n                        this.onCut = function () {\n                            _.nextTick(self.listener)\n                        }\n                        this.onDel = function (e) {\n                            if (e.keyCode === 46 || e.keyCode === 8) {\n                                self.listener()\n                            }\n                        }\n                        _.on(el, 'cut', this.onCut)\n                        _.on(el, 'keyup', this.onDel)\n                    }\n\n                    // set initial value if present\n                    if (\n                        el.hasAttribute('value') ||\n                        (el.tagName === 'TEXTAREA' && el.value.trim())\n                    ) {\n                        this._initValue = number\n                            ? _.toNumber(el.value)\n                            : el.value\n                    }\n                },\n\n                update: function (value) {\n                    this.el.value = _.toString(value)\n                },\n\n                unbind: function () {\n                    var el = this.el\n                    if (this.hasjQuery) {\n                        jQuery(el).off(this.event, this.listener)\n                    } else {\n                        _.off(el, this.event, this.listener)\n                    }\n                    _.off(el,'compositionstart', this.cpLock)\n                    _.off(el,'compositionend', this.cpUnlock)\n                    if (this.onCut) {\n                        _.off(el,'cut', this.onCut)\n                        _.off(el,'keyup', this.onDel)\n                    }\n                }\n\n            }\n\n            /***/ },\n        /* 59 */\n        /***/ function(module, exports, __webpack_require__) {\n\n            var _ = __webpack_require__(11)\n\n            module.exports = {\n\n                bind: function () {\n                    var self = this\n                    var el = this.el\n                    this.listener = function () {\n                        self.set(el.value, true)\n                    }\n                    _.on(el, 'change', this.listener)\n                    if (el.checked) {\n                        this._initValue = el.value\n                    }\n                },\n\n                update: function (value) {\n                    /* jshint eqeqeq: false */\n                    this.el.checked = value == this.el.value\n                },\n\n                unbind: function () {\n                    _.off(this.el, 'change', this.listener)\n                }\n\n            }\n\n            /***/ },\n        /* 60 */\n        /***/ function(module, exports, __webpack_require__) {\n\n            var _ = __webpack_require__(11)\n            var Watcher = __webpack_require__(25)\n            var dirParser = __webpack_require__(21)\n\n            module.exports = {\n\n                bind: function () {\n                    var self = this\n                    var el = this.el\n                    // check options param\n                    var optionsParam = this._checkParam('options')\n                    if (optionsParam) {\n                        initOptions.call(this, optionsParam)\n                    }\n                    this.number = this._checkParam('number') != null\n                    this.multiple = el.hasAttribute('multiple')\n                    this.listener = function () {\n                        var value = self.multiple\n                            ? getMultiValue(el)\n                            : el.value\n                        value = self.number\n                            ? _.isArray(value)\n                            ? value.map(_.toNumber)\n                            : _.toNumber(value)\n                            : value\n                        self.set(value, true)\n                    }\n                    _.on(el, 'change', this.listener)\n                    checkInitialValue.call(this)\n                },\n\n                update: function (value) {\n                    /* jshint eqeqeq: false */\n                    var el = this.el\n                    el.selectedIndex = -1\n                    var multi = this.multiple && _.isArray(value)\n                    var options = el.options\n                    var i = options.length\n                    var option\n                    while (i--) {\n                        option = options[i]\n                        option.selected = multi\n                            ? indexOf(value, option.value) > -1\n                            : value == option.value\n                    }\n                },\n\n                unbind: function () {\n                    _.off(this.el, 'change', this.listener)\n                    if (this.optionWatcher) {\n                        this.optionWatcher.teardown()\n                    }\n                }\n\n            }\n\n            /**\n             * Initialize the option list from the param.\n             *\n             * @param {String} expression\n             */\n\n            function initOptions (expression) {\n                var self = this\n                var descriptor = dirParser.parse(expression)[0]\n                function optionUpdateWatcher (value) {\n                    if (_.isArray(value)) {\n                        self.el.innerHTML = ''\n                        buildOptions(self.el, value)\n                        if (self._watcher) {\n                            self.update(self._watcher.value)\n                        }\n                    } else {\n                        _.warn('Invalid options value for v-model: ' + value)\n                    }\n                }\n                this.optionWatcher = new Watcher(\n                    this.vm,\n                    descriptor.expression,\n                    optionUpdateWatcher,\n                    {\n                        deep: true,\n                        filters: _.resolveFilters(this.vm, descriptor.filters)\n                    }\n                )\n                // update with initial value\n                optionUpdateWatcher(this.optionWatcher.value)\n            }\n\n            /**\n             * Build up option elements. IE9 doesn't create options\n             * when setting innerHTML on <select> elements, so we have\n             * to use DOM API here.\n             *\n             * @param {Element} parent - a <select> or an <optgroup>\n             * @param {Array} options\n             */\n\n            function buildOptions (parent, options) {\n                var op, el\n                for (var i = 0, l = options.length; i < l; i++) {\n                    op = options[i]\n                    if (!op.options) {\n                        el = document.createElement('option')\n                        if (typeof op === 'string') {\n                            el.text = el.value = op\n                        } else {\n                            el.text = op.text\n                            el.value = op.value\n                        }\n                    } else {\n                        el = document.createElement('optgroup')\n                        el.label = op.label\n                        buildOptions(el, op.options)\n                    }\n                    parent.appendChild(el)\n                }\n            }\n\n            /**\n             * Check the initial value for selected options.\n             */\n\n            function checkInitialValue () {\n                var initValue\n                var options = this.el.options\n                for (var i = 0, l = options.length; i < l; i++) {\n                    if (options[i].hasAttribute('selected')) {\n                        if (this.multiple) {\n                            (initValue || (initValue = []))\n                                .push(options[i].value)\n                        } else {\n                            initValue = options[i].value\n                        }\n                    }\n                }\n                if (typeof initValue !== 'undefined') {\n                    this._initValue = this.number\n                        ? _.toNumber(initValue)\n                        : initValue\n                }\n            }\n\n            /**\n             * Helper to extract a value array for select[multiple]\n             *\n             * @param {SelectElement} el\n             * @return {Array}\n             */\n\n            function getMultiValue (el) {\n                return Array.prototype.filter\n                    .call(el.options, filterSelected)\n                    .map(getOptionValue)\n            }\n\n            function filterSelected (op) {\n                return op.selected\n            }\n\n            function getOptionValue (op) {\n                return op.value || op.text\n            }\n\n            /**\n             * Native Array.indexOf uses strict equal, but in this\n             * case we need to match string/numbers with soft equal.\n             *\n             * @param {Array} arr\n             * @param {*} val\n             */\n\n            function indexOf (arr, val) {\n                /* jshint eqeqeq: false */\n                var i = arr.length\n                while (i--) {\n                    if (arr[i] == val) return i\n                }\n                return -1\n            }\n\n            /***/ },\n        /* 61 */\n        /***/ function(module, exports, __webpack_require__) {\n\n            var _ = __webpack_require__(11)\n\n            module.exports = {\n\n                bind: function () {\n                    var self = this\n                    var el = this.el\n                    this.listener = function () {\n                        self.set(el.checked, true)\n                    }\n                    _.on(el, 'change', this.listener)\n                    if (el.checked) {\n                        this._initValue = el.checked\n                    }\n                },\n\n                update: function (value) {\n                    this.el.checked = !!value\n                },\n\n                unbind: function () {\n                    _.off(this.el, 'change', this.listener)\n                }\n\n            }\n\n            /***/ }\n        /******/ ])\n});\n;","/******/ (function(modules) { // webpackBootstrap\n    /******/ \t// The module cache\n    /******/ \tvar installedModules = {};\n\n    /******/ \t// The require function\n    /******/ \tfunction __webpack_require__(moduleId) {\n\n        /******/ \t\t// Check if module is in cache\n        /******/ \t\tif(installedModules[moduleId])\n        /******/ \t\t\treturn installedModules[moduleId].exports;\n\n        /******/ \t\t// Create a new module (and put it into the cache)\n        /******/ \t\tvar module = installedModules[moduleId] = {\n            /******/ \t\t\texports: {},\n            /******/ \t\t\tid: moduleId,\n            /******/ \t\t\tloaded: false\n            /******/ \t\t};\n\n        /******/ \t\t// Execute the module function\n        /******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n        /******/ \t\t// Flag the module as loaded\n        /******/ \t\tmodule.loaded = true;\n\n        /******/ \t\t// Return the exports of the module\n        /******/ \t\treturn module.exports;\n        /******/ \t}\n\n\n    /******/ \t// expose the modules object (__webpack_modules__)\n    /******/ \t__webpack_require__.m = modules;\n\n    /******/ \t// expose the module cache\n    /******/ \t__webpack_require__.c = installedModules;\n\n    /******/ \t// __webpack_public_path__\n    /******/ \t__webpack_require__.p = \"\";\n\n    /******/ \t// Load entry module and return exports\n    /******/ \treturn __webpack_require__(0);\n    /******/ })\n    /************************************************************************/\n    /******/ ([\n    /* 0 */\n    /***/ function(module, exports, __webpack_require__) {\n\n        /**\n         * Install plugin.\n         */\n\n        function install (Vue) {\n            Vue.url = __webpack_require__(1)(Vue);\n            Vue.http = __webpack_require__(3)(Vue);\n            Vue.resource = __webpack_require__(4)(Vue);\n        }\n\n        if (window.Vue) {\n            Vue.use(install);\n        }\n\n        module.exports = install;\n\n\n        /***/ },\n    /* 1 */\n    /***/ function(module, exports, __webpack_require__) {\n\n        module.exports = function (Vue) {\n\n            var _ = __webpack_require__(2)(Vue);\n\n            /**\n             * Url provides URL templating.\n             *\n             * @param {String} url\n             * @param {Object} params\n             */\n\n            function Url (url, params) {\n\n                var urlParams = {}, queryParams = {}, options = url, query;\n\n                if (!_.isPlainObject(options)) {\n                    options = {url: url, params: params};\n                }\n\n                options = _.extend({}, Url.options, _.options('url', this, options));\n\n                url = options.url.replace(/:([a-z]\\w*)/gi, function (match, name) {\n\n                    if (options.params[name]) {\n                        urlParams[name] = true;\n                        return encodeUriSegment(options.params[name]);\n                    }\n\n                    return '';\n                });\n\n                if (!url.match(/^(https?:)?\\//) && options.root) {\n                    url = options.root + '/' + url;\n                }\n\n                url = url.replace(/([^:])[\\/]{2,}/g, '$1/');\n                url = url.replace(/(\\w+)\\/+$/, '$1');\n\n                _.each(options.params, function (value, key) {\n                    if (!urlParams[key]) {\n                        queryParams[key] = value;\n                    }\n                });\n\n                query = Url.params(queryParams);\n\n                if (query) {\n                    url += (url.indexOf('?') == -1 ? '?' : '&') + query;\n                }\n\n                return url;\n            }\n\n            /**\n             * Url options.\n             */\n\n            Url.options = {\n                url: '',\n                root: '',\n                params: {}\n            };\n\n            /**\n             * Encodes a Url parameter string.\n             *\n             * @param {Object} obj\n             */\n\n            Url.params = function (obj) {\n\n                var params = [];\n\n                params.add = function (key, value) {\n\n                    if (_.isFunction (value)) {\n                        value = value();\n                    }\n\n                    if (value === null) {\n                        value = '';\n                    }\n\n                    this.push(encodeUriSegment(key) + '=' + encodeUriSegment(value));\n                };\n\n                serialize(params, obj);\n\n                return params.join('&');\n            };\n\n            /**\n             * Parse a URL and return its components.\n             *\n             * @param {String} url\n             */\n\n            Url.parse = function (url) {\n\n                var pattern = new RegExp(\"^(?:([^:/?#]+):)?(?://([^/?#]*))?([^?#]*)(?:\\\\?([^#]*))?(?:#(.*))?\"),\n                    matches = url.match(pattern);\n\n                return {\n                    url: url,\n                    scheme: matches[1] || '',\n                    host: matches[2] || '',\n                    path: matches[3] || '',\n                    query: matches[4] || '',\n                    fragment: matches[5] || ''\n                };\n            };\n\n            function serialize (params, obj, scope) {\n\n                var array = _.isArray(obj), plain = _.isPlainObject(obj), hash;\n\n                _.each(obj, function (value, key) {\n\n                    hash = _.isObject(value) || _.isArray(value);\n\n                    if (scope) {\n                        key = scope + '[' + (plain || hash ? key : '') + ']';\n                    }\n\n                    if (!scope && array) {\n                        params.add(value.name, value.value);\n                    } else if (hash) {\n                        serialize(params, value, key);\n                    } else {\n                        params.add(key, value);\n                    }\n                });\n            }\n\n            function encodeUriSegment (value) {\n\n                return encodeUriQuery(value, true).\n                    replace(/%26/gi, '&').\n                    replace(/%3D/gi, '=').\n                    replace(/%2B/gi, '+');\n            }\n\n            function encodeUriQuery (value, spaces) {\n\n                return encodeURIComponent(value).\n                    replace(/%40/gi, '@').\n                    replace(/%3A/gi, ':').\n                    replace(/%24/g, '$').\n                    replace(/%2C/gi, ',').\n                    replace(/%20/g, (spaces ? '%20' : '+'));\n            }\n\n            Object.defineProperty(Vue.prototype, '$url', {\n\n                get: function () {\n                    return _.extend(Url.bind(this), Url);\n                }\n\n            });\n\n            return Url;\n        };\n\n\n        /***/ },\n    /* 2 */\n    /***/ function(module, exports, __webpack_require__) {\n\n        /**\n         * Utility functions.\n         */\n\n        module.exports = function (Vue) {\n\n            var _ = Vue.util.extend({}, Vue.util);\n\n            _.options = function (key, obj, options) {\n\n                var opts = obj.$options || {};\n\n                return _.extend({},\n                    opts[key],\n                    options\n                );\n            };\n\n            _.each = function (obj, iterator) {\n\n                var i, key;\n\n                if (typeof obj.length == 'number') {\n                    for (i = 0; i < obj.length; i++) {\n                        iterator.call(obj[i], obj[i], i);\n                    }\n                } else if (_.isObject(obj)) {\n                    for (key in obj) {\n                        if (obj.hasOwnProperty(key)) {\n                            iterator.call(obj[key], obj[key], key);\n                        }\n                    }\n                }\n\n                return obj;\n            };\n\n            _.extend = function (target) {\n\n                var array = [], args = array.slice.call(arguments, 1), deep;\n\n                if (typeof target == 'boolean') {\n                    deep = target;\n                    target = args.shift();\n                }\n\n                args.forEach(function (arg) {\n                    extend(target, arg, deep);\n                });\n\n                return target;\n            };\n\n            function extend (target, source, deep) {\n                for (var key in source) {\n                    if (deep && (_.isPlainObject(source[key]) || _.isArray(source[key]))) {\n                        if (_.isPlainObject(source[key]) && !_.isPlainObject(target[key])) {\n                            target[key] = {};\n                        }\n                        if (_.isArray(source[key]) && !_.isArray(target[key])) {\n                            target[key] = [];\n                        }\n                        extend(target[key], source[key], deep);\n                    } else if (source[key] !== undefined) {\n                        target[key] = source[key];\n                    }\n                }\n            }\n\n            _.isFunction = function (obj) {\n                return obj && typeof obj === 'function';\n            };\n\n            /**\n             * Promise polyfill (https://gist.github.com/briancavalier/814313)\n             */\n\n            _.Promise = window.Promise;\n\n            if (!_.Promise) {\n\n                _.Promise = function (executor) {\n                    executor(this.resolve.bind(this), this.reject.bind(this));\n                    this._thens = [];\n                };\n\n                _.Promise.prototype = {\n\n                    then: function (onResolve, onReject, onProgress) {\n                        this._thens.push({resolve: onResolve, reject: onReject, progress: onProgress});\n                    },\n\n                    'catch': function (onReject) {\n                        this._thens.push({reject: onReject});\n                    },\n\n                    resolve: function (value) {\n                        this._complete('resolve', value);\n                    },\n\n                    reject: function (reason) {\n                        this._complete('reject', reason);\n                    },\n\n                    progress: function (status) {\n\n                        var i = 0, aThen;\n\n                        while (aThen = this._thens[i++]) {\n                            aThen.progress && aThen.progress(status);\n                        }\n                    },\n\n                    _complete: function (which, arg) {\n\n                        this.then = which === 'resolve' ?\n                            function (resolve, reject) { resolve && resolve(arg); } :\n                            function (resolve, reject) { reject && reject(arg); };\n\n                        this.resolve = this.reject = this.progress =\n                            function () { throw new Error('Promise already completed.'); };\n\n                        var aThen, i = 0;\n\n                        while (aThen = this._thens[i++]) {\n                            aThen[which] && aThen[which](arg);\n                        }\n\n                        delete this._thens;\n                    }\n                };\n            }\n\n            return _;\n        };\n\n\n        /***/ },\n    /* 3 */\n    /***/ function(module, exports, __webpack_require__) {\n\n        module.exports = function (Vue) {\n\n            var _ = __webpack_require__(2)(Vue);\n            var jsonType = { 'Content-Type': 'application/json;charset=utf-8' };\n\n            /**\n             * Http provides a service for sending XMLHttpRequests.\n             */\n\n            function Http (url, options) {\n\n                var self = this, headers, promise;\n\n                options = options || {};\n\n                if (_.isPlainObject(url)) {\n                    options = url;\n                    url = '';\n                }\n\n                headers = _.extend({},\n                    Http.headers.common,\n                    Http.headers[options.method.toLowerCase()]\n                );\n\n                options = _.extend(true, {url: url, headers: headers},\n                    Http.options, _.options('http', this, options)\n                );\n\n                if (_.isObject(options.data) && /FormData/i.test(options.data.toString())) {\n                    delete options.headers['Content-Type'];\n                }\n\n                promise = new _.Promise((options.method.toLowerCase() == 'jsonp' ? jsonp : xhr).bind(this, (this.$url || Vue.url), options));\n\n                _.extend(promise, {\n\n                    success: function (onSuccess) {\n\n                        this.then(function (request) {\n                            onSuccess.apply(self, parseReq(request));\n                        }, function () {});\n\n                        return this;\n                    },\n\n                    error: function (onError) {\n\n                        this.catch(function (request) {\n                            onError.apply(self, parseReq(request));\n                        });\n\n                        return this;\n                    },\n\n                    always: function (onAlways) {\n\n                        var cb = function (request) {\n                            onAlways.apply(self, parseReq(request));\n                        };\n\n                        this.then(cb, cb);\n\n                        return this;\n                    }\n\n                });\n\n                if (options.success) {\n                    promise.success(options.success);\n                }\n\n                if (options.error) {\n                    promise.error(options.error);\n                }\n\n                return promise;\n            }\n\n            function xhr(url, options, resolve, reject) {\n\n                var request = new XMLHttpRequest();\n\n                if (_.isFunction(options.beforeSend)) {\n                    options.beforeSend(request, options);\n                }\n\n                if (options.emulateHTTP && /^(PUT|PATCH|DELETE)$/i.test(options.method)) {\n                    options.headers['X-HTTP-Method-Override'] = options.method;\n                    options.method = 'POST';\n                }\n\n                if (options.emulateJSON && _.isPlainObject(options.data)) {\n                    options.headers['Content-Type'] = 'application/x-www-form-urlencoded';\n                    options.data = Vue.url.params(options.data);\n                }\n\n                if (_.isPlainObject(options.data)) {\n                    options.data = JSON.stringify(options.data);\n                }\n\n                request.open(options.method, url(options), true);\n\n                _.each(options.headers, function (value, header) {\n                    request.setRequestHeader(header, value);\n                });\n\n                request.onreadystatechange = function () {\n\n                    if (this.readyState === 4) {\n\n                        if (this.status >= 200 && this.status < 300) {\n                            resolve(this);\n                        } else {\n                            reject(this);\n                        }\n                    }\n                };\n\n                request.send(options.data);\n            }\n\n            function jsonp(url, options, resolve, reject) {\n\n                var callback = '_jsonp' + Math.random().toString(36).substr(2), script, result;\n\n                _.extend(options.params, options.data);\n                options.params[options.jsonp] = callback;\n\n                if (_.isFunction(options.beforeSend)) {\n                    options.beforeSend({}, options);\n                }\n\n                script = document.createElement('script');\n                script.src = url(options.url, options.params);\n                script.type = 'text/javascript';\n                script.async = true;\n\n                window[callback] = function (data) {\n                    result = data;\n                };\n\n                var handler = function (event) {\n\n                    delete window[callback];\n                    document.body.removeChild(script);\n\n                    if (event.type === 'load' && !result) {\n                        event.type = 'error';\n                    }\n\n                    var text = result ? result : event.type, status = event.type === 'error' ? 404 : 200;\n\n                    (status === 200 ? resolve : reject)({ responseText: text, status: status });\n                };\n\n                script.onload = handler;\n                script.onerror = handler;\n\n                document.body.appendChild(script);\n            }\n\n            function parseReq(request) {\n\n                var result;\n\n                try {\n                    result = JSON.parse(request.responseText);\n                } catch (e) {\n                    result = request.responseText;\n                }\n\n                return [result, request.status, request];\n            }\n\n            Http.options = {\n                method: 'GET',\n                params: {},\n                data: '',\n                jsonp: 'callback',\n                beforeSend: null,\n                emulateHTTP: false,\n                emulateJSON: false,\n            };\n\n            Http.headers = {\n                put: jsonType,\n                post: jsonType,\n                patch: jsonType,\n                delete: jsonType,\n                common: { 'Accept': 'application/json, text/plain, */*' }\n            };\n\n            ['get', 'put', 'post', 'patch', 'delete', 'jsonp'].forEach(function (method) {\n\n                Http[method] = function (url, data, success, options) {\n\n                    if (_.isFunction(data)) {\n                        options = success;\n                        success = data;\n                        data = undefined;\n                    }\n\n                    return this(url, _.extend({method: method, data: data, success: success}, options));\n                };\n            });\n\n            Object.defineProperty(Vue.prototype, '$http', {\n\n                get: function () {\n                    return _.extend(Http.bind(this), Http);\n                }\n\n            });\n\n            return Http;\n        };\n\n\n        /***/ },\n    /* 4 */\n    /***/ function(module, exports, __webpack_require__) {\n\n        module.exports = function (Vue) {\n\n            var _ = __webpack_require__(2)(Vue);\n\n            /**\n             * Resource provides interaction support with RESTful services.\n             */\n\n            function Resource (url, params, actions) {\n\n                var self = this, resource = {};\n\n                actions = _.extend({},\n                    Resource.actions,\n                    actions\n                );\n\n                _.each(actions, function (action, name) {\n\n                    action = _.extend(true, {url: url, params: params || {}}, action);\n\n                    resource[name] = function () {\n                        return (self.$http || Vue.http)(opts(action, arguments));\n                    };\n                });\n\n                return resource;\n            }\n\n            function opts (action, args) {\n\n                var options = _.extend({}, action), params = {}, data, success, error;\n\n                switch (args.length) {\n\n                    case 4:\n\n                        error = args[3];\n                        success = args[2];\n\n                    case 3:\n                    case 2:\n\n                        if (_.isFunction (args[1])) {\n\n                            if (_.isFunction (args[0])) {\n\n                                success = args[0];\n                                error = args[1];\n\n                                break;\n                            }\n\n                            success = args[1];\n                            error = args[2];\n\n                        } else {\n\n                            params = args[0];\n                            data = args[1];\n                            success = args[2];\n\n                            break;\n                        }\n\n                    case 1:\n\n                        if (_.isFunction (args[0])) {\n                            success = args[0];\n                        } else if (/^(POST|PUT|PATCH)$/i.test(options.method)) {\n                            data = args[0];\n                        } else {\n                            params = args[0];\n                        }\n\n                        break;\n\n                    case 0:\n\n                        break;\n\n                    default:\n\n                        throw 'Expected up to 4 arguments [params, data, success, error], got ' + args.length + ' arguments';\n                }\n\n                options.url = action.url;\n                options.data = data;\n                options.params = _.extend({}, action.params, params);\n\n                if (success) {\n                    options.success = success;\n                }\n\n                if (error) {\n                    options.error = error;\n                }\n\n                return options;\n            }\n\n            Resource.actions = {\n\n                get: {method: 'GET'},\n                save: {method: 'POST'},\n                query: {method: 'GET'},\n                remove: {method: 'DELETE'},\n                delete: {method: 'DELETE'}\n\n            };\n\n            Object.defineProperty(Vue.prototype, '$resource', {\n\n                get: function () {\n                    return Resource.bind(this);\n                }\n\n            });\n\n            return Resource;\n        };\n\n\n        /***/ }\n    /******/ ]);","!function(e){if(\"object\"==typeof exports&&\"undefined\"!=typeof module)module.exports=e();else if(\"function\"==typeof define&&define.amd)define([],e);else{var f;\"undefined\"!=typeof window?f=window:\"undefined\"!=typeof global?f=global:\"undefined\"!=typeof self&&(f=self),f.io=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error(\"Cannot find module '\"+o+\"'\")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){\n\nmodule.exports = _dereq_('./lib/');\n\n},{\"./lib/\":2}],2:[function(_dereq_,module,exports){\n\n/**\n * Module dependencies.\n */\n\nvar url = _dereq_('./url');\nvar parser = _dereq_('socket.io-parser');\nvar Manager = _dereq_('./manager');\nvar debug = _dereq_('debug')('socket.io-client');\n\n/**\n * Module exports.\n */\n\nmodule.exports = exports = lookup;\n\n/**\n * Managers cache.\n */\n\nvar cache = exports.managers = {};\n\n/**\n * Looks up an existing `Manager` for multiplexing.\n * If the user summons:\n *\n *   `io('http://localhost/a');`\n *   `io('http://localhost/b');`\n *\n * We reuse the existing instance based on same scheme/port/host,\n * and we initialize sockets for each namespace.\n *\n * @api public\n */\n\nfunction lookup(uri, opts) {\n  if (typeof uri == 'object') {\n    opts = uri;\n    uri = undefined;\n  }\n\n  opts = opts || {};\n\n  var parsed = url(uri);\n  var source = parsed.source;\n  var id = parsed.id;\n  var io;\n\n  if (opts.forceNew || opts['force new connection'] || false === opts.multiplex) {\n    debug('ignoring socket cache for %s', source);\n    io = Manager(source, opts);\n  } else {\n    if (!cache[id]) {\n      debug('new io instance for %s', source);\n      cache[id] = Manager(source, opts);\n    }\n    io = cache[id];\n  }\n\n  return io.socket(parsed.path);\n}\n\n/**\n * Protocol version.\n *\n * @api public\n */\n\nexports.protocol = parser.protocol;\n\n/**\n * `connect`.\n *\n * @param {String} uri\n * @api public\n */\n\nexports.connect = lookup;\n\n/**\n * Expose constructors for standalone build.\n *\n * @api public\n */\n\nexports.Manager = _dereq_('./manager');\nexports.Socket = _dereq_('./socket');\n\n},{\"./manager\":3,\"./socket\":5,\"./url\":6,\"debug\":10,\"socket.io-parser\":46}],3:[function(_dereq_,module,exports){\n\n/**\n * Module dependencies.\n */\n\nvar url = _dereq_('./url');\nvar eio = _dereq_('engine.io-client');\nvar Socket = _dereq_('./socket');\nvar Emitter = _dereq_('component-emitter');\nvar parser = _dereq_('socket.io-parser');\nvar on = _dereq_('./on');\nvar bind = _dereq_('component-bind');\nvar object = _dereq_('object-component');\nvar debug = _dereq_('debug')('socket.io-client:manager');\nvar indexOf = _dereq_('indexof');\nvar Backoff = _dereq_('backo2');\n\n/**\n * Module exports\n */\n\nmodule.exports = Manager;\n\n/**\n * `Manager` constructor.\n *\n * @param {String} engine instance or engine uri/opts\n * @param {Object} options\n * @api public\n */\n\nfunction Manager(uri, opts){\n  if (!(this instanceof Manager)) return new Manager(uri, opts);\n  if (uri && ('object' == typeof uri)) {\n    opts = uri;\n    uri = undefined;\n  }\n  opts = opts || {};\n\n  opts.path = opts.path || '/socket.io';\n  this.nsps = {};\n  this.subs = [];\n  this.opts = opts;\n  this.reconnection(opts.reconnection !== false);\n  this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);\n  this.reconnectionDelay(opts.reconnectionDelay || 1000);\n  this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);\n  this.randomizationFactor(opts.randomizationFactor || 0.5);\n  this.backoff = new Backoff({\n    min: this.reconnectionDelay(),\n    max: this.reconnectionDelayMax(),\n    jitter: this.randomizationFactor()\n  });\n  this.timeout(null == opts.timeout ? 20000 : opts.timeout);\n  this.readyState = 'closed';\n  this.uri = uri;\n  this.connected = [];\n  this.encoding = false;\n  this.packetBuffer = [];\n  this.encoder = new parser.Encoder();\n  this.decoder = new parser.Decoder();\n  this.autoConnect = opts.autoConnect !== false;\n  if (this.autoConnect) this.open();\n}\n\n/**\n * Propagate given event to sockets and emit on `this`\n *\n * @api private\n */\n\nManager.prototype.emitAll = function() {\n  this.emit.apply(this, arguments);\n  for (var nsp in this.nsps) {\n    this.nsps[nsp].emit.apply(this.nsps[nsp], arguments);\n  }\n};\n\n/**\n * Update `socket.id` of all sockets\n *\n * @api private\n */\n\nManager.prototype.updateSocketIds = function(){\n  for (var nsp in this.nsps) {\n    this.nsps[nsp].id = this.engine.id;\n  }\n};\n\n/**\n * Mix in `Emitter`.\n */\n\nEmitter(Manager.prototype);\n\n/**\n * Sets the `reconnection` config.\n *\n * @param {Boolean} true/false if it should automatically reconnect\n * @return {Manager} self or value\n * @api public\n */\n\nManager.prototype.reconnection = function(v){\n  if (!arguments.length) return this._reconnection;\n  this._reconnection = !!v;\n  return this;\n};\n\n/**\n * Sets the reconnection attempts config.\n *\n * @param {Number} max reconnection attempts before giving up\n * @return {Manager} self or value\n * @api public\n */\n\nManager.prototype.reconnectionAttempts = function(v){\n  if (!arguments.length) return this._reconnectionAttempts;\n  this._reconnectionAttempts = v;\n  return this;\n};\n\n/**\n * Sets the delay between reconnections.\n *\n * @param {Number} delay\n * @return {Manager} self or value\n * @api public\n */\n\nManager.prototype.reconnectionDelay = function(v){\n  if (!arguments.length) return this._reconnectionDelay;\n  this._reconnectionDelay = v;\n  this.backoff && this.backoff.setMin(v);\n  return this;\n};\n\nManager.prototype.randomizationFactor = function(v){\n  if (!arguments.length) return this._randomizationFactor;\n  this._randomizationFactor = v;\n  this.backoff && this.backoff.setJitter(v);\n  return this;\n};\n\n/**\n * Sets the maximum delay between reconnections.\n *\n * @param {Number} delay\n * @return {Manager} self or value\n * @api public\n */\n\nManager.prototype.reconnectionDelayMax = function(v){\n  if (!arguments.length) return this._reconnectionDelayMax;\n  this._reconnectionDelayMax = v;\n  this.backoff && this.backoff.setMax(v);\n  return this;\n};\n\n/**\n * Sets the connection timeout. `false` to disable\n *\n * @return {Manager} self or value\n * @api public\n */\n\nManager.prototype.timeout = function(v){\n  if (!arguments.length) return this._timeout;\n  this._timeout = v;\n  return this;\n};\n\n/**\n * Starts trying to reconnect if reconnection is enabled and we have not\n * started reconnecting yet\n *\n * @api private\n */\n\nManager.prototype.maybeReconnectOnOpen = function() {\n  // Only try to reconnect if it's the first time we're connecting\n  if (!this.reconnecting && this._reconnection && this.backoff.attempts === 0) {\n    // keeps reconnection from firing twice for the same reconnection loop\n    this.reconnect();\n  }\n};\n\n\n/**\n * Sets the current transport `socket`.\n *\n * @param {Function} optional, callback\n * @return {Manager} self\n * @api public\n */\n\nManager.prototype.open =\nManager.prototype.connect = function(fn){\n  debug('readyState %s', this.readyState);\n  if (~this.readyState.indexOf('open')) return this;\n\n  debug('opening %s', this.uri);\n  this.engine = eio(this.uri, this.opts);\n  var socket = this.engine;\n  var self = this;\n  this.readyState = 'opening';\n  this.skipReconnect = false;\n\n  // emit `open`\n  var openSub = on(socket, 'open', function() {\n    self.onopen();\n    fn && fn();\n  });\n\n  // emit `connect_error`\n  var errorSub = on(socket, 'error', function(data){\n    debug('connect_error');\n    self.cleanup();\n    self.readyState = 'closed';\n    self.emitAll('connect_error', data);\n    if (fn) {\n      var err = new Error('Connection error');\n      err.data = data;\n      fn(err);\n    } else {\n      // Only do this if there is no fn to handle the error\n      self.maybeReconnectOnOpen();\n    }\n  });\n\n  // emit `connect_timeout`\n  if (false !== this._timeout) {\n    var timeout = this._timeout;\n    debug('connect attempt will timeout after %d', timeout);\n\n    // set timer\n    var timer = setTimeout(function(){\n      debug('connect attempt timed out after %d', timeout);\n      openSub.destroy();\n      socket.close();\n      socket.emit('error', 'timeout');\n      self.emitAll('connect_timeout', timeout);\n    }, timeout);\n\n    this.subs.push({\n      destroy: function(){\n        clearTimeout(timer);\n      }\n    });\n  }\n\n  this.subs.push(openSub);\n  this.subs.push(errorSub);\n\n  return this;\n};\n\n/**\n * Called upon transport open.\n *\n * @api private\n */\n\nManager.prototype.onopen = function(){\n  debug('open');\n\n  // clear old subs\n  this.cleanup();\n\n  // mark as open\n  this.readyState = 'open';\n  this.emit('open');\n\n  // add new subs\n  var socket = this.engine;\n  this.subs.push(on(socket, 'data', bind(this, 'ondata')));\n  this.subs.push(on(this.decoder, 'decoded', bind(this, 'ondecoded')));\n  this.subs.push(on(socket, 'error', bind(this, 'onerror')));\n  this.subs.push(on(socket, 'close', bind(this, 'onclose')));\n};\n\n/**\n * Called with data.\n *\n * @api private\n */\n\nManager.prototype.ondata = function(data){\n  this.decoder.add(data);\n};\n\n/**\n * Called when parser fully decodes a packet.\n *\n * @api private\n */\n\nManager.prototype.ondecoded = function(packet) {\n  this.emit('packet', packet);\n};\n\n/**\n * Called upon socket error.\n *\n * @api private\n */\n\nManager.prototype.onerror = function(err){\n  debug('error', err);\n  this.emitAll('error', err);\n};\n\n/**\n * Creates a new socket for the given `nsp`.\n *\n * @return {Socket}\n * @api public\n */\n\nManager.prototype.socket = function(nsp){\n  var socket = this.nsps[nsp];\n  if (!socket) {\n    socket = new Socket(this, nsp);\n    this.nsps[nsp] = socket;\n    var self = this;\n    socket.on('connect', function(){\n      socket.id = self.engine.id;\n      if (!~indexOf(self.connected, socket)) {\n        self.connected.push(socket);\n      }\n    });\n  }\n  return socket;\n};\n\n/**\n * Called upon a socket close.\n *\n * @param {Socket} socket\n */\n\nManager.prototype.destroy = function(socket){\n  var index = indexOf(this.connected, socket);\n  if (~index) this.connected.splice(index, 1);\n  if (this.connected.length) return;\n\n  this.close();\n};\n\n/**\n * Writes a packet.\n *\n * @param {Object} packet\n * @api private\n */\n\nManager.prototype.packet = function(packet){\n  debug('writing packet %j', packet);\n  var self = this;\n\n  if (!self.encoding) {\n    // encode, then write to engine with result\n    self.encoding = true;\n    this.encoder.encode(packet, function(encodedPackets) {\n      for (var i = 0; i < encodedPackets.length; i++) {\n        self.engine.write(encodedPackets[i]);\n      }\n      self.encoding = false;\n      self.processPacketQueue();\n    });\n  } else { // add packet to the queue\n    self.packetBuffer.push(packet);\n  }\n};\n\n/**\n * If packet buffer is non-empty, begins encoding the\n * next packet in line.\n *\n * @api private\n */\n\nManager.prototype.processPacketQueue = function() {\n  if (this.packetBuffer.length > 0 && !this.encoding) {\n    var pack = this.packetBuffer.shift();\n    this.packet(pack);\n  }\n};\n\n/**\n * Clean up transport subscriptions and packet buffer.\n *\n * @api private\n */\n\nManager.prototype.cleanup = function(){\n  var sub;\n  while (sub = this.subs.shift()) sub.destroy();\n\n  this.packetBuffer = [];\n  this.encoding = false;\n\n  this.decoder.destroy();\n};\n\n/**\n * Close the current socket.\n *\n * @api private\n */\n\nManager.prototype.close =\nManager.prototype.disconnect = function(){\n  this.skipReconnect = true;\n  this.backoff.reset();\n  this.readyState = 'closed';\n  this.engine && this.engine.close();\n};\n\n/**\n * Called upon engine close.\n *\n * @api private\n */\n\nManager.prototype.onclose = function(reason){\n  debug('close');\n  this.cleanup();\n  this.backoff.reset();\n  this.readyState = 'closed';\n  this.emit('close', reason);\n  if (this._reconnection && !this.skipReconnect) {\n    this.reconnect();\n  }\n};\n\n/**\n * Attempt a reconnection.\n *\n * @api private\n */\n\nManager.prototype.reconnect = function(){\n  if (this.reconnecting || this.skipReconnect) return this;\n\n  var self = this;\n\n  if (this.backoff.attempts >= this._reconnectionAttempts) {\n    debug('reconnect failed');\n    this.backoff.reset();\n    this.emitAll('reconnect_failed');\n    this.reconnecting = false;\n  } else {\n    var delay = this.backoff.duration();\n    debug('will wait %dms before reconnect attempt', delay);\n\n    this.reconnecting = true;\n    var timer = setTimeout(function(){\n      if (self.skipReconnect) return;\n\n      debug('attempting reconnect');\n      self.emitAll('reconnect_attempt', self.backoff.attempts);\n      self.emitAll('reconnecting', self.backoff.attempts);\n\n      // check again for the case socket closed in above events\n      if (self.skipReconnect) return;\n\n      self.open(function(err){\n        if (err) {\n          debug('reconnect attempt error');\n          self.reconnecting = false;\n          self.reconnect();\n          self.emitAll('reconnect_error', err.data);\n        } else {\n          debug('reconnect success');\n          self.onreconnect();\n        }\n      });\n    }, delay);\n\n    this.subs.push({\n      destroy: function(){\n        clearTimeout(timer);\n      }\n    });\n  }\n};\n\n/**\n * Called upon successful reconnect.\n *\n * @api private\n */\n\nManager.prototype.onreconnect = function(){\n  var attempt = this.backoff.attempts;\n  this.reconnecting = false;\n  this.backoff.reset();\n  this.updateSocketIds();\n  this.emitAll('reconnect', attempt);\n};\n\n},{\"./on\":4,\"./socket\":5,\"./url\":6,\"backo2\":7,\"component-bind\":8,\"component-emitter\":9,\"debug\":10,\"engine.io-client\":11,\"indexof\":42,\"object-component\":43,\"socket.io-parser\":46}],4:[function(_dereq_,module,exports){\n\n/**\n * Module exports.\n */\n\nmodule.exports = on;\n\n/**\n * Helper for subscriptions.\n *\n * @param {Object|EventEmitter} obj with `Emitter` mixin or `EventEmitter`\n * @param {String} event name\n * @param {Function} callback\n * @api public\n */\n\nfunction on(obj, ev, fn) {\n  obj.on(ev, fn);\n  return {\n    destroy: function(){\n      obj.removeListener(ev, fn);\n    }\n  };\n}\n\n},{}],5:[function(_dereq_,module,exports){\n\n/**\n * Module dependencies.\n */\n\nvar parser = _dereq_('socket.io-parser');\nvar Emitter = _dereq_('component-emitter');\nvar toArray = _dereq_('to-array');\nvar on = _dereq_('./on');\nvar bind = _dereq_('component-bind');\nvar debug = _dereq_('debug')('socket.io-client:socket');\nvar hasBin = _dereq_('has-binary');\n\n/**\n * Module exports.\n */\n\nmodule.exports = exports = Socket;\n\n/**\n * Internal events (blacklisted).\n * These events can't be emitted by the user.\n *\n * @api private\n */\n\nvar events = {\n  connect: 1,\n  connect_error: 1,\n  connect_timeout: 1,\n  disconnect: 1,\n  error: 1,\n  reconnect: 1,\n  reconnect_attempt: 1,\n  reconnect_failed: 1,\n  reconnect_error: 1,\n  reconnecting: 1\n};\n\n/**\n * Shortcut to `Emitter#emit`.\n */\n\nvar emit = Emitter.prototype.emit;\n\n/**\n * `Socket` constructor.\n *\n * @api public\n */\n\nfunction Socket(io, nsp){\n  this.io = io;\n  this.nsp = nsp;\n  this.json = this; // compat\n  this.ids = 0;\n  this.acks = {};\n  if (this.io.autoConnect) this.open();\n  this.receiveBuffer = [];\n  this.sendBuffer = [];\n  this.connected = false;\n  this.disconnected = true;\n}\n\n/**\n * Mix in `Emitter`.\n */\n\nEmitter(Socket.prototype);\n\n/**\n * Subscribe to open, close and packet events\n *\n * @api private\n */\n\nSocket.prototype.subEvents = function() {\n  if (this.subs) return;\n\n  var io = this.io;\n  this.subs = [\n    on(io, 'open', bind(this, 'onopen')),\n    on(io, 'packet', bind(this, 'onpacket')),\n    on(io, 'close', bind(this, 'onclose'))\n  ];\n};\n\n/**\n * \"Opens\" the socket.\n *\n * @api public\n */\n\nSocket.prototype.open =\nSocket.prototype.connect = function(){\n  if (this.connected) return this;\n\n  this.subEvents();\n  this.io.open(); // ensure open\n  if ('open' == this.io.readyState) this.onopen();\n  return this;\n};\n\n/**\n * Sends a `message` event.\n *\n * @return {Socket} self\n * @api public\n */\n\nSocket.prototype.send = function(){\n  var args = toArray(arguments);\n  args.unshift('message');\n  this.emit.apply(this, args);\n  return this;\n};\n\n/**\n * Override `emit`.\n * If the event is in `events`, it's emitted normally.\n *\n * @param {String} event name\n * @return {Socket} self\n * @api public\n */\n\nSocket.prototype.emit = function(ev){\n  if (events.hasOwnProperty(ev)) {\n    emit.apply(this, arguments);\n    return this;\n  }\n\n  var args = toArray(arguments);\n  var parserType = parser.EVENT; // default\n  if (hasBin(args)) { parserType = parser.BINARY_EVENT; } // binary\n  var packet = { type: parserType, data: args };\n\n  // event ack callback\n  if ('function' == typeof args[args.length - 1]) {\n    debug('emitting packet with ack id %d', this.ids);\n    this.acks[this.ids] = args.pop();\n    packet.id = this.ids++;\n  }\n\n  if (this.connected) {\n    this.packet(packet);\n  } else {\n    this.sendBuffer.push(packet);\n  }\n\n  return this;\n};\n\n/**\n * Sends a packet.\n *\n * @param {Object} packet\n * @api private\n */\n\nSocket.prototype.packet = function(packet){\n  packet.nsp = this.nsp;\n  this.io.packet(packet);\n};\n\n/**\n * Called upon engine `open`.\n *\n * @api private\n */\n\nSocket.prototype.onopen = function(){\n  debug('transport is open - connecting');\n\n  // write connect packet if necessary\n  if ('/' != this.nsp) {\n    this.packet({ type: parser.CONNECT });\n  }\n};\n\n/**\n * Called upon engine `close`.\n *\n * @param {String} reason\n * @api private\n */\n\nSocket.prototype.onclose = function(reason){\n  debug('close (%s)', reason);\n  this.connected = false;\n  this.disconnected = true;\n  delete this.id;\n  this.emit('disconnect', reason);\n};\n\n/**\n * Called with socket packet.\n *\n * @param {Object} packet\n * @api private\n */\n\nSocket.prototype.onpacket = function(packet){\n  if (packet.nsp != this.nsp) return;\n\n  switch (packet.type) {\n    case parser.CONNECT:\n      this.onconnect();\n      break;\n\n    case parser.EVENT:\n      this.onevent(packet);\n      break;\n\n    case parser.BINARY_EVENT:\n      this.onevent(packet);\n      break;\n\n    case parser.ACK:\n      this.onack(packet);\n      break;\n\n    case parser.BINARY_ACK:\n      this.onack(packet);\n      break;\n\n    case parser.DISCONNECT:\n      this.ondisconnect();\n      break;\n\n    case parser.ERROR:\n      this.emit('error', packet.data);\n      break;\n  }\n};\n\n/**\n * Called upon a server event.\n *\n * @param {Object} packet\n * @api private\n */\n\nSocket.prototype.onevent = function(packet){\n  var args = packet.data || [];\n  debug('emitting event %j', args);\n\n  if (null != packet.id) {\n    debug('attaching ack callback to event');\n    args.push(this.ack(packet.id));\n  }\n\n  if (this.connected) {\n    emit.apply(this, args);\n  } else {\n    this.receiveBuffer.push(args);\n  }\n};\n\n/**\n * Produces an ack callback to emit with an event.\n *\n * @api private\n */\n\nSocket.prototype.ack = function(id){\n  var self = this;\n  var sent = false;\n  return function(){\n    // prevent double callbacks\n    if (sent) return;\n    sent = true;\n    var args = toArray(arguments);\n    debug('sending ack %j', args);\n\n    var type = hasBin(args) ? parser.BINARY_ACK : parser.ACK;\n    self.packet({\n      type: type,\n      id: id,\n      data: args\n    });\n  };\n};\n\n/**\n * Called upon a server acknowlegement.\n *\n * @param {Object} packet\n * @api private\n */\n\nSocket.prototype.onack = function(packet){\n  debug('calling ack %s with %j', packet.id, packet.data);\n  var fn = this.acks[packet.id];\n  fn.apply(this, packet.data);\n  delete this.acks[packet.id];\n};\n\n/**\n * Called upon server connect.\n *\n * @api private\n */\n\nSocket.prototype.onconnect = function(){\n  this.connected = true;\n  this.disconnected = false;\n  this.emit('connect');\n  this.emitBuffered();\n};\n\n/**\n * Emit buffered events (received and emitted).\n *\n * @api private\n */\n\nSocket.prototype.emitBuffered = function(){\n  var i;\n  for (i = 0; i < this.receiveBuffer.length; i++) {\n    emit.apply(this, this.receiveBuffer[i]);\n  }\n  this.receiveBuffer = [];\n\n  for (i = 0; i < this.sendBuffer.length; i++) {\n    this.packet(this.sendBuffer[i]);\n  }\n  this.sendBuffer = [];\n};\n\n/**\n * Called upon server disconnect.\n *\n * @api private\n */\n\nSocket.prototype.ondisconnect = function(){\n  debug('server disconnect (%s)', this.nsp);\n  this.destroy();\n  this.onclose('io server disconnect');\n};\n\n/**\n * Called upon forced client/server side disconnections,\n * this method ensures the manager stops tracking us and\n * that reconnections don't get triggered for this.\n *\n * @api private.\n */\n\nSocket.prototype.destroy = function(){\n  if (this.subs) {\n    // clean subscriptions to avoid reconnections\n    for (var i = 0; i < this.subs.length; i++) {\n      this.subs[i].destroy();\n    }\n    this.subs = null;\n  }\n\n  this.io.destroy(this);\n};\n\n/**\n * Disconnects the socket manually.\n *\n * @return {Socket} self\n * @api public\n */\n\nSocket.prototype.close =\nSocket.prototype.disconnect = function(){\n  if (this.connected) {\n    debug('performing disconnect (%s)', this.nsp);\n    this.packet({ type: parser.DISCONNECT });\n  }\n\n  // remove socket from pool\n  this.destroy();\n\n  if (this.connected) {\n    // fire events\n    this.onclose('io client disconnect');\n  }\n  return this;\n};\n\n},{\"./on\":4,\"component-bind\":8,\"component-emitter\":9,\"debug\":10,\"has-binary\":38,\"socket.io-parser\":46,\"to-array\":50}],6:[function(_dereq_,module,exports){\n(function (global){\n\n/**\n * Module dependencies.\n */\n\nvar parseuri = _dereq_('parseuri');\nvar debug = _dereq_('debug')('socket.io-client:url');\n\n/**\n * Module exports.\n */\n\nmodule.exports = url;\n\n/**\n * URL parser.\n *\n * @param {String} url\n * @param {Object} An object meant to mimic window.location.\n *                 Defaults to window.location.\n * @api public\n */\n\nfunction url(uri, loc){\n  var obj = uri;\n\n  // default to window.location\n  var loc = loc || global.location;\n  if (null == uri) uri = loc.protocol + '//' + loc.host;\n\n  // relative path support\n  if ('string' == typeof uri) {\n    if ('/' == uri.charAt(0)) {\n      if ('/' == uri.charAt(1)) {\n        uri = loc.protocol + uri;\n      } else {\n        uri = loc.hostname + uri;\n      }\n    }\n\n    if (!/^(https?|wss?):\\/\\//.test(uri)) {\n      debug('protocol-less url %s', uri);\n      if ('undefined' != typeof loc) {\n        uri = loc.protocol + '//' + uri;\n      } else {\n        uri = 'https://' + uri;\n      }\n    }\n\n    // parse\n    debug('parse %s', uri);\n    obj = parseuri(uri);\n  }\n\n  // make sure we treat `localhost:80` and `localhost` equally\n  if (!obj.port) {\n    if (/^(http|ws)$/.test(obj.protocol)) {\n      obj.port = '80';\n    }\n    else if (/^(http|ws)s$/.test(obj.protocol)) {\n      obj.port = '443';\n    }\n  }\n\n  obj.path = obj.path || '/';\n\n  // define unique id\n  obj.id = obj.protocol + '://' + obj.host + ':' + obj.port;\n  // define href\n  obj.href = obj.protocol + '://' + obj.host + (loc && loc.port == obj.port ? '' : (':' + obj.port));\n\n  return obj;\n}\n\n}).call(this,typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"debug\":10,\"parseuri\":44}],7:[function(_dereq_,module,exports){\n\n/**\n * Expose `Backoff`.\n */\n\nmodule.exports = Backoff;\n\n/**\n * Initialize backoff timer with `opts`.\n *\n * - `min` initial timeout in milliseconds [100]\n * - `max` max timeout [10000]\n * - `jitter` [0]\n * - `factor` [2]\n *\n * @param {Object} opts\n * @api public\n */\n\nfunction Backoff(opts) {\n  opts = opts || {};\n  this.ms = opts.min || 100;\n  this.max = opts.max || 10000;\n  this.factor = opts.factor || 2;\n  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;\n  this.attempts = 0;\n}\n\n/**\n * Return the backoff duration.\n *\n * @return {Number}\n * @api public\n */\n\nBackoff.prototype.duration = function(){\n  var ms = this.ms * Math.pow(this.factor, this.attempts++);\n  if (this.jitter) {\n    var rand =  Math.random();\n    var deviation = Math.floor(rand * this.jitter * ms);\n    ms = (Math.floor(rand * 10) & 1) == 0  ? ms - deviation : ms + deviation;\n  }\n  return Math.min(ms, this.max) | 0;\n};\n\n/**\n * Reset the number of attempts.\n *\n * @api public\n */\n\nBackoff.prototype.reset = function(){\n  this.attempts = 0;\n};\n\n/**\n * Set the minimum duration\n *\n * @api public\n */\n\nBackoff.prototype.setMin = function(min){\n  this.ms = min;\n};\n\n/**\n * Set the maximum duration\n *\n * @api public\n */\n\nBackoff.prototype.setMax = function(max){\n  this.max = max;\n};\n\n/**\n * Set the jitter\n *\n * @api public\n */\n\nBackoff.prototype.setJitter = function(jitter){\n  this.jitter = jitter;\n};\n\n\n},{}],8:[function(_dereq_,module,exports){\n/**\n * Slice reference.\n */\n\nvar slice = [].slice;\n\n/**\n * Bind `obj` to `fn`.\n *\n * @param {Object} obj\n * @param {Function|String} fn or string\n * @return {Function}\n * @api public\n */\n\nmodule.exports = function(obj, fn){\n  if ('string' == typeof fn) fn = obj[fn];\n  if ('function' != typeof fn) throw new Error('bind() requires a function');\n  var args = slice.call(arguments, 2);\n  return function(){\n    return fn.apply(obj, args.concat(slice.call(arguments)));\n  }\n};\n\n},{}],9:[function(_dereq_,module,exports){\n\n/**\n * Expose `Emitter`.\n */\n\nmodule.exports = Emitter;\n\n/**\n * Initialize a new `Emitter`.\n *\n * @api public\n */\n\nfunction Emitter(obj) {\n  if (obj) return mixin(obj);\n};\n\n/**\n * Mixin the emitter properties.\n *\n * @param {Object} obj\n * @return {Object}\n * @api private\n */\n\nfunction mixin(obj) {\n  for (var key in Emitter.prototype) {\n    obj[key] = Emitter.prototype[key];\n  }\n  return obj;\n}\n\n/**\n * Listen on the given `event` with `fn`.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.on =\nEmitter.prototype.addEventListener = function(event, fn){\n  this._callbacks = this._callbacks || {};\n  (this._callbacks[event] = this._callbacks[event] || [])\n    .push(fn);\n  return this;\n};\n\n/**\n * Adds an `event` listener that will be invoked a single\n * time then automatically removed.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.once = function(event, fn){\n  var self = this;\n  this._callbacks = this._callbacks || {};\n\n  function on() {\n    self.off(event, on);\n    fn.apply(this, arguments);\n  }\n\n  on.fn = fn;\n  this.on(event, on);\n  return this;\n};\n\n/**\n * Remove the given callback for `event` or all\n * registered callbacks.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.off =\nEmitter.prototype.removeListener =\nEmitter.prototype.removeAllListeners =\nEmitter.prototype.removeEventListener = function(event, fn){\n  this._callbacks = this._callbacks || {};\n\n  // all\n  if (0 == arguments.length) {\n    this._callbacks = {};\n    return this;\n  }\n\n  // specific event\n  var callbacks = this._callbacks[event];\n  if (!callbacks) return this;\n\n  // remove all handlers\n  if (1 == arguments.length) {\n    delete this._callbacks[event];\n    return this;\n  }\n\n  // remove specific handler\n  var cb;\n  for (var i = 0; i < callbacks.length; i++) {\n    cb = callbacks[i];\n    if (cb === fn || cb.fn === fn) {\n      callbacks.splice(i, 1);\n      break;\n    }\n  }\n  return this;\n};\n\n/**\n * Emit `event` with the given args.\n *\n * @param {String} event\n * @param {Mixed} ...\n * @return {Emitter}\n */\n\nEmitter.prototype.emit = function(event){\n  this._callbacks = this._callbacks || {};\n  var args = [].slice.call(arguments, 1)\n    , callbacks = this._callbacks[event];\n\n  if (callbacks) {\n    callbacks = callbacks.slice(0);\n    for (var i = 0, len = callbacks.length; i < len; ++i) {\n      callbacks[i].apply(this, args);\n    }\n  }\n\n  return this;\n};\n\n/**\n * Return array of callbacks for `event`.\n *\n * @param {String} event\n * @return {Array}\n * @api public\n */\n\nEmitter.prototype.listeners = function(event){\n  this._callbacks = this._callbacks || {};\n  return this._callbacks[event] || [];\n};\n\n/**\n * Check if this emitter has `event` handlers.\n *\n * @param {String} event\n * @return {Boolean}\n * @api public\n */\n\nEmitter.prototype.hasListeners = function(event){\n  return !! this.listeners(event).length;\n};\n\n},{}],10:[function(_dereq_,module,exports){\n\n/**\n * Expose `debug()` as the module.\n */\n\nmodule.exports = debug;\n\n/**\n * Create a debugger with the given `name`.\n *\n * @param {String} name\n * @return {Type}\n * @api public\n */\n\nfunction debug(name) {\n  if (!debug.enabled(name)) return function(){};\n\n  return function(fmt){\n    fmt = coerce(fmt);\n\n    var curr = new Date;\n    var ms = curr - (debug[name] || curr);\n    debug[name] = curr;\n\n    fmt = name\n      + ' '\n      + fmt\n      + ' +' + debug.humanize(ms);\n\n    // This hackery is required for IE8\n    // where `console.log` doesn't have 'apply'\n    window.console\n      && console.log\n      && Function.prototype.apply.call(console.log, console, arguments);\n  }\n}\n\n/**\n * The currently active debug mode names.\n */\n\ndebug.names = [];\ndebug.skips = [];\n\n/**\n * Enables a debug mode by name. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} name\n * @api public\n */\n\ndebug.enable = function(name) {\n  try {\n    localStorage.debug = name;\n  } catch(e){}\n\n  var split = (name || '').split(/[\\s,]+/)\n    , len = split.length;\n\n  for (var i = 0; i < len; i++) {\n    name = split[i].replace('*', '.*?');\n    if (name[0] === '-') {\n      debug.skips.push(new RegExp('^' + name.substr(1) + '$'));\n    }\n    else {\n      debug.names.push(new RegExp('^' + name + '$'));\n    }\n  }\n};\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\ndebug.disable = function(){\n  debug.enable('');\n};\n\n/**\n * Humanize the given `ms`.\n *\n * @param {Number} m\n * @return {String}\n * @api private\n */\n\ndebug.humanize = function(ms) {\n  var sec = 1000\n    , min = 60 * 1000\n    , hour = 60 * min;\n\n  if (ms >= hour) return (ms / hour).toFixed(1) + 'h';\n  if (ms >= min) return (ms / min).toFixed(1) + 'm';\n  if (ms >= sec) return (ms / sec | 0) + 's';\n  return ms + 'ms';\n};\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\ndebug.enabled = function(name) {\n  for (var i = 0, len = debug.skips.length; i < len; i++) {\n    if (debug.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (var i = 0, len = debug.names.length; i < len; i++) {\n    if (debug.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * Coerce `val`.\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n\n// persist\n\ntry {\n  if (window.localStorage) debug.enable(localStorage.debug);\n} catch(e){}\n\n},{}],11:[function(_dereq_,module,exports){\n\nmodule.exports =  _dereq_('./lib/');\n\n},{\"./lib/\":12}],12:[function(_dereq_,module,exports){\n\nmodule.exports = _dereq_('./socket');\n\n/**\n * Exports parser\n *\n * @api public\n *\n */\nmodule.exports.parser = _dereq_('engine.io-parser');\n\n},{\"./socket\":13,\"engine.io-parser\":25}],13:[function(_dereq_,module,exports){\n(function (global){\n/**\n * Module dependencies.\n */\n\nvar transports = _dereq_('./transports');\nvar Emitter = _dereq_('component-emitter');\nvar debug = _dereq_('debug')('engine.io-client:socket');\nvar index = _dereq_('indexof');\nvar parser = _dereq_('engine.io-parser');\nvar parseuri = _dereq_('parseuri');\nvar parsejson = _dereq_('parsejson');\nvar parseqs = _dereq_('parseqs');\n\n/**\n * Module exports.\n */\n\nmodule.exports = Socket;\n\n/**\n * Noop function.\n *\n * @api private\n */\n\nfunction noop(){}\n\n/**\n * Socket constructor.\n *\n * @param {String|Object} uri or options\n * @param {Object} options\n * @api public\n */\n\nfunction Socket(uri, opts){\n  if (!(this instanceof Socket)) return new Socket(uri, opts);\n\n  opts = opts || {};\n\n  if (uri && 'object' == typeof uri) {\n    opts = uri;\n    uri = null;\n  }\n\n  if (uri) {\n    uri = parseuri(uri);\n    opts.host = uri.host;\n    opts.secure = uri.protocol == 'https' || uri.protocol == 'wss';\n    opts.port = uri.port;\n    if (uri.query) opts.query = uri.query;\n  }\n\n  this.secure = null != opts.secure ? opts.secure :\n    (global.location && 'https:' == location.protocol);\n\n  if (opts.host) {\n    var pieces = opts.host.split(':');\n    opts.hostname = pieces.shift();\n    if (pieces.length) {\n      opts.port = pieces.pop();\n    } else if (!opts.port) {\n      // if no port is specified manually, use the protocol default\n      opts.port = this.secure ? '443' : '80';\n    }\n  }\n\n  this.agent = opts.agent || false;\n  this.hostname = opts.hostname ||\n    (global.location ? location.hostname : 'localhost');\n  this.port = opts.port || (global.location && location.port ?\n       location.port :\n       (this.secure ? 443 : 80));\n  this.query = opts.query || {};\n  if ('string' == typeof this.query) this.query = parseqs.decode(this.query);\n  this.upgrade = false !== opts.upgrade;\n  this.path = (opts.path || '/engine.io').replace(/\\/$/, '') + '/';\n  this.forceJSONP = !!opts.forceJSONP;\n  this.jsonp = false !== opts.jsonp;\n  this.forceBase64 = !!opts.forceBase64;\n  this.enablesXDR = !!opts.enablesXDR;\n  this.timestampParam = opts.timestampParam || 't';\n  this.timestampRequests = opts.timestampRequests;\n  this.transports = opts.transports || ['polling', 'websocket'];\n  this.readyState = '';\n  this.writeBuffer = [];\n  this.callbackBuffer = [];\n  this.policyPort = opts.policyPort || 843;\n  this.rememberUpgrade = opts.rememberUpgrade || false;\n  this.binaryType = null;\n  this.onlyBinaryUpgrades = opts.onlyBinaryUpgrades;\n\n  // SSL options for Node.js client\n  this.pfx = opts.pfx || null;\n  this.key = opts.key || null;\n  this.passphrase = opts.passphrase || null;\n  this.cert = opts.cert || null;\n  this.ca = opts.ca || null;\n  this.ciphers = opts.ciphers || null;\n  this.rejectUnauthorized = opts.rejectUnauthorized || null;\n\n  this.open();\n}\n\nSocket.priorWebsocketSuccess = false;\n\n/**\n * Mix in `Emitter`.\n */\n\nEmitter(Socket.prototype);\n\n/**\n * Protocol version.\n *\n * @api public\n */\n\nSocket.protocol = parser.protocol; // this is an int\n\n/**\n * Expose deps for legacy compatibility\n * and standalone browser access.\n */\n\nSocket.Socket = Socket;\nSocket.Transport = _dereq_('./transport');\nSocket.transports = _dereq_('./transports');\nSocket.parser = _dereq_('engine.io-parser');\n\n/**\n * Creates transport of the given type.\n *\n * @param {String} transport name\n * @return {Transport}\n * @api private\n */\n\nSocket.prototype.createTransport = function (name) {\n  debug('creating transport \"%s\"', name);\n  var query = clone(this.query);\n\n  // append engine.io protocol identifier\n  query.EIO = parser.protocol;\n\n  // transport name\n  query.transport = name;\n\n  // session id if we already have one\n  if (this.id) query.sid = this.id;\n\n  var transport = new transports[name]({\n    agent: this.agent,\n    hostname: this.hostname,\n    port: this.port,\n    secure: this.secure,\n    path: this.path,\n    query: query,\n    forceJSONP: this.forceJSONP,\n    jsonp: this.jsonp,\n    forceBase64: this.forceBase64,\n    enablesXDR: this.enablesXDR,\n    timestampRequests: this.timestampRequests,\n    timestampParam: this.timestampParam,\n    policyPort: this.policyPort,\n    socket: this,\n    pfx: this.pfx,\n    key: this.key,\n    passphrase: this.passphrase,\n    cert: this.cert,\n    ca: this.ca,\n    ciphers: this.ciphers,\n    rejectUnauthorized: this.rejectUnauthorized\n  });\n\n  return transport;\n};\n\nfunction clone (obj) {\n  var o = {};\n  for (var i in obj) {\n    if (obj.hasOwnProperty(i)) {\n      o[i] = obj[i];\n    }\n  }\n  return o;\n}\n\n/**\n * Initializes transport to use and starts probe.\n *\n * @api private\n */\nSocket.prototype.open = function () {\n  var transport;\n  if (this.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf('websocket') != -1) {\n    transport = 'websocket';\n  } else if (0 == this.transports.length) {\n    // Emit error on next tick so it can be listened to\n    var self = this;\n    setTimeout(function() {\n      self.emit('error', 'No transports available');\n    }, 0);\n    return;\n  } else {\n    transport = this.transports[0];\n  }\n  this.readyState = 'opening';\n\n  // Retry with the next transport if the transport is disabled (jsonp: false)\n  var transport;\n  try {\n    transport = this.createTransport(transport);\n  } catch (e) {\n    this.transports.shift();\n    this.open();\n    return;\n  }\n\n  transport.open();\n  this.setTransport(transport);\n};\n\n/**\n * Sets the current transport. Disables the existing one (if any).\n *\n * @api private\n */\n\nSocket.prototype.setTransport = function(transport){\n  debug('setting transport %s', transport.name);\n  var self = this;\n\n  if (this.transport) {\n    debug('clearing existing transport %s', this.transport.name);\n    this.transport.removeAllListeners();\n  }\n\n  // set up transport\n  this.transport = transport;\n\n  // set up transport listeners\n  transport\n  .on('drain', function(){\n    self.onDrain();\n  })\n  .on('packet', function(packet){\n    self.onPacket(packet);\n  })\n  .on('error', function(e){\n    self.onError(e);\n  })\n  .on('close', function(){\n    self.onClose('transport close');\n  });\n};\n\n/**\n * Probes a transport.\n *\n * @param {String} transport name\n * @api private\n */\n\nSocket.prototype.probe = function (name) {\n  debug('probing transport \"%s\"', name);\n  var transport = this.createTransport(name, { probe: 1 })\n    , failed = false\n    , self = this;\n\n  Socket.priorWebsocketSuccess = false;\n\n  function onTransportOpen(){\n    if (self.onlyBinaryUpgrades) {\n      var upgradeLosesBinary = !this.supportsBinary && self.transport.supportsBinary;\n      failed = failed || upgradeLosesBinary;\n    }\n    if (failed) return;\n\n    debug('probe transport \"%s\" opened', name);\n    transport.send([{ type: 'ping', data: 'probe' }]);\n    transport.once('packet', function (msg) {\n      if (failed) return;\n      if ('pong' == msg.type && 'probe' == msg.data) {\n        debug('probe transport \"%s\" pong', name);\n        self.upgrading = true;\n        self.emit('upgrading', transport);\n        if (!transport) return;\n        Socket.priorWebsocketSuccess = 'websocket' == transport.name;\n\n        debug('pausing current transport \"%s\"', self.transport.name);\n        self.transport.pause(function () {\n          if (failed) return;\n          if ('closed' == self.readyState) return;\n          debug('changing transport and sending upgrade packet');\n\n          cleanup();\n\n          self.setTransport(transport);\n          transport.send([{ type: 'upgrade' }]);\n          self.emit('upgrade', transport);\n          transport = null;\n          self.upgrading = false;\n          self.flush();\n        });\n      } else {\n        debug('probe transport \"%s\" failed', name);\n        var err = new Error('probe error');\n        err.transport = transport.name;\n        self.emit('upgradeError', err);\n      }\n    });\n  }\n\n  function freezeTransport() {\n    if (failed) return;\n\n    // Any callback called by transport should be ignored since now\n    failed = true;\n\n    cleanup();\n\n    transport.close();\n    transport = null;\n  }\n\n  //Handle any error that happens while probing\n  function onerror(err) {\n    var error = new Error('probe error: ' + err);\n    error.transport = transport.name;\n\n    freezeTransport();\n\n    debug('probe transport \"%s\" failed because of error: %s', name, err);\n\n    self.emit('upgradeError', error);\n  }\n\n  function onTransportClose(){\n    onerror(\"transport closed\");\n  }\n\n  //When the socket is closed while we're probing\n  function onclose(){\n    onerror(\"socket closed\");\n  }\n\n  //When the socket is upgraded while we're probing\n  function onupgrade(to){\n    if (transport && to.name != transport.name) {\n      debug('\"%s\" works - aborting \"%s\"', to.name, transport.name);\n      freezeTransport();\n    }\n  }\n\n  //Remove all listeners on the transport and on self\n  function cleanup(){\n    transport.removeListener('open', onTransportOpen);\n    transport.removeListener('error', onerror);\n    transport.removeListener('close', onTransportClose);\n    self.removeListener('close', onclose);\n    self.removeListener('upgrading', onupgrade);\n  }\n\n  transport.once('open', onTransportOpen);\n  transport.once('error', onerror);\n  transport.once('close', onTransportClose);\n\n  this.once('close', onclose);\n  this.once('upgrading', onupgrade);\n\n  transport.open();\n\n};\n\n/**\n * Called when connection is deemed open.\n *\n * @api public\n */\n\nSocket.prototype.onOpen = function () {\n  debug('socket open');\n  this.readyState = 'open';\n  Socket.priorWebsocketSuccess = 'websocket' == this.transport.name;\n  this.emit('open');\n  this.flush();\n\n  // we check for `readyState` in case an `open`\n  // listener already closed the socket\n  if ('open' == this.readyState && this.upgrade && this.transport.pause) {\n    debug('starting upgrade probes');\n    for (var i = 0, l = this.upgrades.length; i < l; i++) {\n      this.probe(this.upgrades[i]);\n    }\n  }\n};\n\n/**\n * Handles a packet.\n *\n * @api private\n */\n\nSocket.prototype.onPacket = function (packet) {\n  if ('opening' == this.readyState || 'open' == this.readyState) {\n    debug('socket receive: type \"%s\", data \"%s\"', packet.type, packet.data);\n\n    this.emit('packet', packet);\n\n    // Socket is live - any packet counts\n    this.emit('heartbeat');\n\n    switch (packet.type) {\n      case 'open':\n        this.onHandshake(parsejson(packet.data));\n        break;\n\n      case 'pong':\n        this.setPing();\n        break;\n\n      case 'error':\n        var err = new Error('server error');\n        err.code = packet.data;\n        this.emit('error', err);\n        break;\n\n      case 'message':\n        this.emit('data', packet.data);\n        this.emit('message', packet.data);\n        break;\n    }\n  } else {\n    debug('packet received with socket readyState \"%s\"', this.readyState);\n  }\n};\n\n/**\n * Called upon handshake completion.\n *\n * @param {Object} handshake obj\n * @api private\n */\n\nSocket.prototype.onHandshake = function (data) {\n  this.emit('handshake', data);\n  this.id = data.sid;\n  this.transport.query.sid = data.sid;\n  this.upgrades = this.filterUpgrades(data.upgrades);\n  this.pingInterval = data.pingInterval;\n  this.pingTimeout = data.pingTimeout;\n  this.onOpen();\n  // In case open handler closes socket\n  if  ('closed' == this.readyState) return;\n  this.setPing();\n\n  // Prolong liveness of socket on heartbeat\n  this.removeListener('heartbeat', this.onHeartbeat);\n  this.on('heartbeat', this.onHeartbeat);\n};\n\n/**\n * Resets ping timeout.\n *\n * @api private\n */\n\nSocket.prototype.onHeartbeat = function (timeout) {\n  clearTimeout(this.pingTimeoutTimer);\n  var self = this;\n  self.pingTimeoutTimer = setTimeout(function () {\n    if ('closed' == self.readyState) return;\n    self.onClose('ping timeout');\n  }, timeout || (self.pingInterval + self.pingTimeout));\n};\n\n/**\n * Pings server every `this.pingInterval` and expects response\n * within `this.pingTimeout` or closes connection.\n *\n * @api private\n */\n\nSocket.prototype.setPing = function () {\n  var self = this;\n  clearTimeout(self.pingIntervalTimer);\n  self.pingIntervalTimer = setTimeout(function () {\n    debug('writing ping packet - expecting pong within %sms', self.pingTimeout);\n    self.ping();\n    self.onHeartbeat(self.pingTimeout);\n  }, self.pingInterval);\n};\n\n/**\n* Sends a ping packet.\n*\n* @api public\n*/\n\nSocket.prototype.ping = function () {\n  this.sendPacket('ping');\n};\n\n/**\n * Called on `drain` event\n *\n * @api private\n */\n\nSocket.prototype.onDrain = function() {\n  for (var i = 0; i < this.prevBufferLen; i++) {\n    if (this.callbackBuffer[i]) {\n      this.callbackBuffer[i]();\n    }\n  }\n\n  this.writeBuffer.splice(0, this.prevBufferLen);\n  this.callbackBuffer.splice(0, this.prevBufferLen);\n\n  // setting prevBufferLen = 0 is very important\n  // for example, when upgrading, upgrade packet is sent over,\n  // and a nonzero prevBufferLen could cause problems on `drain`\n  this.prevBufferLen = 0;\n\n  if (this.writeBuffer.length == 0) {\n    this.emit('drain');\n  } else {\n    this.flush();\n  }\n};\n\n/**\n * Flush write buffers.\n *\n * @api private\n */\n\nSocket.prototype.flush = function () {\n  if ('closed' != this.readyState && this.transport.writable &&\n    !this.upgrading && this.writeBuffer.length) {\n    debug('flushing %d packets in socket', this.writeBuffer.length);\n    this.transport.send(this.writeBuffer);\n    // keep track of current length of writeBuffer\n    // splice writeBuffer and callbackBuffer on `drain`\n    this.prevBufferLen = this.writeBuffer.length;\n    this.emit('flush');\n  }\n};\n\n/**\n * Sends a message.\n *\n * @param {String} message.\n * @param {Function} callback function.\n * @return {Socket} for chaining.\n * @api public\n */\n\nSocket.prototype.write =\nSocket.prototype.send = function (msg, fn) {\n  this.sendPacket('message', msg, fn);\n  return this;\n};\n\n/**\n * Sends a packet.\n *\n * @param {String} packet type.\n * @param {String} data.\n * @param {Function} callback function.\n * @api private\n */\n\nSocket.prototype.sendPacket = function (type, data, fn) {\n  if ('closing' == this.readyState || 'closed' == this.readyState) {\n    return;\n  }\n\n  var packet = { type: type, data: data };\n  this.emit('packetCreate', packet);\n  this.writeBuffer.push(packet);\n  this.callbackBuffer.push(fn);\n  this.flush();\n};\n\n/**\n * Closes the connection.\n *\n * @api private\n */\n\nSocket.prototype.close = function () {\n  if ('opening' == this.readyState || 'open' == this.readyState) {\n    this.readyState = 'closing';\n\n    var self = this;\n\n    function close() {\n      self.onClose('forced close');\n      debug('socket closing - telling transport to close');\n      self.transport.close();\n    }\n\n    function cleanupAndClose() {\n      self.removeListener('upgrade', cleanupAndClose);\n      self.removeListener('upgradeError', cleanupAndClose);\n      close();\n    }\n\n    function waitForUpgrade() {\n      // wait for upgrade to finish since we can't send packets while pausing a transport\n      self.once('upgrade', cleanupAndClose);\n      self.once('upgradeError', cleanupAndClose);\n    }\n\n    if (this.writeBuffer.length) {\n      this.once('drain', function() {\n        if (this.upgrading) {\n          waitForUpgrade();\n        } else {\n          close();\n        }\n      });\n    } else if (this.upgrading) {\n      waitForUpgrade();\n    } else {\n      close();\n    }\n  }\n\n  return this;\n};\n\n/**\n * Called upon transport error\n *\n * @api private\n */\n\nSocket.prototype.onError = function (err) {\n  debug('socket error %j', err);\n  Socket.priorWebsocketSuccess = false;\n  this.emit('error', err);\n  this.onClose('transport error', err);\n};\n\n/**\n * Called upon transport close.\n *\n * @api private\n */\n\nSocket.prototype.onClose = function (reason, desc) {\n  if ('opening' == this.readyState || 'open' == this.readyState || 'closing' == this.readyState) {\n    debug('socket close with reason: \"%s\"', reason);\n    var self = this;\n\n    // clear timers\n    clearTimeout(this.pingIntervalTimer);\n    clearTimeout(this.pingTimeoutTimer);\n\n    // clean buffers in next tick, so developers can still\n    // grab the buffers on `close` event\n    setTimeout(function() {\n      self.writeBuffer = [];\n      self.callbackBuffer = [];\n      self.prevBufferLen = 0;\n    }, 0);\n\n    // stop event from firing again for transport\n    this.transport.removeAllListeners('close');\n\n    // ensure transport won't stay open\n    this.transport.close();\n\n    // ignore further transport communication\n    this.transport.removeAllListeners();\n\n    // set ready state\n    this.readyState = 'closed';\n\n    // clear session id\n    this.id = null;\n\n    // emit close event\n    this.emit('close', reason, desc);\n  }\n};\n\n/**\n * Filters upgrades, returning only those matching client transports.\n *\n * @param {Array} server upgrades\n * @api private\n *\n */\n\nSocket.prototype.filterUpgrades = function (upgrades) {\n  var filteredUpgrades = [];\n  for (var i = 0, j = upgrades.length; i<j; i++) {\n    if (~index(this.transports, upgrades[i])) filteredUpgrades.push(upgrades[i]);\n  }\n  return filteredUpgrades;\n};\n\n}).call(this,typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"./transport\":14,\"./transports\":15,\"component-emitter\":9,\"debug\":22,\"engine.io-parser\":25,\"indexof\":42,\"parsejson\":34,\"parseqs\":35,\"parseuri\":36}],14:[function(_dereq_,module,exports){\n/**\n * Module dependencies.\n */\n\nvar parser = _dereq_('engine.io-parser');\nvar Emitter = _dereq_('component-emitter');\n\n/**\n * Module exports.\n */\n\nmodule.exports = Transport;\n\n/**\n * Transport abstract constructor.\n *\n * @param {Object} options.\n * @api private\n */\n\nfunction Transport (opts) {\n  this.path = opts.path;\n  this.hostname = opts.hostname;\n  this.port = opts.port;\n  this.secure = opts.secure;\n  this.query = opts.query;\n  this.timestampParam = opts.timestampParam;\n  this.timestampRequests = opts.timestampRequests;\n  this.readyState = '';\n  this.agent = opts.agent || false;\n  this.socket = opts.socket;\n  this.enablesXDR = opts.enablesXDR;\n\n  // SSL options for Node.js client\n  this.pfx = opts.pfx;\n  this.key = opts.key;\n  this.passphrase = opts.passphrase;\n  this.cert = opts.cert;\n  this.ca = opts.ca;\n  this.ciphers = opts.ciphers;\n  this.rejectUnauthorized = opts.rejectUnauthorized;\n}\n\n/**\n * Mix in `Emitter`.\n */\n\nEmitter(Transport.prototype);\n\n/**\n * A counter used to prevent collisions in the timestamps used\n * for cache busting.\n */\n\nTransport.timestamps = 0;\n\n/**\n * Emits an error.\n *\n * @param {String} str\n * @return {Transport} for chaining\n * @api public\n */\n\nTransport.prototype.onError = function (msg, desc) {\n  var err = new Error(msg);\n  err.type = 'TransportError';\n  err.description = desc;\n  this.emit('error', err);\n  return this;\n};\n\n/**\n * Opens the transport.\n *\n * @api public\n */\n\nTransport.prototype.open = function () {\n  if ('closed' == this.readyState || '' == this.readyState) {\n    this.readyState = 'opening';\n    this.doOpen();\n  }\n\n  return this;\n};\n\n/**\n * Closes the transport.\n *\n * @api private\n */\n\nTransport.prototype.close = function () {\n  if ('opening' == this.readyState || 'open' == this.readyState) {\n    this.doClose();\n    this.onClose();\n  }\n\n  return this;\n};\n\n/**\n * Sends multiple packets.\n *\n * @param {Array} packets\n * @api private\n */\n\nTransport.prototype.send = function(packets){\n  if ('open' == this.readyState) {\n    this.write(packets);\n  } else {\n    throw new Error('Transport not open');\n  }\n};\n\n/**\n * Called upon open\n *\n * @api private\n */\n\nTransport.prototype.onOpen = function () {\n  this.readyState = 'open';\n  this.writable = true;\n  this.emit('open');\n};\n\n/**\n * Called with data.\n *\n * @param {String} data\n * @api private\n */\n\nTransport.prototype.onData = function(data){\n  var packet = parser.decodePacket(data, this.socket.binaryType);\n  this.onPacket(packet);\n};\n\n/**\n * Called with a decoded packet.\n */\n\nTransport.prototype.onPacket = function (packet) {\n  this.emit('packet', packet);\n};\n\n/**\n * Called upon close.\n *\n * @api private\n */\n\nTransport.prototype.onClose = function () {\n  this.readyState = 'closed';\n  this.emit('close');\n};\n\n},{\"component-emitter\":9,\"engine.io-parser\":25}],15:[function(_dereq_,module,exports){\n(function (global){\n/**\n * Module dependencies\n */\n\nvar XMLHttpRequest = _dereq_('xmlhttprequest');\nvar XHR = _dereq_('./polling-xhr');\nvar JSONP = _dereq_('./polling-jsonp');\nvar websocket = _dereq_('./websocket');\n\n/**\n * Export transports.\n */\n\nexports.polling = polling;\nexports.websocket = websocket;\n\n/**\n * Polling transport polymorphic constructor.\n * Decides on xhr vs jsonp based on feature detection.\n *\n * @api private\n */\n\nfunction polling(opts){\n  var xhr;\n  var xd = false;\n  var xs = false;\n  var jsonp = false !== opts.jsonp;\n\n  if (global.location) {\n    var isSSL = 'https:' == location.protocol;\n    var port = location.port;\n\n    // some user agents have empty `location.port`\n    if (!port) {\n      port = isSSL ? 443 : 80;\n    }\n\n    xd = opts.hostname != location.hostname || port != opts.port;\n    xs = opts.secure != isSSL;\n  }\n\n  opts.xdomain = xd;\n  opts.xscheme = xs;\n  xhr = new XMLHttpRequest(opts);\n\n  if ('open' in xhr && !opts.forceJSONP) {\n    return new XHR(opts);\n  } else {\n    if (!jsonp) throw new Error('JSONP disabled');\n    return new JSONP(opts);\n  }\n}\n\n}).call(this,typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"./polling-jsonp\":16,\"./polling-xhr\":17,\"./websocket\":19,\"xmlhttprequest\":20}],16:[function(_dereq_,module,exports){\n(function (global){\n\n/**\n * Module requirements.\n */\n\nvar Polling = _dereq_('./polling');\nvar inherit = _dereq_('component-inherit');\n\n/**\n * Module exports.\n */\n\nmodule.exports = JSONPPolling;\n\n/**\n * Cached regular expressions.\n */\n\nvar rNewline = /\\n/g;\nvar rEscapedNewline = /\\\\n/g;\n\n/**\n * Global JSONP callbacks.\n */\n\nvar callbacks;\n\n/**\n * Callbacks count.\n */\n\nvar index = 0;\n\n/**\n * Noop.\n */\n\nfunction empty () { }\n\n/**\n * JSONP Polling constructor.\n *\n * @param {Object} opts.\n * @api public\n */\n\nfunction JSONPPolling (opts) {\n  Polling.call(this, opts);\n\n  this.query = this.query || {};\n\n  // define global callbacks array if not present\n  // we do this here (lazily) to avoid unneeded global pollution\n  if (!callbacks) {\n    // we need to consider multiple engines in the same page\n    if (!global.___eio) global.___eio = [];\n    callbacks = global.___eio;\n  }\n\n  // callback identifier\n  this.index = callbacks.length;\n\n  // add callback to jsonp global\n  var self = this;\n  callbacks.push(function (msg) {\n    self.onData(msg);\n  });\n\n  // append to query string\n  this.query.j = this.index;\n\n  // prevent spurious errors from being emitted when the window is unloaded\n  if (global.document && global.addEventListener) {\n    global.addEventListener('beforeunload', function () {\n      if (self.script) self.script.onerror = empty;\n    }, false);\n  }\n}\n\n/**\n * Inherits from Polling.\n */\n\ninherit(JSONPPolling, Polling);\n\n/*\n * JSONP only supports binary as base64 encoded strings\n */\n\nJSONPPolling.prototype.supportsBinary = false;\n\n/**\n * Closes the socket.\n *\n * @api private\n */\n\nJSONPPolling.prototype.doClose = function () {\n  if (this.script) {\n    this.script.parentNode.removeChild(this.script);\n    this.script = null;\n  }\n\n  if (this.form) {\n    this.form.parentNode.removeChild(this.form);\n    this.form = null;\n    this.iframe = null;\n  }\n\n  Polling.prototype.doClose.call(this);\n};\n\n/**\n * Starts a poll cycle.\n *\n * @api private\n */\n\nJSONPPolling.prototype.doPoll = function () {\n  var self = this;\n  var script = document.createElement('script');\n\n  if (this.script) {\n    this.script.parentNode.removeChild(this.script);\n    this.script = null;\n  }\n\n  script.async = true;\n  script.src = this.uri();\n  script.onerror = function(e){\n    self.onError('jsonp poll error',e);\n  };\n\n  var insertAt = document.getElementsByTagName('script')[0];\n  insertAt.parentNode.insertBefore(script, insertAt);\n  this.script = script;\n\n  var isUAgecko = 'undefined' != typeof navigator && /gecko/i.test(navigator.userAgent);\n  \n  if (isUAgecko) {\n    setTimeout(function () {\n      var iframe = document.createElement('iframe');\n      document.body.appendChild(iframe);\n      document.body.removeChild(iframe);\n    }, 100);\n  }\n};\n\n/**\n * Writes with a hidden iframe.\n *\n * @param {String} data to send\n * @param {Function} called upon flush.\n * @api private\n */\n\nJSONPPolling.prototype.doWrite = function (data, fn) {\n  var self = this;\n\n  if (!this.form) {\n    var form = document.createElement('form');\n    var area = document.createElement('textarea');\n    var id = this.iframeId = 'eio_iframe_' + this.index;\n    var iframe;\n\n    form.className = 'socketio';\n    form.style.position = 'absolute';\n    form.style.top = '-1000px';\n    form.style.left = '-1000px';\n    form.target = id;\n    form.method = 'POST';\n    form.setAttribute('accept-charset', 'utf-8');\n    area.name = 'd';\n    form.appendChild(area);\n    document.body.appendChild(form);\n\n    this.form = form;\n    this.area = area;\n  }\n\n  this.form.action = this.uri();\n\n  function complete () {\n    initIframe();\n    fn();\n  }\n\n  function initIframe () {\n    if (self.iframe) {\n      try {\n        self.form.removeChild(self.iframe);\n      } catch (e) {\n        self.onError('jsonp polling iframe removal error', e);\n      }\n    }\n\n    try {\n      // ie6 dynamic iframes with target=\"\" support (thanks Chris Lambacher)\n      var html = '<iframe src=\"javascript:0\" name=\"'+ self.iframeId +'\">';\n      iframe = document.createElement(html);\n    } catch (e) {\n      iframe = document.createElement('iframe');\n      iframe.name = self.iframeId;\n      iframe.src = 'javascript:0';\n    }\n\n    iframe.id = self.iframeId;\n\n    self.form.appendChild(iframe);\n    self.iframe = iframe;\n  }\n\n  initIframe();\n\n  // escape \\n to prevent it from being converted into \\r\\n by some UAs\n  // double escaping is required for escaped new lines because unescaping of new lines can be done safely on server-side\n  data = data.replace(rEscapedNewline, '\\\\\\n');\n  this.area.value = data.replace(rNewline, '\\\\n');\n\n  try {\n    this.form.submit();\n  } catch(e) {}\n\n  if (this.iframe.attachEvent) {\n    this.iframe.onreadystatechange = function(){\n      if (self.iframe.readyState == 'complete') {\n        complete();\n      }\n    };\n  } else {\n    this.iframe.onload = complete;\n  }\n};\n\n}).call(this,typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"./polling\":18,\"component-inherit\":21}],17:[function(_dereq_,module,exports){\n(function (global){\n/**\n * Module requirements.\n */\n\nvar XMLHttpRequest = _dereq_('xmlhttprequest');\nvar Polling = _dereq_('./polling');\nvar Emitter = _dereq_('component-emitter');\nvar inherit = _dereq_('component-inherit');\nvar debug = _dereq_('debug')('engine.io-client:polling-xhr');\n\n/**\n * Module exports.\n */\n\nmodule.exports = XHR;\nmodule.exports.Request = Request;\n\n/**\n * Empty function\n */\n\nfunction empty(){}\n\n/**\n * XHR Polling constructor.\n *\n * @param {Object} opts\n * @api public\n */\n\nfunction XHR(opts){\n  Polling.call(this, opts);\n\n  if (global.location) {\n    var isSSL = 'https:' == location.protocol;\n    var port = location.port;\n\n    // some user agents have empty `location.port`\n    if (!port) {\n      port = isSSL ? 443 : 80;\n    }\n\n    this.xd = opts.hostname != global.location.hostname ||\n      port != opts.port;\n    this.xs = opts.secure != isSSL;\n  }\n}\n\n/**\n * Inherits from Polling.\n */\n\ninherit(XHR, Polling);\n\n/**\n * XHR supports binary\n */\n\nXHR.prototype.supportsBinary = true;\n\n/**\n * Creates a request.\n *\n * @param {String} method\n * @api private\n */\n\nXHR.prototype.request = function(opts){\n  opts = opts || {};\n  opts.uri = this.uri();\n  opts.xd = this.xd;\n  opts.xs = this.xs;\n  opts.agent = this.agent || false;\n  opts.supportsBinary = this.supportsBinary;\n  opts.enablesXDR = this.enablesXDR;\n\n  // SSL options for Node.js client\n  opts.pfx = this.pfx;\n  opts.key = this.key;\n  opts.passphrase = this.passphrase;\n  opts.cert = this.cert;\n  opts.ca = this.ca;\n  opts.ciphers = this.ciphers;\n  opts.rejectUnauthorized = this.rejectUnauthorized;\n\n  return new Request(opts);\n};\n\n/**\n * Sends data.\n *\n * @param {String} data to send.\n * @param {Function} called upon flush.\n * @api private\n */\n\nXHR.prototype.doWrite = function(data, fn){\n  var isBinary = typeof data !== 'string' && data !== undefined;\n  var req = this.request({ method: 'POST', data: data, isBinary: isBinary });\n  var self = this;\n  req.on('success', fn);\n  req.on('error', function(err){\n    self.onError('xhr post error', err);\n  });\n  this.sendXhr = req;\n};\n\n/**\n * Starts a poll cycle.\n *\n * @api private\n */\n\nXHR.prototype.doPoll = function(){\n  debug('xhr poll');\n  var req = this.request();\n  var self = this;\n  req.on('data', function(data){\n    self.onData(data);\n  });\n  req.on('error', function(err){\n    self.onError('xhr poll error', err);\n  });\n  this.pollXhr = req;\n};\n\n/**\n * Request constructor\n *\n * @param {Object} options\n * @api public\n */\n\nfunction Request(opts){\n  this.method = opts.method || 'GET';\n  this.uri = opts.uri;\n  this.xd = !!opts.xd;\n  this.xs = !!opts.xs;\n  this.async = false !== opts.async;\n  this.data = undefined != opts.data ? opts.data : null;\n  this.agent = opts.agent;\n  this.isBinary = opts.isBinary;\n  this.supportsBinary = opts.supportsBinary;\n  this.enablesXDR = opts.enablesXDR;\n\n  // SSL options for Node.js client\n  this.pfx = opts.pfx;\n  this.key = opts.key;\n  this.passphrase = opts.passphrase;\n  this.cert = opts.cert;\n  this.ca = opts.ca;\n  this.ciphers = opts.ciphers;\n  this.rejectUnauthorized = opts.rejectUnauthorized;\n\n  this.create();\n}\n\n/**\n * Mix in `Emitter`.\n */\n\nEmitter(Request.prototype);\n\n/**\n * Creates the XHR object and sends the request.\n *\n * @api private\n */\n\nRequest.prototype.create = function(){\n  var opts = { agent: this.agent, xdomain: this.xd, xscheme: this.xs, enablesXDR: this.enablesXDR };\n\n  // SSL options for Node.js client\n  opts.pfx = this.pfx;\n  opts.key = this.key;\n  opts.passphrase = this.passphrase;\n  opts.cert = this.cert;\n  opts.ca = this.ca;\n  opts.ciphers = this.ciphers;\n  opts.rejectUnauthorized = this.rejectUnauthorized;\n\n  var xhr = this.xhr = new XMLHttpRequest(opts);\n  var self = this;\n\n  try {\n    debug('xhr open %s: %s', this.method, this.uri);\n    xhr.open(this.method, this.uri, this.async);\n    if (this.supportsBinary) {\n      // This has to be done after open because Firefox is stupid\n      // http://stackoverflow.com/questions/13216903/get-binary-data-with-xmlhttprequest-in-a-firefox-extension\n      xhr.responseType = 'arraybuffer';\n    }\n\n    if ('POST' == this.method) {\n      try {\n        if (this.isBinary) {\n          xhr.setRequestHeader('Content-type', 'application/octet-stream');\n        } else {\n          xhr.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');\n        }\n      } catch (e) {}\n    }\n\n    // ie6 check\n    if ('withCredentials' in xhr) {\n      xhr.withCredentials = true;\n    }\n\n    if (this.hasXDR()) {\n      xhr.onload = function(){\n        self.onLoad();\n      };\n      xhr.onerror = function(){\n        self.onError(xhr.responseText);\n      };\n    } else {\n      xhr.onreadystatechange = function(){\n        if (4 != xhr.readyState) return;\n        if (200 == xhr.status || 1223 == xhr.status) {\n          self.onLoad();\n        } else {\n          // make sure the `error` event handler that's user-set\n          // does not throw in the same tick and gets caught here\n          setTimeout(function(){\n            self.onError(xhr.status);\n          }, 0);\n        }\n      };\n    }\n\n    debug('xhr data %s', this.data);\n    xhr.send(this.data);\n  } catch (e) {\n    // Need to defer since .create() is called directly fhrom the constructor\n    // and thus the 'error' event can only be only bound *after* this exception\n    // occurs.  Therefore, also, we cannot throw here at all.\n    setTimeout(function() {\n      self.onError(e);\n    }, 0);\n    return;\n  }\n\n  if (global.document) {\n    this.index = Request.requestsCount++;\n    Request.requests[this.index] = this;\n  }\n};\n\n/**\n * Called upon successful response.\n *\n * @api private\n */\n\nRequest.prototype.onSuccess = function(){\n  this.emit('success');\n  this.cleanup();\n};\n\n/**\n * Called if we have data.\n *\n * @api private\n */\n\nRequest.prototype.onData = function(data){\n  this.emit('data', data);\n  this.onSuccess();\n};\n\n/**\n * Called upon error.\n *\n * @api private\n */\n\nRequest.prototype.onError = function(err){\n  this.emit('error', err);\n  this.cleanup(true);\n};\n\n/**\n * Cleans up house.\n *\n * @api private\n */\n\nRequest.prototype.cleanup = function(fromError){\n  if ('undefined' == typeof this.xhr || null === this.xhr) {\n    return;\n  }\n  // xmlhttprequest\n  if (this.hasXDR()) {\n    this.xhr.onload = this.xhr.onerror = empty;\n  } else {\n    this.xhr.onreadystatechange = empty;\n  }\n\n  if (fromError) {\n    try {\n      this.xhr.abort();\n    } catch(e) {}\n  }\n\n  if (global.document) {\n    delete Request.requests[this.index];\n  }\n\n  this.xhr = null;\n};\n\n/**\n * Called upon load.\n *\n * @api private\n */\n\nRequest.prototype.onLoad = function(){\n  var data;\n  try {\n    var contentType;\n    try {\n      contentType = this.xhr.getResponseHeader('Content-Type').split(';')[0];\n    } catch (e) {}\n    if (contentType === 'application/octet-stream') {\n      data = this.xhr.response;\n    } else {\n      if (!this.supportsBinary) {\n        data = this.xhr.responseText;\n      } else {\n        data = 'ok';\n      }\n    }\n  } catch (e) {\n    this.onError(e);\n  }\n  if (null != data) {\n    this.onData(data);\n  }\n};\n\n/**\n * Check if it has XDomainRequest.\n *\n * @api private\n */\n\nRequest.prototype.hasXDR = function(){\n  return 'undefined' !== typeof global.XDomainRequest && !this.xs && this.enablesXDR;\n};\n\n/**\n * Aborts the request.\n *\n * @api public\n */\n\nRequest.prototype.abort = function(){\n  this.cleanup();\n};\n\n/**\n * Aborts pending requests when unloading the window. This is needed to prevent\n * memory leaks (e.g. when using IE) and to ensure that no spurious error is\n * emitted.\n */\n\nif (global.document) {\n  Request.requestsCount = 0;\n  Request.requests = {};\n  if (global.attachEvent) {\n    global.attachEvent('onunload', unloadHandler);\n  } else if (global.addEventListener) {\n    global.addEventListener('beforeunload', unloadHandler, false);\n  }\n}\n\nfunction unloadHandler() {\n  for (var i in Request.requests) {\n    if (Request.requests.hasOwnProperty(i)) {\n      Request.requests[i].abort();\n    }\n  }\n}\n\n}).call(this,typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"./polling\":18,\"component-emitter\":9,\"component-inherit\":21,\"debug\":22,\"xmlhttprequest\":20}],18:[function(_dereq_,module,exports){\n/**\n * Module dependencies.\n */\n\nvar Transport = _dereq_('../transport');\nvar parseqs = _dereq_('parseqs');\nvar parser = _dereq_('engine.io-parser');\nvar inherit = _dereq_('component-inherit');\nvar debug = _dereq_('debug')('engine.io-client:polling');\n\n/**\n * Module exports.\n */\n\nmodule.exports = Polling;\n\n/**\n * Is XHR2 supported?\n */\n\nvar hasXHR2 = (function() {\n  var XMLHttpRequest = _dereq_('xmlhttprequest');\n  var xhr = new XMLHttpRequest({ xdomain: false });\n  return null != xhr.responseType;\n})();\n\n/**\n * Polling interface.\n *\n * @param {Object} opts\n * @api private\n */\n\nfunction Polling(opts){\n  var forceBase64 = (opts && opts.forceBase64);\n  if (!hasXHR2 || forceBase64) {\n    this.supportsBinary = false;\n  }\n  Transport.call(this, opts);\n}\n\n/**\n * Inherits from Transport.\n */\n\ninherit(Polling, Transport);\n\n/**\n * Transport name.\n */\n\nPolling.prototype.name = 'polling';\n\n/**\n * Opens the socket (triggers polling). We write a PING message to determine\n * when the transport is open.\n *\n * @api private\n */\n\nPolling.prototype.doOpen = function(){\n  this.poll();\n};\n\n/**\n * Pauses polling.\n *\n * @param {Function} callback upon buffers are flushed and transport is paused\n * @api private\n */\n\nPolling.prototype.pause = function(onPause){\n  var pending = 0;\n  var self = this;\n\n  this.readyState = 'pausing';\n\n  function pause(){\n    debug('paused');\n    self.readyState = 'paused';\n    onPause();\n  }\n\n  if (this.polling || !this.writable) {\n    var total = 0;\n\n    if (this.polling) {\n      debug('we are currently polling - waiting to pause');\n      total++;\n      this.once('pollComplete', function(){\n        debug('pre-pause polling complete');\n        --total || pause();\n      });\n    }\n\n    if (!this.writable) {\n      debug('we are currently writing - waiting to pause');\n      total++;\n      this.once('drain', function(){\n        debug('pre-pause writing complete');\n        --total || pause();\n      });\n    }\n  } else {\n    pause();\n  }\n};\n\n/**\n * Starts polling cycle.\n *\n * @api public\n */\n\nPolling.prototype.poll = function(){\n  debug('polling');\n  this.polling = true;\n  this.doPoll();\n  this.emit('poll');\n};\n\n/**\n * Overloads onData to detect payloads.\n *\n * @api private\n */\n\nPolling.prototype.onData = function(data){\n  var self = this;\n  debug('polling got data %s', data);\n  var callback = function(packet, index, total) {\n    // if its the first message we consider the transport open\n    if ('opening' == self.readyState) {\n      self.onOpen();\n    }\n\n    // if its a close packet, we close the ongoing requests\n    if ('close' == packet.type) {\n      self.onClose();\n      return false;\n    }\n\n    // otherwise bypass onData and handle the message\n    self.onPacket(packet);\n  };\n\n  // decode payload\n  parser.decodePayload(data, this.socket.binaryType, callback);\n\n  // if an event did not trigger closing\n  if ('closed' != this.readyState) {\n    // if we got data we're not polling\n    this.polling = false;\n    this.emit('pollComplete');\n\n    if ('open' == this.readyState) {\n      this.poll();\n    } else {\n      debug('ignoring poll - transport state \"%s\"', this.readyState);\n    }\n  }\n};\n\n/**\n * For polling, send a close packet.\n *\n * @api private\n */\n\nPolling.prototype.doClose = function(){\n  var self = this;\n\n  function close(){\n    debug('writing close packet');\n    self.write([{ type: 'close' }]);\n  }\n\n  if ('open' == this.readyState) {\n    debug('transport open - closing');\n    close();\n  } else {\n    // in case we're trying to close while\n    // handshaking is in progress (GH-164)\n    debug('transport not open - deferring close');\n    this.once('open', close);\n  }\n};\n\n/**\n * Writes a packets payload.\n *\n * @param {Array} data packets\n * @param {Function} drain callback\n * @api private\n */\n\nPolling.prototype.write = function(packets){\n  var self = this;\n  this.writable = false;\n  var callbackfn = function() {\n    self.writable = true;\n    self.emit('drain');\n  };\n\n  var self = this;\n  parser.encodePayload(packets, this.supportsBinary, function(data) {\n    self.doWrite(data, callbackfn);\n  });\n};\n\n/**\n * Generates uri for connection.\n *\n * @api private\n */\n\nPolling.prototype.uri = function(){\n  var query = this.query || {};\n  var schema = this.secure ? 'https' : 'http';\n  var port = '';\n\n  // cache busting is forced\n  if (false !== this.timestampRequests) {\n    query[this.timestampParam] = +new Date + '-' + Transport.timestamps++;\n  }\n\n  if (!this.supportsBinary && !query.sid) {\n    query.b64 = 1;\n  }\n\n  query = parseqs.encode(query);\n\n  // avoid port if default for schema\n  if (this.port && (('https' == schema && this.port != 443) ||\n     ('http' == schema && this.port != 80))) {\n    port = ':' + this.port;\n  }\n\n  // prepend ? to query\n  if (query.length) {\n    query = '?' + query;\n  }\n\n  return schema + '://' + this.hostname + port + this.path + query;\n};\n\n},{\"../transport\":14,\"component-inherit\":21,\"debug\":22,\"engine.io-parser\":25,\"parseqs\":35,\"xmlhttprequest\":20}],19:[function(_dereq_,module,exports){\n/**\n * Module dependencies.\n */\n\nvar Transport = _dereq_('../transport');\nvar parser = _dereq_('engine.io-parser');\nvar parseqs = _dereq_('parseqs');\nvar inherit = _dereq_('component-inherit');\nvar debug = _dereq_('debug')('engine.io-client:websocket');\n\n/**\n * `ws` exposes a WebSocket-compatible interface in\n * Node, or the `WebSocket` or `MozWebSocket` globals\n * in the browser.\n */\n\nvar WebSocket = _dereq_('ws');\n\n/**\n * Module exports.\n */\n\nmodule.exports = WS;\n\n/**\n * WebSocket transport constructor.\n *\n * @api {Object} connection options\n * @api public\n */\n\nfunction WS(opts){\n  var forceBase64 = (opts && opts.forceBase64);\n  if (forceBase64) {\n    this.supportsBinary = false;\n  }\n  Transport.call(this, opts);\n}\n\n/**\n * Inherits from Transport.\n */\n\ninherit(WS, Transport);\n\n/**\n * Transport name.\n *\n * @api public\n */\n\nWS.prototype.name = 'websocket';\n\n/*\n * WebSockets support binary\n */\n\nWS.prototype.supportsBinary = true;\n\n/**\n * Opens socket.\n *\n * @api private\n */\n\nWS.prototype.doOpen = function(){\n  if (!this.check()) {\n    // let probe timeout\n    return;\n  }\n\n  var self = this;\n  var uri = this.uri();\n  var protocols = void(0);\n  var opts = { agent: this.agent };\n\n  // SSL options for Node.js client\n  opts.pfx = this.pfx;\n  opts.key = this.key;\n  opts.passphrase = this.passphrase;\n  opts.cert = this.cert;\n  opts.ca = this.ca;\n  opts.ciphers = this.ciphers;\n  opts.rejectUnauthorized = this.rejectUnauthorized;\n\n  this.ws = new WebSocket(uri, protocols, opts);\n\n  if (this.ws.binaryType === undefined) {\n    this.supportsBinary = false;\n  }\n\n  this.ws.binaryType = 'arraybuffer';\n  this.addEventListeners();\n};\n\n/**\n * Adds event listeners to the socket\n *\n * @api private\n */\n\nWS.prototype.addEventListeners = function(){\n  var self = this;\n\n  this.ws.onopen = function(){\n    self.onOpen();\n  };\n  this.ws.onclose = function(){\n    self.onClose();\n  };\n  this.ws.onmessage = function(ev){\n    self.onData(ev.data);\n  };\n  this.ws.onerror = function(e){\n    self.onError('websocket error', e);\n  };\n};\n\n/**\n * Override `onData` to use a timer on iOS.\n * See: https://gist.github.com/mloughran/2052006\n *\n * @api private\n */\n\nif ('undefined' != typeof navigator\n  && /iPad|iPhone|iPod/i.test(navigator.userAgent)) {\n  WS.prototype.onData = function(data){\n    var self = this;\n    setTimeout(function(){\n      Transport.prototype.onData.call(self, data);\n    }, 0);\n  };\n}\n\n/**\n * Writes data to socket.\n *\n * @param {Array} array of packets.\n * @api private\n */\n\nWS.prototype.write = function(packets){\n  var self = this;\n  this.writable = false;\n  // encodePacket efficient as it uses WS framing\n  // no need for encodePayload\n  for (var i = 0, l = packets.length; i < l; i++) {\n    parser.encodePacket(packets[i], this.supportsBinary, function(data) {\n      //Sometimes the websocket has already been closed but the browser didn't\n      //have a chance of informing us about it yet, in that case send will\n      //throw an error\n      try {\n        self.ws.send(data);\n      } catch (e){\n        debug('websocket closed before onclose event');\n      }\n    });\n  }\n\n  function ondrain() {\n    self.writable = true;\n    self.emit('drain');\n  }\n  // fake drain\n  // defer to next tick to allow Socket to clear writeBuffer\n  setTimeout(ondrain, 0);\n};\n\n/**\n * Called upon close\n *\n * @api private\n */\n\nWS.prototype.onClose = function(){\n  Transport.prototype.onClose.call(this);\n};\n\n/**\n * Closes socket.\n *\n * @api private\n */\n\nWS.prototype.doClose = function(){\n  if (typeof this.ws !== 'undefined') {\n    this.ws.close();\n  }\n};\n\n/**\n * Generates uri for connection.\n *\n * @api private\n */\n\nWS.prototype.uri = function(){\n  var query = this.query || {};\n  var schema = this.secure ? 'wss' : 'ws';\n  var port = '';\n\n  // avoid port if default for schema\n  if (this.port && (('wss' == schema && this.port != 443)\n    || ('ws' == schema && this.port != 80))) {\n    port = ':' + this.port;\n  }\n\n  // append timestamp to URI\n  if (this.timestampRequests) {\n    query[this.timestampParam] = +new Date;\n  }\n\n  // communicate binary support capabilities\n  if (!this.supportsBinary) {\n    query.b64 = 1;\n  }\n\n  query = parseqs.encode(query);\n\n  // prepend ? to query\n  if (query.length) {\n    query = '?' + query;\n  }\n\n  return schema + '://' + this.hostname + port + this.path + query;\n};\n\n/**\n * Feature detection for WebSocket.\n *\n * @return {Boolean} whether this transport is available.\n * @api public\n */\n\nWS.prototype.check = function(){\n  return !!WebSocket && !('__initialize' in WebSocket && this.name === WS.prototype.name);\n};\n\n},{\"../transport\":14,\"component-inherit\":21,\"debug\":22,\"engine.io-parser\":25,\"parseqs\":35,\"ws\":37}],20:[function(_dereq_,module,exports){\n// browser shim for xmlhttprequest module\nvar hasCORS = _dereq_('has-cors');\n\nmodule.exports = function(opts) {\n  var xdomain = opts.xdomain;\n\n  // scheme must be same when usign XDomainRequest\n  // http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx\n  var xscheme = opts.xscheme;\n\n  // XDomainRequest has a flow of not sending cookie, therefore it should be disabled as a default.\n  // https://github.com/Automattic/engine.io-client/pull/217\n  var enablesXDR = opts.enablesXDR;\n\n  // XMLHttpRequest can be disabled on IE\n  try {\n    if ('undefined' != typeof XMLHttpRequest && (!xdomain || hasCORS)) {\n      return new XMLHttpRequest();\n    }\n  } catch (e) { }\n\n  // Use XDomainRequest for IE8 if enablesXDR is true\n  // because loading bar keeps flashing when using jsonp-polling\n  // https://github.com/yujiosaka/socke.io-ie8-loading-example\n  try {\n    if ('undefined' != typeof XDomainRequest && !xscheme && enablesXDR) {\n      return new XDomainRequest();\n    }\n  } catch (e) { }\n\n  if (!xdomain) {\n    try {\n      return new ActiveXObject('Microsoft.XMLHTTP');\n    } catch(e) { }\n  }\n}\n\n},{\"has-cors\":40}],21:[function(_dereq_,module,exports){\n\nmodule.exports = function(a, b){\n  var fn = function(){};\n  fn.prototype = b.prototype;\n  a.prototype = new fn;\n  a.prototype.constructor = a;\n};\n},{}],22:[function(_dereq_,module,exports){\n\n/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = _dereq_('./debug');\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\n\n/**\n * Colors.\n */\n\nexports.colors = [\n  'lightseagreen',\n  'forestgreen',\n  'goldenrod',\n  'dodgerblue',\n  'darkorchid',\n  'crimson'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // is webkit? http://stackoverflow.com/a/16459606/376773\n  return ('WebkitAppearance' in document.documentElement.style) ||\n    // is firebug? http://stackoverflow.com/a/398120/376773\n    (window.console && (console.firebug || (console.exception && console.table))) ||\n    // is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    (navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31);\n}\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nexports.formatters.j = function(v) {\n  return JSON.stringify(v);\n};\n\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs() {\n  var args = arguments;\n  var useColors = this.useColors;\n\n  args[0] = (useColors ? '%c' : '')\n    + this.namespace\n    + (useColors ? ' %c' : ' ')\n    + args[0]\n    + (useColors ? '%c ' : ' ')\n    + '+' + exports.humanize(this.diff);\n\n  if (!useColors) return args;\n\n  var c = 'color: ' + this.color;\n  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));\n\n  // the final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-z%]/g, function(match) {\n    if ('%' === match) return;\n    index++;\n    if ('%c' === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n\n  args.splice(lastC, 0, c);\n  return args;\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\nfunction log() {\n  // This hackery is required for IE8,\n  // where the `console.log` function doesn't have 'apply'\n  return 'object' == typeof console\n    && 'function' == typeof console.log\n    && Function.prototype.apply.call(console.log, console, arguments);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      localStorage.removeItem('debug');\n    } else {\n      localStorage.debug = namespaces;\n    }\n  } catch(e) {}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  var r;\n  try {\n    r = localStorage.debug;\n  } catch(e) {}\n  return r;\n}\n\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\nexports.enable(load());\n\n},{\"./debug\":23}],23:[function(_dereq_,module,exports){\n\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = debug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = _dereq_('ms');\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lowercased letter, i.e. \"n\".\n */\n\nexports.formatters = {};\n\n/**\n * Previously assigned color.\n */\n\nvar prevColor = 0;\n\n/**\n * Previous log timestamp.\n */\n\nvar prevTime;\n\n/**\n * Select a color.\n *\n * @return {Number}\n * @api private\n */\n\nfunction selectColor() {\n  return exports.colors[prevColor++ % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction debug(namespace) {\n\n  // define the `disabled` version\n  function disabled() {\n  }\n  disabled.enabled = false;\n\n  // define the `enabled` version\n  function enabled() {\n\n    var self = enabled;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // add the `color` if not set\n    if (null == self.useColors) self.useColors = exports.useColors();\n    if (null == self.color && self.useColors) self.color = selectColor();\n\n    var args = Array.prototype.slice.call(arguments);\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %o\n      args = ['%o'].concat(args);\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    if ('function' === typeof exports.formatArgs) {\n      args = exports.formatArgs.apply(self, args);\n    }\n    var logFn = enabled.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n  enabled.enabled = true;\n\n  var fn = exports.enabled(namespace) ? enabled : disabled;\n\n  fn.namespace = namespace;\n\n  return fn;\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n\n  var split = (namespaces || '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (var i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n\n},{\"ms\":24}],24:[function(_dereq_,module,exports){\n/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} options\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options){\n  options = options || {};\n  if ('string' == typeof val) return parse(val);\n  return options.long\n    ? long(val)\n    : short(val);\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  var match = /^((?:\\d+)?\\.?\\d+) *(ms|seconds?|s|minutes?|m|hours?|h|days?|d|years?|y)?$/i.exec(str);\n  if (!match) return;\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'y':\n      return n * y;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 's':\n      return n * s;\n    case 'ms':\n      return n;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction short(ms) {\n  if (ms >= d) return Math.round(ms / d) + 'd';\n  if (ms >= h) return Math.round(ms / h) + 'h';\n  if (ms >= m) return Math.round(ms / m) + 'm';\n  if (ms >= s) return Math.round(ms / s) + 's';\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction long(ms) {\n  return plural(ms, d, 'day')\n    || plural(ms, h, 'hour')\n    || plural(ms, m, 'minute')\n    || plural(ms, s, 'second')\n    || ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms < n) return;\n  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;\n  return Math.ceil(ms / n) + ' ' + name + 's';\n}\n\n},{}],25:[function(_dereq_,module,exports){\n(function (global){\n/**\n * Module dependencies.\n */\n\nvar keys = _dereq_('./keys');\nvar hasBinary = _dereq_('has-binary');\nvar sliceBuffer = _dereq_('arraybuffer.slice');\nvar base64encoder = _dereq_('base64-arraybuffer');\nvar after = _dereq_('after');\nvar utf8 = _dereq_('utf8');\n\n/**\n * Check if we are running an android browser. That requires us to use\n * ArrayBuffer with polling transports...\n *\n * http://ghinda.net/jpeg-blob-ajax-android/\n */\n\nvar isAndroid = navigator.userAgent.match(/Android/i);\n\n/**\n * Check if we are running in PhantomJS.\n * Uploading a Blob with PhantomJS does not work correctly, as reported here:\n * https://github.com/ariya/phantomjs/issues/11395\n * @type boolean\n */\nvar isPhantomJS = /PhantomJS/i.test(navigator.userAgent);\n\n/**\n * When true, avoids using Blobs to encode payloads.\n * @type boolean\n */\nvar dontSendBlobs = isAndroid || isPhantomJS;\n\n/**\n * Current protocol version.\n */\n\nexports.protocol = 3;\n\n/**\n * Packet types.\n */\n\nvar packets = exports.packets = {\n    open:     0    // non-ws\n  , close:    1    // non-ws\n  , ping:     2\n  , pong:     3\n  , message:  4\n  , upgrade:  5\n  , noop:     6\n};\n\nvar packetslist = keys(packets);\n\n/**\n * Premade error packet.\n */\n\nvar err = { type: 'error', data: 'parser error' };\n\n/**\n * Create a blob api even for blob builder when vendor prefixes exist\n */\n\nvar Blob = _dereq_('blob');\n\n/**\n * Encodes a packet.\n *\n *     <packet type id> [ <data> ]\n *\n * Example:\n *\n *     5hello world\n *     3\n *     4\n *\n * Binary is encoded in an identical principle\n *\n * @api private\n */\n\nexports.encodePacket = function (packet, supportsBinary, utf8encode, callback) {\n  if ('function' == typeof supportsBinary) {\n    callback = supportsBinary;\n    supportsBinary = false;\n  }\n\n  if ('function' == typeof utf8encode) {\n    callback = utf8encode;\n    utf8encode = null;\n  }\n\n  var data = (packet.data === undefined)\n    ? undefined\n    : packet.data.buffer || packet.data;\n\n  if (global.ArrayBuffer && data instanceof ArrayBuffer) {\n    return encodeArrayBuffer(packet, supportsBinary, callback);\n  } else if (Blob && data instanceof global.Blob) {\n    return encodeBlob(packet, supportsBinary, callback);\n  }\n\n  // might be an object with { base64: true, data: dataAsBase64String }\n  if (data && data.base64) {\n    return encodeBase64Object(packet, callback);\n  }\n\n  // Sending data as a utf-8 string\n  var encoded = packets[packet.type];\n\n  // data fragment is optional\n  if (undefined !== packet.data) {\n    encoded += utf8encode ? utf8.encode(String(packet.data)) : String(packet.data);\n  }\n\n  return callback('' + encoded);\n\n};\n\nfunction encodeBase64Object(packet, callback) {\n  // packet data is an object { base64: true, data: dataAsBase64String }\n  var message = 'b' + exports.packets[packet.type] + packet.data.data;\n  return callback(message);\n}\n\n/**\n * Encode packet helpers for binary types\n */\n\nfunction encodeArrayBuffer(packet, supportsBinary, callback) {\n  if (!supportsBinary) {\n    return exports.encodeBase64Packet(packet, callback);\n  }\n\n  var data = packet.data;\n  var contentArray = new Uint8Array(data);\n  var resultBuffer = new Uint8Array(1 + data.byteLength);\n\n  resultBuffer[0] = packets[packet.type];\n  for (var i = 0; i < contentArray.length; i++) {\n    resultBuffer[i+1] = contentArray[i];\n  }\n\n  return callback(resultBuffer.buffer);\n}\n\nfunction encodeBlobAsArrayBuffer(packet, supportsBinary, callback) {\n  if (!supportsBinary) {\n    return exports.encodeBase64Packet(packet, callback);\n  }\n\n  var fr = new FileReader();\n  fr.onload = function() {\n    packet.data = fr.result;\n    exports.encodePacket(packet, supportsBinary, true, callback);\n  };\n  return fr.readAsArrayBuffer(packet.data);\n}\n\nfunction encodeBlob(packet, supportsBinary, callback) {\n  if (!supportsBinary) {\n    return exports.encodeBase64Packet(packet, callback);\n  }\n\n  if (dontSendBlobs) {\n    return encodeBlobAsArrayBuffer(packet, supportsBinary, callback);\n  }\n\n  var length = new Uint8Array(1);\n  length[0] = packets[packet.type];\n  var blob = new Blob([length.buffer, packet.data]);\n\n  return callback(blob);\n}\n\n/**\n * Encodes a packet with binary data in a base64 string\n *\n * @param {Object} packet, has `type` and `data`\n * @return {String} base64 encoded message\n */\n\nexports.encodeBase64Packet = function(packet, callback) {\n  var message = 'b' + exports.packets[packet.type];\n  if (Blob && packet.data instanceof Blob) {\n    var fr = new FileReader();\n    fr.onload = function() {\n      var b64 = fr.result.split(',')[1];\n      callback(message + b64);\n    };\n    return fr.readAsDataURL(packet.data);\n  }\n\n  var b64data;\n  try {\n    b64data = String.fromCharCode.apply(null, new Uint8Array(packet.data));\n  } catch (e) {\n    // iPhone Safari doesn't let you apply with typed arrays\n    var typed = new Uint8Array(packet.data);\n    var basic = new Array(typed.length);\n    for (var i = 0; i < typed.length; i++) {\n      basic[i] = typed[i];\n    }\n    b64data = String.fromCharCode.apply(null, basic);\n  }\n  message += global.btoa(b64data);\n  return callback(message);\n};\n\n/**\n * Decodes a packet. Changes format to Blob if requested.\n *\n * @return {Object} with `type` and `data` (if any)\n * @api private\n */\n\nexports.decodePacket = function (data, binaryType, utf8decode) {\n  // String data\n  if (typeof data == 'string' || data === undefined) {\n    if (data.charAt(0) == 'b') {\n      return exports.decodeBase64Packet(data.substr(1), binaryType);\n    }\n\n    if (utf8decode) {\n      try {\n        data = utf8.decode(data);\n      } catch (e) {\n        return err;\n      }\n    }\n    var type = data.charAt(0);\n\n    if (Number(type) != type || !packetslist[type]) {\n      return err;\n    }\n\n    if (data.length > 1) {\n      return { type: packetslist[type], data: data.substring(1) };\n    } else {\n      return { type: packetslist[type] };\n    }\n  }\n\n  var asArray = new Uint8Array(data);\n  var type = asArray[0];\n  var rest = sliceBuffer(data, 1);\n  if (Blob && binaryType === 'blob') {\n    rest = new Blob([rest]);\n  }\n  return { type: packetslist[type], data: rest };\n};\n\n/**\n * Decodes a packet encoded in a base64 string\n *\n * @param {String} base64 encoded message\n * @return {Object} with `type` and `data` (if any)\n */\n\nexports.decodeBase64Packet = function(msg, binaryType) {\n  var type = packetslist[msg.charAt(0)];\n  if (!global.ArrayBuffer) {\n    return { type: type, data: { base64: true, data: msg.substr(1) } };\n  }\n\n  var data = base64encoder.decode(msg.substr(1));\n\n  if (binaryType === 'blob' && Blob) {\n    data = new Blob([data]);\n  }\n\n  return { type: type, data: data };\n};\n\n/**\n * Encodes multiple messages (payload).\n *\n *     <length>:data\n *\n * Example:\n *\n *     11:hello world2:hi\n *\n * If any contents are binary, they will be encoded as base64 strings. Base64\n * encoded strings are marked with a b before the length specifier\n *\n * @param {Array} packets\n * @api private\n */\n\nexports.encodePayload = function (packets, supportsBinary, callback) {\n  if (typeof supportsBinary == 'function') {\n    callback = supportsBinary;\n    supportsBinary = null;\n  }\n\n  var isBinary = hasBinary(packets);\n\n  if (supportsBinary && isBinary) {\n    if (Blob && !dontSendBlobs) {\n      return exports.encodePayloadAsBlob(packets, callback);\n    }\n\n    return exports.encodePayloadAsArrayBuffer(packets, callback);\n  }\n\n  if (!packets.length) {\n    return callback('0:');\n  }\n\n  function setLengthHeader(message) {\n    return message.length + ':' + message;\n  }\n\n  function encodeOne(packet, doneCallback) {\n    exports.encodePacket(packet, !isBinary ? false : supportsBinary, true, function(message) {\n      doneCallback(null, setLengthHeader(message));\n    });\n  }\n\n  map(packets, encodeOne, function(err, results) {\n    return callback(results.join(''));\n  });\n};\n\n/**\n * Async array map using after\n */\n\nfunction map(ary, each, done) {\n  var result = new Array(ary.length);\n  var next = after(ary.length, done);\n\n  var eachWithIndex = function(i, el, cb) {\n    each(el, function(error, msg) {\n      result[i] = msg;\n      cb(error, result);\n    });\n  };\n\n  for (var i = 0; i < ary.length; i++) {\n    eachWithIndex(i, ary[i], next);\n  }\n}\n\n/*\n * Decodes data when a payload is maybe expected. Possible binary contents are\n * decoded from their base64 representation\n *\n * @param {String} data, callback method\n * @api public\n */\n\nexports.decodePayload = function (data, binaryType, callback) {\n  if (typeof data != 'string') {\n    return exports.decodePayloadAsBinary(data, binaryType, callback);\n  }\n\n  if (typeof binaryType === 'function') {\n    callback = binaryType;\n    binaryType = null;\n  }\n\n  var packet;\n  if (data == '') {\n    // parser error - ignoring payload\n    return callback(err, 0, 1);\n  }\n\n  var length = ''\n    , n, msg;\n\n  for (var i = 0, l = data.length; i < l; i++) {\n    var chr = data.charAt(i);\n\n    if (':' != chr) {\n      length += chr;\n    } else {\n      if ('' == length || (length != (n = Number(length)))) {\n        // parser error - ignoring payload\n        return callback(err, 0, 1);\n      }\n\n      msg = data.substr(i + 1, n);\n\n      if (length != msg.length) {\n        // parser error - ignoring payload\n        return callback(err, 0, 1);\n      }\n\n      if (msg.length) {\n        packet = exports.decodePacket(msg, binaryType, true);\n\n        if (err.type == packet.type && err.data == packet.data) {\n          // parser error in individual packet - ignoring payload\n          return callback(err, 0, 1);\n        }\n\n        var ret = callback(packet, i + n, l);\n        if (false === ret) return;\n      }\n\n      // advance cursor\n      i += n;\n      length = '';\n    }\n  }\n\n  if (length != '') {\n    // parser error - ignoring payload\n    return callback(err, 0, 1);\n  }\n\n};\n\n/**\n * Encodes multiple messages (payload) as binary.\n *\n * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number\n * 255><data>\n *\n * Example:\n * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers\n *\n * @param {Array} packets\n * @return {ArrayBuffer} encoded payload\n * @api private\n */\n\nexports.encodePayloadAsArrayBuffer = function(packets, callback) {\n  if (!packets.length) {\n    return callback(new ArrayBuffer(0));\n  }\n\n  function encodeOne(packet, doneCallback) {\n    exports.encodePacket(packet, true, true, function(data) {\n      return doneCallback(null, data);\n    });\n  }\n\n  map(packets, encodeOne, function(err, encodedPackets) {\n    var totalLength = encodedPackets.reduce(function(acc, p) {\n      var len;\n      if (typeof p === 'string'){\n        len = p.length;\n      } else {\n        len = p.byteLength;\n      }\n      return acc + len.toString().length + len + 2; // string/binary identifier + separator = 2\n    }, 0);\n\n    var resultArray = new Uint8Array(totalLength);\n\n    var bufferIndex = 0;\n    encodedPackets.forEach(function(p) {\n      var isString = typeof p === 'string';\n      var ab = p;\n      if (isString) {\n        var view = new Uint8Array(p.length);\n        for (var i = 0; i < p.length; i++) {\n          view[i] = p.charCodeAt(i);\n        }\n        ab = view.buffer;\n      }\n\n      if (isString) { // not true binary\n        resultArray[bufferIndex++] = 0;\n      } else { // true binary\n        resultArray[bufferIndex++] = 1;\n      }\n\n      var lenStr = ab.byteLength.toString();\n      for (var i = 0; i < lenStr.length; i++) {\n        resultArray[bufferIndex++] = parseInt(lenStr[i]);\n      }\n      resultArray[bufferIndex++] = 255;\n\n      var view = new Uint8Array(ab);\n      for (var i = 0; i < view.length; i++) {\n        resultArray[bufferIndex++] = view[i];\n      }\n    });\n\n    return callback(resultArray.buffer);\n  });\n};\n\n/**\n * Encode as Blob\n */\n\nexports.encodePayloadAsBlob = function(packets, callback) {\n  function encodeOne(packet, doneCallback) {\n    exports.encodePacket(packet, true, true, function(encoded) {\n      var binaryIdentifier = new Uint8Array(1);\n      binaryIdentifier[0] = 1;\n      if (typeof encoded === 'string') {\n        var view = new Uint8Array(encoded.length);\n        for (var i = 0; i < encoded.length; i++) {\n          view[i] = encoded.charCodeAt(i);\n        }\n        encoded = view.buffer;\n        binaryIdentifier[0] = 0;\n      }\n\n      var len = (encoded instanceof ArrayBuffer)\n        ? encoded.byteLength\n        : encoded.size;\n\n      var lenStr = len.toString();\n      var lengthAry = new Uint8Array(lenStr.length + 1);\n      for (var i = 0; i < lenStr.length; i++) {\n        lengthAry[i] = parseInt(lenStr[i]);\n      }\n      lengthAry[lenStr.length] = 255;\n\n      if (Blob) {\n        var blob = new Blob([binaryIdentifier.buffer, lengthAry.buffer, encoded]);\n        doneCallback(null, blob);\n      }\n    });\n  }\n\n  map(packets, encodeOne, function(err, results) {\n    return callback(new Blob(results));\n  });\n};\n\n/*\n * Decodes data when a payload is maybe expected. Strings are decoded by\n * interpreting each byte as a key code for entries marked to start with 0. See\n * description of encodePayloadAsBinary\n *\n * @param {ArrayBuffer} data, callback method\n * @api public\n */\n\nexports.decodePayloadAsBinary = function (data, binaryType, callback) {\n  if (typeof binaryType === 'function') {\n    callback = binaryType;\n    binaryType = null;\n  }\n\n  var bufferTail = data;\n  var buffers = [];\n\n  var numberTooLong = false;\n  while (bufferTail.byteLength > 0) {\n    var tailArray = new Uint8Array(bufferTail);\n    var isString = tailArray[0] === 0;\n    var msgLength = '';\n\n    for (var i = 1; ; i++) {\n      if (tailArray[i] == 255) break;\n\n      if (msgLength.length > 310) {\n        numberTooLong = true;\n        break;\n      }\n\n      msgLength += tailArray[i];\n    }\n\n    if(numberTooLong) return callback(err, 0, 1);\n\n    bufferTail = sliceBuffer(bufferTail, 2 + msgLength.length);\n    msgLength = parseInt(msgLength);\n\n    var msg = sliceBuffer(bufferTail, 0, msgLength);\n    if (isString) {\n      try {\n        msg = String.fromCharCode.apply(null, new Uint8Array(msg));\n      } catch (e) {\n        // iPhone Safari doesn't let you apply to typed arrays\n        var typed = new Uint8Array(msg);\n        msg = '';\n        for (var i = 0; i < typed.length; i++) {\n          msg += String.fromCharCode(typed[i]);\n        }\n      }\n    }\n\n    buffers.push(msg);\n    bufferTail = sliceBuffer(bufferTail, msgLength);\n  }\n\n  var total = buffers.length;\n  buffers.forEach(function(buffer, i) {\n    callback(exports.decodePacket(buffer, binaryType, true), i, total);\n  });\n};\n\n}).call(this,typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"./keys\":26,\"after\":27,\"arraybuffer.slice\":28,\"base64-arraybuffer\":29,\"blob\":30,\"has-binary\":31,\"utf8\":33}],26:[function(_dereq_,module,exports){\n\n/**\n * Gets the keys for an object.\n *\n * @return {Array} keys\n * @api private\n */\n\nmodule.exports = Object.keys || function keys (obj){\n  var arr = [];\n  var has = Object.prototype.hasOwnProperty;\n\n  for (var i in obj) {\n    if (has.call(obj, i)) {\n      arr.push(i);\n    }\n  }\n  return arr;\n};\n\n},{}],27:[function(_dereq_,module,exports){\nmodule.exports = after\n\nfunction after(count, callback, err_cb) {\n    var bail = false\n    err_cb = err_cb || noop\n    proxy.count = count\n\n    return (count === 0) ? callback() : proxy\n\n    function proxy(err, result) {\n        if (proxy.count <= 0) {\n            throw new Error('after called too many times')\n        }\n        --proxy.count\n\n        // after first error, rest are passed to err_cb\n        if (err) {\n            bail = true\n            callback(err)\n            // future error callbacks will go to error handler\n            callback = err_cb\n        } else if (proxy.count === 0 && !bail) {\n            callback(null, result)\n        }\n    }\n}\n\nfunction noop() {}\n\n},{}],28:[function(_dereq_,module,exports){\n/**\n * An abstraction for slicing an arraybuffer even when\n * ArrayBuffer.prototype.slice is not supported\n *\n * @api public\n */\n\nmodule.exports = function(arraybuffer, start, end) {\n  var bytes = arraybuffer.byteLength;\n  start = start || 0;\n  end = end || bytes;\n\n  if (arraybuffer.slice) { return arraybuffer.slice(start, end); }\n\n  if (start < 0) { start += bytes; }\n  if (end < 0) { end += bytes; }\n  if (end > bytes) { end = bytes; }\n\n  if (start >= bytes || start >= end || bytes === 0) {\n    return new ArrayBuffer(0);\n  }\n\n  var abv = new Uint8Array(arraybuffer);\n  var result = new Uint8Array(end - start);\n  for (var i = start, ii = 0; i < end; i++, ii++) {\n    result[ii] = abv[i];\n  }\n  return result.buffer;\n};\n\n},{}],29:[function(_dereq_,module,exports){\n/*\n * base64-arraybuffer\n * https://github.com/niklasvh/base64-arraybuffer\n *\n * Copyright (c) 2012 Niklas von Hertzen\n * Licensed under the MIT license.\n */\n(function(chars){\n  \"use strict\";\n\n  exports.encode = function(arraybuffer) {\n    var bytes = new Uint8Array(arraybuffer),\n    i, len = bytes.length, base64 = \"\";\n\n    for (i = 0; i < len; i+=3) {\n      base64 += chars[bytes[i] >> 2];\n      base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];\n      base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];\n      base64 += chars[bytes[i + 2] & 63];\n    }\n\n    if ((len % 3) === 2) {\n      base64 = base64.substring(0, base64.length - 1) + \"=\";\n    } else if (len % 3 === 1) {\n      base64 = base64.substring(0, base64.length - 2) + \"==\";\n    }\n\n    return base64;\n  };\n\n  exports.decode =  function(base64) {\n    var bufferLength = base64.length * 0.75,\n    len = base64.length, i, p = 0,\n    encoded1, encoded2, encoded3, encoded4;\n\n    if (base64[base64.length - 1] === \"=\") {\n      bufferLength--;\n      if (base64[base64.length - 2] === \"=\") {\n        bufferLength--;\n      }\n    }\n\n    var arraybuffer = new ArrayBuffer(bufferLength),\n    bytes = new Uint8Array(arraybuffer);\n\n    for (i = 0; i < len; i+=4) {\n      encoded1 = chars.indexOf(base64[i]);\n      encoded2 = chars.indexOf(base64[i+1]);\n      encoded3 = chars.indexOf(base64[i+2]);\n      encoded4 = chars.indexOf(base64[i+3]);\n\n      bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);\n      bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);\n      bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);\n    }\n\n    return arraybuffer;\n  };\n})(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\");\n\n},{}],30:[function(_dereq_,module,exports){\n(function (global){\n/**\n * Create a blob builder even when vendor prefixes exist\n */\n\nvar BlobBuilder = global.BlobBuilder\n  || global.WebKitBlobBuilder\n  || global.MSBlobBuilder\n  || global.MozBlobBuilder;\n\n/**\n * Check if Blob constructor is supported\n */\n\nvar blobSupported = (function() {\n  try {\n    var b = new Blob(['hi']);\n    return b.size == 2;\n  } catch(e) {\n    return false;\n  }\n})();\n\n/**\n * Check if BlobBuilder is supported\n */\n\nvar blobBuilderSupported = BlobBuilder\n  && BlobBuilder.prototype.append\n  && BlobBuilder.prototype.getBlob;\n\nfunction BlobBuilderConstructor(ary, options) {\n  options = options || {};\n\n  var bb = new BlobBuilder();\n  for (var i = 0; i < ary.length; i++) {\n    bb.append(ary[i]);\n  }\n  return (options.type) ? bb.getBlob(options.type) : bb.getBlob();\n};\n\nmodule.exports = (function() {\n  if (blobSupported) {\n    return global.Blob;\n  } else if (blobBuilderSupported) {\n    return BlobBuilderConstructor;\n  } else {\n    return undefined;\n  }\n})();\n\n}).call(this,typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}],31:[function(_dereq_,module,exports){\n(function (global){\n\n/*\n * Module requirements.\n */\n\nvar isArray = _dereq_('isarray');\n\n/**\n * Module exports.\n */\n\nmodule.exports = hasBinary;\n\n/**\n * Checks for binary data.\n *\n * Right now only Buffer and ArrayBuffer are supported..\n *\n * @param {Object} anything\n * @api public\n */\n\nfunction hasBinary(data) {\n\n  function _hasBinary(obj) {\n    if (!obj) return false;\n\n    if ( (global.Buffer && global.Buffer.isBuffer(obj)) ||\n         (global.ArrayBuffer && obj instanceof ArrayBuffer) ||\n         (global.Blob && obj instanceof Blob) ||\n         (global.File && obj instanceof File)\n        ) {\n      return true;\n    }\n\n    if (isArray(obj)) {\n      for (var i = 0; i < obj.length; i++) {\n          if (_hasBinary(obj[i])) {\n              return true;\n          }\n      }\n    } else if (obj && 'object' == typeof obj) {\n      if (obj.toJSON) {\n        obj = obj.toJSON();\n      }\n\n      for (var key in obj) {\n        if (obj.hasOwnProperty(key) && _hasBinary(obj[key])) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  return _hasBinary(data);\n}\n\n}).call(this,typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"isarray\":32}],32:[function(_dereq_,module,exports){\nmodule.exports = Array.isArray || function (arr) {\n  return Object.prototype.toString.call(arr) == '[object Array]';\n};\n\n},{}],33:[function(_dereq_,module,exports){\n(function (global){\n/*! http://mths.be/utf8js v2.0.0 by @mathias */\n;(function(root) {\n\n\t// Detect free variables `exports`\n\tvar freeExports = typeof exports == 'object' && exports;\n\n\t// Detect free variable `module`\n\tvar freeModule = typeof module == 'object' && module &&\n\t\tmodule.exports == freeExports && module;\n\n\t// Detect free variable `global`, from Node.js or Browserified code,\n\t// and use it as `root`\n\tvar freeGlobal = typeof global == 'object' && global;\n\tif (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {\n\t\troot = freeGlobal;\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\tvar stringFromCharCode = String.fromCharCode;\n\n\t// Taken from http://mths.be/punycode\n\tfunction ucs2decode(string) {\n\t\tvar output = [];\n\t\tvar counter = 0;\n\t\tvar length = string.length;\n\t\tvar value;\n\t\tvar extra;\n\t\twhile (counter < length) {\n\t\t\tvalue = string.charCodeAt(counter++);\n\t\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t\t// high surrogate, and there is a next character\n\t\t\t\textra = string.charCodeAt(counter++);\n\t\t\t\tif ((extra & 0xFC00) == 0xDC00) { // low surrogate\n\t\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t\t} else {\n\t\t\t\t\t// unmatched surrogate; only append this code unit, in case the next\n\t\t\t\t\t// code unit is the high surrogate of a surrogate pair\n\t\t\t\t\toutput.push(value);\n\t\t\t\t\tcounter--;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toutput.push(value);\n\t\t\t}\n\t\t}\n\t\treturn output;\n\t}\n\n\t// Taken from http://mths.be/punycode\n\tfunction ucs2encode(array) {\n\t\tvar length = array.length;\n\t\tvar index = -1;\n\t\tvar value;\n\t\tvar output = '';\n\t\twhile (++index < length) {\n\t\t\tvalue = array[index];\n\t\t\tif (value > 0xFFFF) {\n\t\t\t\tvalue -= 0x10000;\n\t\t\t\toutput += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n\t\t\t\tvalue = 0xDC00 | value & 0x3FF;\n\t\t\t}\n\t\t\toutput += stringFromCharCode(value);\n\t\t}\n\t\treturn output;\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\tfunction createByte(codePoint, shift) {\n\t\treturn stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);\n\t}\n\n\tfunction encodeCodePoint(codePoint) {\n\t\tif ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence\n\t\t\treturn stringFromCharCode(codePoint);\n\t\t}\n\t\tvar symbol = '';\n\t\tif ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence\n\t\t\tsymbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);\n\t\t}\n\t\telse if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence\n\t\t\tsymbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);\n\t\t\tsymbol += createByte(codePoint, 6);\n\t\t}\n\t\telse if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence\n\t\t\tsymbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);\n\t\t\tsymbol += createByte(codePoint, 12);\n\t\t\tsymbol += createByte(codePoint, 6);\n\t\t}\n\t\tsymbol += stringFromCharCode((codePoint & 0x3F) | 0x80);\n\t\treturn symbol;\n\t}\n\n\tfunction utf8encode(string) {\n\t\tvar codePoints = ucs2decode(string);\n\n\t\t// console.log(JSON.stringify(codePoints.map(function(x) {\n\t\t// \treturn 'U+' + x.toString(16).toUpperCase();\n\t\t// })));\n\n\t\tvar length = codePoints.length;\n\t\tvar index = -1;\n\t\tvar codePoint;\n\t\tvar byteString = '';\n\t\twhile (++index < length) {\n\t\t\tcodePoint = codePoints[index];\n\t\t\tbyteString += encodeCodePoint(codePoint);\n\t\t}\n\t\treturn byteString;\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\tfunction readContinuationByte() {\n\t\tif (byteIndex >= byteCount) {\n\t\t\tthrow Error('Invalid byte index');\n\t\t}\n\n\t\tvar continuationByte = byteArray[byteIndex] & 0xFF;\n\t\tbyteIndex++;\n\n\t\tif ((continuationByte & 0xC0) == 0x80) {\n\t\t\treturn continuationByte & 0x3F;\n\t\t}\n\n\t\t// If we end up here, it’s not a continuation byte\n\t\tthrow Error('Invalid continuation byte');\n\t}\n\n\tfunction decodeSymbol() {\n\t\tvar byte1;\n\t\tvar byte2;\n\t\tvar byte3;\n\t\tvar byte4;\n\t\tvar codePoint;\n\n\t\tif (byteIndex > byteCount) {\n\t\t\tthrow Error('Invalid byte index');\n\t\t}\n\n\t\tif (byteIndex == byteCount) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Read first byte\n\t\tbyte1 = byteArray[byteIndex] & 0xFF;\n\t\tbyteIndex++;\n\n\t\t// 1-byte sequence (no continuation bytes)\n\t\tif ((byte1 & 0x80) == 0) {\n\t\t\treturn byte1;\n\t\t}\n\n\t\t// 2-byte sequence\n\t\tif ((byte1 & 0xE0) == 0xC0) {\n\t\t\tvar byte2 = readContinuationByte();\n\t\t\tcodePoint = ((byte1 & 0x1F) << 6) | byte2;\n\t\t\tif (codePoint >= 0x80) {\n\t\t\t\treturn codePoint;\n\t\t\t} else {\n\t\t\t\tthrow Error('Invalid continuation byte');\n\t\t\t}\n\t\t}\n\n\t\t// 3-byte sequence (may include unpaired surrogates)\n\t\tif ((byte1 & 0xF0) == 0xE0) {\n\t\t\tbyte2 = readContinuationByte();\n\t\t\tbyte3 = readContinuationByte();\n\t\t\tcodePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;\n\t\t\tif (codePoint >= 0x0800) {\n\t\t\t\treturn codePoint;\n\t\t\t} else {\n\t\t\t\tthrow Error('Invalid continuation byte');\n\t\t\t}\n\t\t}\n\n\t\t// 4-byte sequence\n\t\tif ((byte1 & 0xF8) == 0xF0) {\n\t\t\tbyte2 = readContinuationByte();\n\t\t\tbyte3 = readContinuationByte();\n\t\t\tbyte4 = readContinuationByte();\n\t\t\tcodePoint = ((byte1 & 0x0F) << 0x12) | (byte2 << 0x0C) |\n\t\t\t\t(byte3 << 0x06) | byte4;\n\t\t\tif (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {\n\t\t\t\treturn codePoint;\n\t\t\t}\n\t\t}\n\n\t\tthrow Error('Invalid UTF-8 detected');\n\t}\n\n\tvar byteArray;\n\tvar byteCount;\n\tvar byteIndex;\n\tfunction utf8decode(byteString) {\n\t\tbyteArray = ucs2decode(byteString);\n\t\tbyteCount = byteArray.length;\n\t\tbyteIndex = 0;\n\t\tvar codePoints = [];\n\t\tvar tmp;\n\t\twhile ((tmp = decodeSymbol()) !== false) {\n\t\t\tcodePoints.push(tmp);\n\t\t}\n\t\treturn ucs2encode(codePoints);\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\tvar utf8 = {\n\t\t'version': '2.0.0',\n\t\t'encode': utf8encode,\n\t\t'decode': utf8decode\n\t};\n\n\t// Some AMD build optimizers, like r.js, check for specific condition patterns\n\t// like the following:\n\tif (\n\t\ttypeof define == 'function' &&\n\t\ttypeof define.amd == 'object' &&\n\t\tdefine.amd\n\t) {\n\t\tdefine(function() {\n\t\t\treturn utf8;\n\t\t});\n\t}\telse if (freeExports && !freeExports.nodeType) {\n\t\tif (freeModule) { // in Node.js or RingoJS v0.8.0+\n\t\t\tfreeModule.exports = utf8;\n\t\t} else { // in Narwhal or RingoJS v0.7.0-\n\t\t\tvar object = {};\n\t\t\tvar hasOwnProperty = object.hasOwnProperty;\n\t\t\tfor (var key in utf8) {\n\t\t\t\thasOwnProperty.call(utf8, key) && (freeExports[key] = utf8[key]);\n\t\t\t}\n\t\t}\n\t} else { // in Rhino or a web browser\n\t\troot.utf8 = utf8;\n\t}\n\n}(this));\n\n}).call(this,typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}],34:[function(_dereq_,module,exports){\n(function (global){\n/**\n * JSON parse.\n *\n * @see Based on jQuery#parseJSON (MIT) and JSON2\n * @api private\n */\n\nvar rvalidchars = /^[\\],:{}\\s]*$/;\nvar rvalidescape = /\\\\(?:[\"\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/g;\nvar rvalidtokens = /\"[^\"\\\\\\n\\r]*\"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g;\nvar rvalidbraces = /(?:^|:|,)(?:\\s*\\[)+/g;\nvar rtrimLeft = /^\\s+/;\nvar rtrimRight = /\\s+$/;\n\nmodule.exports = function parsejson(data) {\n  if ('string' != typeof data || !data) {\n    return null;\n  }\n\n  data = data.replace(rtrimLeft, '').replace(rtrimRight, '');\n\n  // Attempt to parse using the native JSON parser first\n  if (global.JSON && JSON.parse) {\n    return JSON.parse(data);\n  }\n\n  if (rvalidchars.test(data.replace(rvalidescape, '@')\n      .replace(rvalidtokens, ']')\n      .replace(rvalidbraces, ''))) {\n    return (new Function('return ' + data))();\n  }\n};\n}).call(this,typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}],35:[function(_dereq_,module,exports){\n/**\n * Compiles a querystring\n * Returns string representation of the object\n *\n * @param {Object}\n * @api private\n */\n\nexports.encode = function (obj) {\n  var str = '';\n\n  for (var i in obj) {\n    if (obj.hasOwnProperty(i)) {\n      if (str.length) str += '&';\n      str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);\n    }\n  }\n\n  return str;\n};\n\n/**\n * Parses a simple querystring into an object\n *\n * @param {String} qs\n * @api private\n */\n\nexports.decode = function(qs){\n  var qry = {};\n  var pairs = qs.split('&');\n  for (var i = 0, l = pairs.length; i < l; i++) {\n    var pair = pairs[i].split('=');\n    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);\n  }\n  return qry;\n};\n\n},{}],36:[function(_dereq_,module,exports){\n/**\n * Parses an URI\n *\n * @author Steven Levithan <stevenlevithan.com> (MIT license)\n * @api private\n */\n\nvar re = /^(?:(?![^:@]+:[^:@\\/]*@)(http|https|ws|wss):\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/;\n\nvar parts = [\n    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'\n];\n\nmodule.exports = function parseuri(str) {\n    var src = str,\n        b = str.indexOf('['),\n        e = str.indexOf(']');\n\n    if (b != -1 && e != -1) {\n        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);\n    }\n\n    var m = re.exec(str || ''),\n        uri = {},\n        i = 14;\n\n    while (i--) {\n        uri[parts[i]] = m[i] || '';\n    }\n\n    if (b != -1 && e != -1) {\n        uri.source = src;\n        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');\n        uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');\n        uri.ipv6uri = true;\n    }\n\n    return uri;\n};\n\n},{}],37:[function(_dereq_,module,exports){\n\n/**\n * Module dependencies.\n */\n\nvar global = (function() { return this; })();\n\n/**\n * WebSocket constructor.\n */\n\nvar WebSocket = global.WebSocket || global.MozWebSocket;\n\n/**\n * Module exports.\n */\n\nmodule.exports = WebSocket ? ws : null;\n\n/**\n * WebSocket constructor.\n *\n * The third `opts` options object gets ignored in web browsers, since it's\n * non-standard, and throws a TypeError if passed to the constructor.\n * See: https://github.com/einaros/ws/issues/227\n *\n * @param {String} uri\n * @param {Array} protocols (optional)\n * @param {Object) opts (optional)\n * @api public\n */\n\nfunction ws(uri, protocols, opts) {\n  var instance;\n  if (protocols) {\n    instance = new WebSocket(uri, protocols);\n  } else {\n    instance = new WebSocket(uri);\n  }\n  return instance;\n}\n\nif (WebSocket) ws.prototype = WebSocket.prototype;\n\n},{}],38:[function(_dereq_,module,exports){\n(function (global){\n\n/*\n * Module requirements.\n */\n\nvar isArray = _dereq_('isarray');\n\n/**\n * Module exports.\n */\n\nmodule.exports = hasBinary;\n\n/**\n * Checks for binary data.\n *\n * Right now only Buffer and ArrayBuffer are supported..\n *\n * @param {Object} anything\n * @api public\n */\n\nfunction hasBinary(data) {\n\n  function _hasBinary(obj) {\n    if (!obj) return false;\n\n    if ( (global.Buffer && global.Buffer.isBuffer(obj)) ||\n         (global.ArrayBuffer && obj instanceof ArrayBuffer) ||\n         (global.Blob && obj instanceof Blob) ||\n         (global.File && obj instanceof File)\n        ) {\n      return true;\n    }\n\n    if (isArray(obj)) {\n      for (var i = 0; i < obj.length; i++) {\n          if (_hasBinary(obj[i])) {\n              return true;\n          }\n      }\n    } else if (obj && 'object' == typeof obj) {\n      if (obj.toJSON) {\n        obj = obj.toJSON();\n      }\n\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key) && _hasBinary(obj[key])) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  return _hasBinary(data);\n}\n\n}).call(this,typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"isarray\":39}],39:[function(_dereq_,module,exports){\nmodule.exports=_dereq_(32)\n},{}],40:[function(_dereq_,module,exports){\n\n/**\n * Module dependencies.\n */\n\nvar global = _dereq_('global');\n\n/**\n * Module exports.\n *\n * Logic borrowed from Modernizr:\n *\n *   - https://github.com/Modernizr/Modernizr/blob/master/feature-detects/cors.js\n */\n\ntry {\n  module.exports = 'XMLHttpRequest' in global &&\n    'withCredentials' in new global.XMLHttpRequest();\n} catch (err) {\n  // if XMLHttp support is disabled in IE then it will throw\n  // when trying to create\n  module.exports = false;\n}\n\n},{\"global\":41}],41:[function(_dereq_,module,exports){\n\n/**\n * Returns `this`. Execute this without a \"context\" (i.e. without it being\n * attached to an object of the left-hand side), and `this` points to the\n * \"global\" scope of the current JS execution.\n */\n\nmodule.exports = (function () { return this; })();\n\n},{}],42:[function(_dereq_,module,exports){\n\nvar indexOf = [].indexOf;\n\nmodule.exports = function(arr, obj){\n  if (indexOf) return arr.indexOf(obj);\n  for (var i = 0; i < arr.length; ++i) {\n    if (arr[i] === obj) return i;\n  }\n  return -1;\n};\n},{}],43:[function(_dereq_,module,exports){\n\n/**\n * HOP ref.\n */\n\nvar has = Object.prototype.hasOwnProperty;\n\n/**\n * Return own keys in `obj`.\n *\n * @param {Object} obj\n * @return {Array}\n * @api public\n */\n\nexports.keys = Object.keys || function(obj){\n  var keys = [];\n  for (var key in obj) {\n    if (has.call(obj, key)) {\n      keys.push(key);\n    }\n  }\n  return keys;\n};\n\n/**\n * Return own values in `obj`.\n *\n * @param {Object} obj\n * @return {Array}\n * @api public\n */\n\nexports.values = function(obj){\n  var vals = [];\n  for (var key in obj) {\n    if (has.call(obj, key)) {\n      vals.push(obj[key]);\n    }\n  }\n  return vals;\n};\n\n/**\n * Merge `b` into `a`.\n *\n * @param {Object} a\n * @param {Object} b\n * @return {Object} a\n * @api public\n */\n\nexports.merge = function(a, b){\n  for (var key in b) {\n    if (has.call(b, key)) {\n      a[key] = b[key];\n    }\n  }\n  return a;\n};\n\n/**\n * Return length of `obj`.\n *\n * @param {Object} obj\n * @return {Number}\n * @api public\n */\n\nexports.length = function(obj){\n  return exports.keys(obj).length;\n};\n\n/**\n * Check if `obj` is empty.\n *\n * @param {Object} obj\n * @return {Boolean}\n * @api public\n */\n\nexports.isEmpty = function(obj){\n  return 0 == exports.length(obj);\n};\n},{}],44:[function(_dereq_,module,exports){\n/**\n * Parses an URI\n *\n * @author Steven Levithan <stevenlevithan.com> (MIT license)\n * @api private\n */\n\nvar re = /^(?:(?![^:@]+:[^:@\\/]*@)(http|https|ws|wss):\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/;\n\nvar parts = [\n    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host'\n  , 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'\n];\n\nmodule.exports = function parseuri(str) {\n  var m = re.exec(str || '')\n    , uri = {}\n    , i = 14;\n\n  while (i--) {\n    uri[parts[i]] = m[i] || '';\n  }\n\n  return uri;\n};\n\n},{}],45:[function(_dereq_,module,exports){\n(function (global){\n/*global Blob,File*/\n\n/**\n * Module requirements\n */\n\nvar isArray = _dereq_('isarray');\nvar isBuf = _dereq_('./is-buffer');\n\n/**\n * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder.\n * Anything with blobs or files should be fed through removeBlobs before coming\n * here.\n *\n * @param {Object} packet - socket.io event packet\n * @return {Object} with deconstructed packet and list of buffers\n * @api public\n */\n\nexports.deconstructPacket = function(packet){\n  var buffers = [];\n  var packetData = packet.data;\n\n  function _deconstructPacket(data) {\n    if (!data) return data;\n\n    if (isBuf(data)) {\n      var placeholder = { _placeholder: true, num: buffers.length };\n      buffers.push(data);\n      return placeholder;\n    } else if (isArray(data)) {\n      var newData = new Array(data.length);\n      for (var i = 0; i < data.length; i++) {\n        newData[i] = _deconstructPacket(data[i]);\n      }\n      return newData;\n    } else if ('object' == typeof data && !(data instanceof Date)) {\n      var newData = {};\n      for (var key in data) {\n        newData[key] = _deconstructPacket(data[key]);\n      }\n      return newData;\n    }\n    return data;\n  }\n\n  var pack = packet;\n  pack.data = _deconstructPacket(packetData);\n  pack.attachments = buffers.length; // number of binary 'attachments'\n  return {packet: pack, buffers: buffers};\n};\n\n/**\n * Reconstructs a binary packet from its placeholder packet and buffers\n *\n * @param {Object} packet - event packet with placeholders\n * @param {Array} buffers - binary buffers to put in placeholder positions\n * @return {Object} reconstructed packet\n * @api public\n */\n\nexports.reconstructPacket = function(packet, buffers) {\n  var curPlaceHolder = 0;\n\n  function _reconstructPacket(data) {\n    if (data && data._placeholder) {\n      var buf = buffers[data.num]; // appropriate buffer (should be natural order anyway)\n      return buf;\n    } else if (isArray(data)) {\n      for (var i = 0; i < data.length; i++) {\n        data[i] = _reconstructPacket(data[i]);\n      }\n      return data;\n    } else if (data && 'object' == typeof data) {\n      for (var key in data) {\n        data[key] = _reconstructPacket(data[key]);\n      }\n      return data;\n    }\n    return data;\n  }\n\n  packet.data = _reconstructPacket(packet.data);\n  packet.attachments = undefined; // no longer useful\n  return packet;\n};\n\n/**\n * Asynchronously removes Blobs or Files from data via\n * FileReader's readAsArrayBuffer method. Used before encoding\n * data as msgpack. Calls callback with the blobless data.\n *\n * @param {Object} data\n * @param {Function} callback\n * @api private\n */\n\nexports.removeBlobs = function(data, callback) {\n  function _removeBlobs(obj, curKey, containingObject) {\n    if (!obj) return obj;\n\n    // convert any blob\n    if ((global.Blob && obj instanceof Blob) ||\n        (global.File && obj instanceof File)) {\n      pendingBlobs++;\n\n      // async filereader\n      var fileReader = new FileReader();\n      fileReader.onload = function() { // this.result == arraybuffer\n        if (containingObject) {\n          containingObject[curKey] = this.result;\n        }\n        else {\n          bloblessData = this.result;\n        }\n\n        // if nothing pending its callback time\n        if(! --pendingBlobs) {\n          callback(bloblessData);\n        }\n      };\n\n      fileReader.readAsArrayBuffer(obj); // blob -> arraybuffer\n    } else if (isArray(obj)) { // handle array\n      for (var i = 0; i < obj.length; i++) {\n        _removeBlobs(obj[i], i, obj);\n      }\n    } else if (obj && 'object' == typeof obj && !isBuf(obj)) { // and object\n      for (var key in obj) {\n        _removeBlobs(obj[key], key, obj);\n      }\n    }\n  }\n\n  var pendingBlobs = 0;\n  var bloblessData = data;\n  _removeBlobs(bloblessData);\n  if (!pendingBlobs) {\n    callback(bloblessData);\n  }\n};\n\n}).call(this,typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"./is-buffer\":47,\"isarray\":48}],46:[function(_dereq_,module,exports){\n\n/**\n * Module dependencies.\n */\n\nvar debug = _dereq_('debug')('socket.io-parser');\nvar json = _dereq_('json3');\nvar isArray = _dereq_('isarray');\nvar Emitter = _dereq_('component-emitter');\nvar binary = _dereq_('./binary');\nvar isBuf = _dereq_('./is-buffer');\n\n/**\n * Protocol version.\n *\n * @api public\n */\n\nexports.protocol = 4;\n\n/**\n * Packet types.\n *\n * @api public\n */\n\nexports.types = [\n  'CONNECT',\n  'DISCONNECT',\n  'EVENT',\n  'BINARY_EVENT',\n  'ACK',\n  'BINARY_ACK',\n  'ERROR'\n];\n\n/**\n * Packet type `connect`.\n *\n * @api public\n */\n\nexports.CONNECT = 0;\n\n/**\n * Packet type `disconnect`.\n *\n * @api public\n */\n\nexports.DISCONNECT = 1;\n\n/**\n * Packet type `event`.\n *\n * @api public\n */\n\nexports.EVENT = 2;\n\n/**\n * Packet type `ack`.\n *\n * @api public\n */\n\nexports.ACK = 3;\n\n/**\n * Packet type `error`.\n *\n * @api public\n */\n\nexports.ERROR = 4;\n\n/**\n * Packet type 'binary event'\n *\n * @api public\n */\n\nexports.BINARY_EVENT = 5;\n\n/**\n * Packet type `binary ack`. For acks with binary arguments.\n *\n * @api public\n */\n\nexports.BINARY_ACK = 6;\n\n/**\n * Encoder constructor.\n *\n * @api public\n */\n\nexports.Encoder = Encoder;\n\n/**\n * Decoder constructor.\n *\n * @api public\n */\n\nexports.Decoder = Decoder;\n\n/**\n * A socket.io Encoder instance\n *\n * @api public\n */\n\nfunction Encoder() {}\n\n/**\n * Encode a packet as a single string if non-binary, or as a\n * buffer sequence, depending on packet type.\n *\n * @param {Object} obj - packet object\n * @param {Function} callback - function to handle encodings (likely engine.write)\n * @return Calls callback with Array of encodings\n * @api public\n */\n\nEncoder.prototype.encode = function(obj, callback){\n  debug('encoding packet %j', obj);\n\n  if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {\n    encodeAsBinary(obj, callback);\n  }\n  else {\n    var encoding = encodeAsString(obj);\n    callback([encoding]);\n  }\n};\n\n/**\n * Encode packet as string.\n *\n * @param {Object} packet\n * @return {String} encoded\n * @api private\n */\n\nfunction encodeAsString(obj) {\n  var str = '';\n  var nsp = false;\n\n  // first is type\n  str += obj.type;\n\n  // attachments if we have them\n  if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {\n    str += obj.attachments;\n    str += '-';\n  }\n\n  // if we have a namespace other than `/`\n  // we append it followed by a comma `,`\n  if (obj.nsp && '/' != obj.nsp) {\n    nsp = true;\n    str += obj.nsp;\n  }\n\n  // immediately followed by the id\n  if (null != obj.id) {\n    if (nsp) {\n      str += ',';\n      nsp = false;\n    }\n    str += obj.id;\n  }\n\n  // json data\n  if (null != obj.data) {\n    if (nsp) str += ',';\n    str += json.stringify(obj.data);\n  }\n\n  debug('encoded %j as %s', obj, str);\n  return str;\n}\n\n/**\n * Encode packet as 'buffer sequence' by removing blobs, and\n * deconstructing packet into object with placeholders and\n * a list of buffers.\n *\n * @param {Object} packet\n * @return {Buffer} encoded\n * @api private\n */\n\nfunction encodeAsBinary(obj, callback) {\n\n  function writeEncoding(bloblessData) {\n    var deconstruction = binary.deconstructPacket(bloblessData);\n    var pack = encodeAsString(deconstruction.packet);\n    var buffers = deconstruction.buffers;\n\n    buffers.unshift(pack); // add packet info to beginning of data list\n    callback(buffers); // write all the buffers\n  }\n\n  binary.removeBlobs(obj, writeEncoding);\n}\n\n/**\n * A socket.io Decoder instance\n *\n * @return {Object} decoder\n * @api public\n */\n\nfunction Decoder() {\n  this.reconstructor = null;\n}\n\n/**\n * Mix in `Emitter` with Decoder.\n */\n\nEmitter(Decoder.prototype);\n\n/**\n * Decodes an ecoded packet string into packet JSON.\n *\n * @param {String} obj - encoded packet\n * @return {Object} packet\n * @api public\n */\n\nDecoder.prototype.add = function(obj) {\n  var packet;\n  if ('string' == typeof obj) {\n    packet = decodeString(obj);\n    if (exports.BINARY_EVENT == packet.type || exports.BINARY_ACK == packet.type) { // binary packet's json\n      this.reconstructor = new BinaryReconstructor(packet);\n\n      // no attachments, labeled binary but no binary data to follow\n      if (this.reconstructor.reconPack.attachments === 0) {\n        this.emit('decoded', packet);\n      }\n    } else { // non-binary full packet\n      this.emit('decoded', packet);\n    }\n  }\n  else if (isBuf(obj) || obj.base64) { // raw binary data\n    if (!this.reconstructor) {\n      throw new Error('got binary data when not reconstructing a packet');\n    } else {\n      packet = this.reconstructor.takeBinaryData(obj);\n      if (packet) { // received final buffer\n        this.reconstructor = null;\n        this.emit('decoded', packet);\n      }\n    }\n  }\n  else {\n    throw new Error('Unknown type: ' + obj);\n  }\n};\n\n/**\n * Decode a packet String (JSON data)\n *\n * @param {String} str\n * @return {Object} packet\n * @api private\n */\n\nfunction decodeString(str) {\n  var p = {};\n  var i = 0;\n\n  // look up type\n  p.type = Number(str.charAt(0));\n  if (null == exports.types[p.type]) return error();\n\n  // look up attachments if type binary\n  if (exports.BINARY_EVENT == p.type || exports.BINARY_ACK == p.type) {\n    var buf = '';\n    while (str.charAt(++i) != '-') {\n      buf += str.charAt(i);\n      if (i == str.length) break;\n    }\n    if (buf != Number(buf) || str.charAt(i) != '-') {\n      throw new Error('Illegal attachments');\n    }\n    p.attachments = Number(buf);\n  }\n\n  // look up namespace (if any)\n  if ('/' == str.charAt(i + 1)) {\n    p.nsp = '';\n    while (++i) {\n      var c = str.charAt(i);\n      if (',' == c) break;\n      p.nsp += c;\n      if (i == str.length) break;\n    }\n  } else {\n    p.nsp = '/';\n  }\n\n  // look up id\n  var next = str.charAt(i + 1);\n  if ('' !== next && Number(next) == next) {\n    p.id = '';\n    while (++i) {\n      var c = str.charAt(i);\n      if (null == c || Number(c) != c) {\n        --i;\n        break;\n      }\n      p.id += str.charAt(i);\n      if (i == str.length) break;\n    }\n    p.id = Number(p.id);\n  }\n\n  // look up json data\n  if (str.charAt(++i)) {\n    try {\n      p.data = json.parse(str.substr(i));\n    } catch(e){\n      return error();\n    }\n  }\n\n  debug('decoded %s as %j', str, p);\n  return p;\n}\n\n/**\n * Deallocates a parser's resources\n *\n * @api public\n */\n\nDecoder.prototype.destroy = function() {\n  if (this.reconstructor) {\n    this.reconstructor.finishedReconstruction();\n  }\n};\n\n/**\n * A manager of a binary event's 'buffer sequence'. Should\n * be constructed whenever a packet of type BINARY_EVENT is\n * decoded.\n *\n * @param {Object} packet\n * @return {BinaryReconstructor} initialized reconstructor\n * @api private\n */\n\nfunction BinaryReconstructor(packet) {\n  this.reconPack = packet;\n  this.buffers = [];\n}\n\n/**\n * Method to be called when binary data received from connection\n * after a BINARY_EVENT packet.\n *\n * @param {Buffer | ArrayBuffer} binData - the raw binary data received\n * @return {null | Object} returns null if more binary data is expected or\n *   a reconstructed packet object if all buffers have been received.\n * @api private\n */\n\nBinaryReconstructor.prototype.takeBinaryData = function(binData) {\n  this.buffers.push(binData);\n  if (this.buffers.length == this.reconPack.attachments) { // done with buffer list\n    var packet = binary.reconstructPacket(this.reconPack, this.buffers);\n    this.finishedReconstruction();\n    return packet;\n  }\n  return null;\n};\n\n/**\n * Cleans up binary packet reconstruction variables.\n *\n * @api private\n */\n\nBinaryReconstructor.prototype.finishedReconstruction = function() {\n  this.reconPack = null;\n  this.buffers = [];\n};\n\nfunction error(data){\n  return {\n    type: exports.ERROR,\n    data: 'parser error'\n  };\n}\n\n},{\"./binary\":45,\"./is-buffer\":47,\"component-emitter\":9,\"debug\":10,\"isarray\":48,\"json3\":49}],47:[function(_dereq_,module,exports){\n(function (global){\n\nmodule.exports = isBuf;\n\n/**\n * Returns true if obj is a buffer or an arraybuffer.\n *\n * @api private\n */\n\nfunction isBuf(obj) {\n  return (global.Buffer && global.Buffer.isBuffer(obj)) ||\n         (global.ArrayBuffer && obj instanceof ArrayBuffer);\n}\n\n}).call(this,typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}],48:[function(_dereq_,module,exports){\nmodule.exports=_dereq_(32)\n},{}],49:[function(_dereq_,module,exports){\n/*! JSON v3.2.6 | http://bestiejs.github.io/json3 | Copyright 2012-2013, Kit Cambridge | http://kit.mit-license.org */\n;(function (window) {\n  // Convenience aliases.\n  var getClass = {}.toString, isProperty, forEach, undef;\n\n  // Detect the `define` function exposed by asynchronous module loaders. The\n  // strict `define` check is necessary for compatibility with `r.js`.\n  var isLoader = typeof define === \"function\" && define.amd;\n\n  // Detect native implementations.\n  var nativeJSON = typeof JSON == \"object\" && JSON;\n\n  // Set up the JSON 3 namespace, preferring the CommonJS `exports` object if\n  // available.\n  var JSON3 = typeof exports == \"object\" && exports && !exports.nodeType && exports;\n\n  if (JSON3 && nativeJSON) {\n    // Explicitly delegate to the native `stringify` and `parse`\n    // implementations in CommonJS environments.\n    JSON3.stringify = nativeJSON.stringify;\n    JSON3.parse = nativeJSON.parse;\n  } else {\n    // Export for web browsers, JavaScript engines, and asynchronous module\n    // loaders, using the global `JSON` object if available.\n    JSON3 = window.JSON = nativeJSON || {};\n  }\n\n  // Test the `Date#getUTC*` methods. Based on work by @Yaffle.\n  var isExtended = new Date(-3509827334573292);\n  try {\n    // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical\n    // results for certain dates in Opera >= 10.53.\n    isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 &&\n      // Safari < 2.0.2 stores the internal millisecond time value correctly,\n      // but clips the values returned by the date methods to the range of\n      // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).\n      isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;\n  } catch (exception) {}\n\n  // Internal: Determines whether the native `JSON.stringify` and `parse`\n  // implementations are spec-compliant. Based on work by Ken Snyder.\n  function has(name) {\n    if (has[name] !== undef) {\n      // Return cached feature test result.\n      return has[name];\n    }\n\n    var isSupported;\n    if (name == \"bug-string-char-index\") {\n      // IE <= 7 doesn't support accessing string characters using square\n      // bracket notation. IE 8 only supports this for primitives.\n      isSupported = \"a\"[0] != \"a\";\n    } else if (name == \"json\") {\n      // Indicates whether both `JSON.stringify` and `JSON.parse` are\n      // supported.\n      isSupported = has(\"json-stringify\") && has(\"json-parse\");\n    } else {\n      var value, serialized = '{\"a\":[1,true,false,null,\"\\\\u0000\\\\b\\\\n\\\\f\\\\r\\\\t\"]}';\n      // Test `JSON.stringify`.\n      if (name == \"json-stringify\") {\n        var stringify = JSON3.stringify, stringifySupported = typeof stringify == \"function\" && isExtended;\n        if (stringifySupported) {\n          // A test function object with a custom `toJSON` method.\n          (value = function () {\n            return 1;\n          }).toJSON = value;\n          try {\n            stringifySupported =\n              // Firefox 3.1b1 and b2 serialize string, number, and boolean\n              // primitives as object literals.\n              stringify(0) === \"0\" &&\n              // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object\n              // literals.\n              stringify(new Number()) === \"0\" &&\n              stringify(new String()) == '\"\"' &&\n              // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or\n              // does not define a canonical JSON representation (this applies to\n              // objects with `toJSON` properties as well, *unless* they are nested\n              // within an object or array).\n              stringify(getClass) === undef &&\n              // IE 8 serializes `undefined` as `\"undefined\"`. Safari <= 5.1.7 and\n              // FF 3.1b3 pass this test.\n              stringify(undef) === undef &&\n              // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,\n              // respectively, if the value is omitted entirely.\n              stringify() === undef &&\n              // FF 3.1b1, 2 throw an error if the given value is not a number,\n              // string, array, object, Boolean, or `null` literal. This applies to\n              // objects with custom `toJSON` methods as well, unless they are nested\n              // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`\n              // methods entirely.\n              stringify(value) === \"1\" &&\n              stringify([value]) == \"[1]\" &&\n              // Prototype <= 1.6.1 serializes `[undefined]` as `\"[]\"` instead of\n              // `\"[null]\"`.\n              stringify([undef]) == \"[null]\" &&\n              // YUI 3.0.0b1 fails to serialize `null` literals.\n              stringify(null) == \"null\" &&\n              // FF 3.1b1, 2 halts serialization if an array contains a function:\n              // `[1, true, getClass, 1]` serializes as \"[1,true,],\". FF 3.1b3\n              // elides non-JSON values from objects and arrays, unless they\n              // define custom `toJSON` methods.\n              stringify([undef, getClass, null]) == \"[null,null,null]\" &&\n              // Simple serialization test. FF 3.1b1 uses Unicode escape sequences\n              // where character escape codes are expected (e.g., `\\b` => `\\u0008`).\n              stringify({ \"a\": [value, true, false, null, \"\\x00\\b\\n\\f\\r\\t\"] }) == serialized &&\n              // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.\n              stringify(null, value) === \"1\" &&\n              stringify([1, 2], null, 1) == \"[\\n 1,\\n 2\\n]\" &&\n              // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly\n              // serialize extended years.\n              stringify(new Date(-8.64e15)) == '\"-271821-04-20T00:00:00.000Z\"' &&\n              // The milliseconds are optional in ES 5, but required in 5.1.\n              stringify(new Date(8.64e15)) == '\"+275760-09-13T00:00:00.000Z\"' &&\n              // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative\n              // four-digit years instead of six-digit years. Credits: @Yaffle.\n              stringify(new Date(-621987552e5)) == '\"-000001-01-01T00:00:00.000Z\"' &&\n              // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond\n              // values less than 1000. Credits: @Yaffle.\n              stringify(new Date(-1)) == '\"1969-12-31T23:59:59.999Z\"';\n          } catch (exception) {\n            stringifySupported = false;\n          }\n        }\n        isSupported = stringifySupported;\n      }\n      // Test `JSON.parse`.\n      if (name == \"json-parse\") {\n        var parse = JSON3.parse;\n        if (typeof parse == \"function\") {\n          try {\n            // FF 3.1b1, b2 will throw an exception if a bare literal is provided.\n            // Conforming implementations should also coerce the initial argument to\n            // a string prior to parsing.\n            if (parse(\"0\") === 0 && !parse(false)) {\n              // Simple parsing test.\n              value = parse(serialized);\n              var parseSupported = value[\"a\"].length == 5 && value[\"a\"][0] === 1;\n              if (parseSupported) {\n                try {\n                  // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.\n                  parseSupported = !parse('\"\\t\"');\n                } catch (exception) {}\n                if (parseSupported) {\n                  try {\n                    // FF 4.0 and 4.0.1 allow leading `+` signs and leading\n                    // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow\n                    // certain octal literals.\n                    parseSupported = parse(\"01\") !== 1;\n                  } catch (exception) {}\n                }\n                if (parseSupported) {\n                  try {\n                    // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal\n                    // points. These environments, along with FF 3.1b1 and 2,\n                    // also allow trailing commas in JSON objects and arrays.\n                    parseSupported = parse(\"1.\") !== 1;\n                  } catch (exception) {}\n                }\n              }\n            }\n          } catch (exception) {\n            parseSupported = false;\n          }\n        }\n        isSupported = parseSupported;\n      }\n    }\n    return has[name] = !!isSupported;\n  }\n\n  if (!has(\"json\")) {\n    // Common `[[Class]]` name aliases.\n    var functionClass = \"[object Function]\";\n    var dateClass = \"[object Date]\";\n    var numberClass = \"[object Number]\";\n    var stringClass = \"[object String]\";\n    var arrayClass = \"[object Array]\";\n    var booleanClass = \"[object Boolean]\";\n\n    // Detect incomplete support for accessing string characters by index.\n    var charIndexBuggy = has(\"bug-string-char-index\");\n\n    // Define additional utility methods if the `Date` methods are buggy.\n    if (!isExtended) {\n      var floor = Math.floor;\n      // A mapping between the months of the year and the number of days between\n      // January 1st and the first of the respective month.\n      var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];\n      // Internal: Calculates the number of days between the Unix epoch and the\n      // first day of the given month.\n      var getDay = function (year, month) {\n        return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);\n      };\n    }\n\n    // Internal: Determines if a property is a direct property of the given\n    // object. Delegates to the native `Object#hasOwnProperty` method.\n    if (!(isProperty = {}.hasOwnProperty)) {\n      isProperty = function (property) {\n        var members = {}, constructor;\n        if ((members.__proto__ = null, members.__proto__ = {\n          // The *proto* property cannot be set multiple times in recent\n          // versions of Firefox and SeaMonkey.\n          \"toString\": 1\n        }, members).toString != getClass) {\n          // Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but\n          // supports the mutable *proto* property.\n          isProperty = function (property) {\n            // Capture and break the object's prototype chain (see section 8.6.2\n            // of the ES 5.1 spec). The parenthesized expression prevents an\n            // unsafe transformation by the Closure Compiler.\n            var original = this.__proto__, result = property in (this.__proto__ = null, this);\n            // Restore the original prototype chain.\n            this.__proto__ = original;\n            return result;\n          };\n        } else {\n          // Capture a reference to the top-level `Object` constructor.\n          constructor = members.constructor;\n          // Use the `constructor` property to simulate `Object#hasOwnProperty` in\n          // other environments.\n          isProperty = function (property) {\n            var parent = (this.constructor || constructor).prototype;\n            return property in this && !(property in parent && this[property] === parent[property]);\n          };\n        }\n        members = null;\n        return isProperty.call(this, property);\n      };\n    }\n\n    // Internal: A set of primitive types used by `isHostType`.\n    var PrimitiveTypes = {\n      'boolean': 1,\n      'number': 1,\n      'string': 1,\n      'undefined': 1\n    };\n\n    // Internal: Determines if the given object `property` value is a\n    // non-primitive.\n    var isHostType = function (object, property) {\n      var type = typeof object[property];\n      return type == 'object' ? !!object[property] : !PrimitiveTypes[type];\n    };\n\n    // Internal: Normalizes the `for...in` iteration algorithm across\n    // environments. Each enumerated key is yielded to a `callback` function.\n    forEach = function (object, callback) {\n      var size = 0, Properties, members, property;\n\n      // Tests for bugs in the current environment's `for...in` algorithm. The\n      // `valueOf` property inherits the non-enumerable flag from\n      // `Object.prototype` in older versions of IE, Netscape, and Mozilla.\n      (Properties = function () {\n        this.valueOf = 0;\n      }).prototype.valueOf = 0;\n\n      // Iterate over a new instance of the `Properties` class.\n      members = new Properties();\n      for (property in members) {\n        // Ignore all properties inherited from `Object.prototype`.\n        if (isProperty.call(members, property)) {\n          size++;\n        }\n      }\n      Properties = members = null;\n\n      // Normalize the iteration algorithm.\n      if (!size) {\n        // A list of non-enumerable properties inherited from `Object.prototype`.\n        members = [\"valueOf\", \"toString\", \"toLocaleString\", \"propertyIsEnumerable\", \"isPrototypeOf\", \"hasOwnProperty\", \"constructor\"];\n        // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable\n        // properties.\n        forEach = function (object, callback) {\n          var isFunction = getClass.call(object) == functionClass, property, length;\n          var hasProperty = !isFunction && typeof object.constructor != 'function' && isHostType(object, 'hasOwnProperty') ? object.hasOwnProperty : isProperty;\n          for (property in object) {\n            // Gecko <= 1.0 enumerates the `prototype` property of functions under\n            // certain conditions; IE does not.\n            if (!(isFunction && property == \"prototype\") && hasProperty.call(object, property)) {\n              callback(property);\n            }\n          }\n          // Manually invoke the callback for each non-enumerable property.\n          for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property));\n        };\n      } else if (size == 2) {\n        // Safari <= 2.0.4 enumerates shadowed properties twice.\n        forEach = function (object, callback) {\n          // Create a set of iterated properties.\n          var members = {}, isFunction = getClass.call(object) == functionClass, property;\n          for (property in object) {\n            // Store each property name to prevent double enumeration. The\n            // `prototype` property of functions is not enumerated due to cross-\n            // environment inconsistencies.\n            if (!(isFunction && property == \"prototype\") && !isProperty.call(members, property) && (members[property] = 1) && isProperty.call(object, property)) {\n              callback(property);\n            }\n          }\n        };\n      } else {\n        // No bugs detected; use the standard `for...in` algorithm.\n        forEach = function (object, callback) {\n          var isFunction = getClass.call(object) == functionClass, property, isConstructor;\n          for (property in object) {\n            if (!(isFunction && property == \"prototype\") && isProperty.call(object, property) && !(isConstructor = property === \"constructor\")) {\n              callback(property);\n            }\n          }\n          // Manually invoke the callback for the `constructor` property due to\n          // cross-environment inconsistencies.\n          if (isConstructor || isProperty.call(object, (property = \"constructor\"))) {\n            callback(property);\n          }\n        };\n      }\n      return forEach(object, callback);\n    };\n\n    // Public: Serializes a JavaScript `value` as a JSON string. The optional\n    // `filter` argument may specify either a function that alters how object and\n    // array members are serialized, or an array of strings and numbers that\n    // indicates which properties should be serialized. The optional `width`\n    // argument may be either a string or number that specifies the indentation\n    // level of the output.\n    if (!has(\"json-stringify\")) {\n      // Internal: A map of control characters and their escaped equivalents.\n      var Escapes = {\n        92: \"\\\\\\\\\",\n        34: '\\\\\"',\n        8: \"\\\\b\",\n        12: \"\\\\f\",\n        10: \"\\\\n\",\n        13: \"\\\\r\",\n        9: \"\\\\t\"\n      };\n\n      // Internal: Converts `value` into a zero-padded string such that its\n      // length is at least equal to `width`. The `width` must be <= 6.\n      var leadingZeroes = \"000000\";\n      var toPaddedString = function (width, value) {\n        // The `|| 0` expression is necessary to work around a bug in\n        // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== \"0\"`.\n        return (leadingZeroes + (value || 0)).slice(-width);\n      };\n\n      // Internal: Double-quotes a string `value`, replacing all ASCII control\n      // characters (characters with code unit values between 0 and 31) with\n      // their escaped equivalents. This is an implementation of the\n      // `Quote(value)` operation defined in ES 5.1 section 15.12.3.\n      var unicodePrefix = \"\\\\u00\";\n      var quote = function (value) {\n        var result = '\"', index = 0, length = value.length, isLarge = length > 10 && charIndexBuggy, symbols;\n        if (isLarge) {\n          symbols = value.split(\"\");\n        }\n        for (; index < length; index++) {\n          var charCode = value.charCodeAt(index);\n          // If the character is a control character, append its Unicode or\n          // shorthand escape sequence; otherwise, append the character as-is.\n          switch (charCode) {\n            case 8: case 9: case 10: case 12: case 13: case 34: case 92:\n              result += Escapes[charCode];\n              break;\n            default:\n              if (charCode < 32) {\n                result += unicodePrefix + toPaddedString(2, charCode.toString(16));\n                break;\n              }\n              result += isLarge ? symbols[index] : charIndexBuggy ? value.charAt(index) : value[index];\n          }\n        }\n        return result + '\"';\n      };\n\n      // Internal: Recursively serializes an object. Implements the\n      // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.\n      var serialize = function (property, object, callback, properties, whitespace, indentation, stack) {\n        var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;\n        try {\n          // Necessary for host object support.\n          value = object[property];\n        } catch (exception) {}\n        if (typeof value == \"object\" && value) {\n          className = getClass.call(value);\n          if (className == dateClass && !isProperty.call(value, \"toJSON\")) {\n            if (value > -1 / 0 && value < 1 / 0) {\n              // Dates are serialized according to the `Date#toJSON` method\n              // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15\n              // for the ISO 8601 date time string format.\n              if (getDay) {\n                // Manually compute the year, month, date, hours, minutes,\n                // seconds, and milliseconds if the `getUTC*` methods are\n                // buggy. Adapted from @Yaffle's `date-shim` project.\n                date = floor(value / 864e5);\n                for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++);\n                for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++);\n                date = 1 + date - getDay(year, month);\n                // The `time` value specifies the time within the day (see ES\n                // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used\n                // to compute `A modulo B`, as the `%` operator does not\n                // correspond to the `modulo` operation for negative numbers.\n                time = (value % 864e5 + 864e5) % 864e5;\n                // The hours, minutes, seconds, and milliseconds are obtained by\n                // decomposing the time within the day. See section 15.9.1.10.\n                hours = floor(time / 36e5) % 24;\n                minutes = floor(time / 6e4) % 60;\n                seconds = floor(time / 1e3) % 60;\n                milliseconds = time % 1e3;\n              } else {\n                year = value.getUTCFullYear();\n                month = value.getUTCMonth();\n                date = value.getUTCDate();\n                hours = value.getUTCHours();\n                minutes = value.getUTCMinutes();\n                seconds = value.getUTCSeconds();\n                milliseconds = value.getUTCMilliseconds();\n              }\n              // Serialize extended years correctly.\n              value = (year <= 0 || year >= 1e4 ? (year < 0 ? \"-\" : \"+\") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) +\n                \"-\" + toPaddedString(2, month + 1) + \"-\" + toPaddedString(2, date) +\n                // Months, dates, hours, minutes, and seconds should have two\n                // digits; milliseconds should have three.\n                \"T\" + toPaddedString(2, hours) + \":\" + toPaddedString(2, minutes) + \":\" + toPaddedString(2, seconds) +\n                // Milliseconds are optional in ES 5.0, but required in 5.1.\n                \".\" + toPaddedString(3, milliseconds) + \"Z\";\n            } else {\n              value = null;\n            }\n          } else if (typeof value.toJSON == \"function\" && ((className != numberClass && className != stringClass && className != arrayClass) || isProperty.call(value, \"toJSON\"))) {\n            // Prototype <= 1.6.1 adds non-standard `toJSON` methods to the\n            // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3\n            // ignores all `toJSON` methods on these objects unless they are\n            // defined directly on an instance.\n            value = value.toJSON(property);\n          }\n        }\n        if (callback) {\n          // If a replacement function was provided, call it to obtain the value\n          // for serialization.\n          value = callback.call(object, property, value);\n        }\n        if (value === null) {\n          return \"null\";\n        }\n        className = getClass.call(value);\n        if (className == booleanClass) {\n          // Booleans are represented literally.\n          return \"\" + value;\n        } else if (className == numberClass) {\n          // JSON numbers must be finite. `Infinity` and `NaN` are serialized as\n          // `\"null\"`.\n          return value > -1 / 0 && value < 1 / 0 ? \"\" + value : \"null\";\n        } else if (className == stringClass) {\n          // Strings are double-quoted and escaped.\n          return quote(\"\" + value);\n        }\n        // Recursively serialize objects and arrays.\n        if (typeof value == \"object\") {\n          // Check for cyclic structures. This is a linear search; performance\n          // is inversely proportional to the number of unique nested objects.\n          for (length = stack.length; length--;) {\n            if (stack[length] === value) {\n              // Cyclic structures cannot be serialized by `JSON.stringify`.\n              throw TypeError();\n            }\n          }\n          // Add the object to the stack of traversed objects.\n          stack.push(value);\n          results = [];\n          // Save the current indentation level and indent one additional level.\n          prefix = indentation;\n          indentation += whitespace;\n          if (className == arrayClass) {\n            // Recursively serialize array elements.\n            for (index = 0, length = value.length; index < length; index++) {\n              element = serialize(index, value, callback, properties, whitespace, indentation, stack);\n              results.push(element === undef ? \"null\" : element);\n            }\n            result = results.length ? (whitespace ? \"[\\n\" + indentation + results.join(\",\\n\" + indentation) + \"\\n\" + prefix + \"]\" : (\"[\" + results.join(\",\") + \"]\")) : \"[]\";\n          } else {\n            // Recursively serialize object members. Members are selected from\n            // either a user-specified list of property names, or the object\n            // itself.\n            forEach(properties || value, function (property) {\n              var element = serialize(property, value, callback, properties, whitespace, indentation, stack);\n              if (element !== undef) {\n                // According to ES 5.1 section 15.12.3: \"If `gap` {whitespace}\n                // is not the empty string, let `member` {quote(property) + \":\"}\n                // be the concatenation of `member` and the `space` character.\"\n                // The \"`space` character\" refers to the literal space\n                // character, not the `space` {width} argument provided to\n                // `JSON.stringify`.\n                results.push(quote(property) + \":\" + (whitespace ? \" \" : \"\") + element);\n              }\n            });\n            result = results.length ? (whitespace ? \"{\\n\" + indentation + results.join(\",\\n\" + indentation) + \"\\n\" + prefix + \"}\" : (\"{\" + results.join(\",\") + \"}\")) : \"{}\";\n          }\n          // Remove the object from the traversed object stack.\n          stack.pop();\n          return result;\n        }\n      };\n\n      // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.\n      JSON3.stringify = function (source, filter, width) {\n        var whitespace, callback, properties, className;\n        if (typeof filter == \"function\" || typeof filter == \"object\" && filter) {\n          if ((className = getClass.call(filter)) == functionClass) {\n            callback = filter;\n          } else if (className == arrayClass) {\n            // Convert the property names array into a makeshift set.\n            properties = {};\n            for (var index = 0, length = filter.length, value; index < length; value = filter[index++], ((className = getClass.call(value)), className == stringClass || className == numberClass) && (properties[value] = 1));\n          }\n        }\n        if (width) {\n          if ((className = getClass.call(width)) == numberClass) {\n            // Convert the `width` to an integer and create a string containing\n            // `width` number of space characters.\n            if ((width -= width % 1) > 0) {\n              for (whitespace = \"\", width > 10 && (width = 10); whitespace.length < width; whitespace += \" \");\n            }\n          } else if (className == stringClass) {\n            whitespace = width.length <= 10 ? width : width.slice(0, 10);\n          }\n        }\n        // Opera <= 7.54u2 discards the values associated with empty string keys\n        // (`\"\"`) only if they are used directly within an object member list\n        // (e.g., `!(\"\" in { \"\": 1})`).\n        return serialize(\"\", (value = {}, value[\"\"] = source, value), callback, properties, whitespace, \"\", []);\n      };\n    }\n\n    // Public: Parses a JSON source string.\n    if (!has(\"json-parse\")) {\n      var fromCharCode = String.fromCharCode;\n\n      // Internal: A map of escaped control characters and their unescaped\n      // equivalents.\n      var Unescapes = {\n        92: \"\\\\\",\n        34: '\"',\n        47: \"/\",\n        98: \"\\b\",\n        116: \"\\t\",\n        110: \"\\n\",\n        102: \"\\f\",\n        114: \"\\r\"\n      };\n\n      // Internal: Stores the parser state.\n      var Index, Source;\n\n      // Internal: Resets the parser state and throws a `SyntaxError`.\n      var abort = function() {\n        Index = Source = null;\n        throw SyntaxError();\n      };\n\n      // Internal: Returns the next token, or `\"$\"` if the parser has reached\n      // the end of the source string. A token may be a string, number, `null`\n      // literal, or Boolean literal.\n      var lex = function () {\n        var source = Source, length = source.length, value, begin, position, isSigned, charCode;\n        while (Index < length) {\n          charCode = source.charCodeAt(Index);\n          switch (charCode) {\n            case 9: case 10: case 13: case 32:\n              // Skip whitespace tokens, including tabs, carriage returns, line\n              // feeds, and space characters.\n              Index++;\n              break;\n            case 123: case 125: case 91: case 93: case 58: case 44:\n              // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at\n              // the current position.\n              value = charIndexBuggy ? source.charAt(Index) : source[Index];\n              Index++;\n              return value;\n            case 34:\n              // `\"` delimits a JSON string; advance to the next character and\n              // begin parsing the string. String tokens are prefixed with the\n              // sentinel `@` character to distinguish them from punctuators and\n              // end-of-string tokens.\n              for (value = \"@\", Index++; Index < length;) {\n                charCode = source.charCodeAt(Index);\n                if (charCode < 32) {\n                  // Unescaped ASCII control characters (those with a code unit\n                  // less than the space character) are not permitted.\n                  abort();\n                } else if (charCode == 92) {\n                  // A reverse solidus (`\\`) marks the beginning of an escaped\n                  // control character (including `\"`, `\\`, and `/`) or Unicode\n                  // escape sequence.\n                  charCode = source.charCodeAt(++Index);\n                  switch (charCode) {\n                    case 92: case 34: case 47: case 98: case 116: case 110: case 102: case 114:\n                      // Revive escaped control characters.\n                      value += Unescapes[charCode];\n                      Index++;\n                      break;\n                    case 117:\n                      // `\\u` marks the beginning of a Unicode escape sequence.\n                      // Advance to the first character and validate the\n                      // four-digit code point.\n                      begin = ++Index;\n                      for (position = Index + 4; Index < position; Index++) {\n                        charCode = source.charCodeAt(Index);\n                        // A valid sequence comprises four hexdigits (case-\n                        // insensitive) that form a single hexadecimal value.\n                        if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {\n                          // Invalid Unicode escape sequence.\n                          abort();\n                        }\n                      }\n                      // Revive the escaped character.\n                      value += fromCharCode(\"0x\" + source.slice(begin, Index));\n                      break;\n                    default:\n                      // Invalid escape sequence.\n                      abort();\n                  }\n                } else {\n                  if (charCode == 34) {\n                    // An unescaped double-quote character marks the end of the\n                    // string.\n                    break;\n                  }\n                  charCode = source.charCodeAt(Index);\n                  begin = Index;\n                  // Optimize for the common case where a string is valid.\n                  while (charCode >= 32 && charCode != 92 && charCode != 34) {\n                    charCode = source.charCodeAt(++Index);\n                  }\n                  // Append the string as-is.\n                  value += source.slice(begin, Index);\n                }\n              }\n              if (source.charCodeAt(Index) == 34) {\n                // Advance to the next character and return the revived string.\n                Index++;\n                return value;\n              }\n              // Unterminated string.\n              abort();\n            default:\n              // Parse numbers and literals.\n              begin = Index;\n              // Advance past the negative sign, if one is specified.\n              if (charCode == 45) {\n                isSigned = true;\n                charCode = source.charCodeAt(++Index);\n              }\n              // Parse an integer or floating-point value.\n              if (charCode >= 48 && charCode <= 57) {\n                // Leading zeroes are interpreted as octal literals.\n                if (charCode == 48 && ((charCode = source.charCodeAt(Index + 1)), charCode >= 48 && charCode <= 57)) {\n                  // Illegal octal literal.\n                  abort();\n                }\n                isSigned = false;\n                // Parse the integer component.\n                for (; Index < length && ((charCode = source.charCodeAt(Index)), charCode >= 48 && charCode <= 57); Index++);\n                // Floats cannot contain a leading decimal point; however, this\n                // case is already accounted for by the parser.\n                if (source.charCodeAt(Index) == 46) {\n                  position = ++Index;\n                  // Parse the decimal component.\n                  for (; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);\n                  if (position == Index) {\n                    // Illegal trailing decimal.\n                    abort();\n                  }\n                  Index = position;\n                }\n                // Parse exponents. The `e` denoting the exponent is\n                // case-insensitive.\n                charCode = source.charCodeAt(Index);\n                if (charCode == 101 || charCode == 69) {\n                  charCode = source.charCodeAt(++Index);\n                  // Skip past the sign following the exponent, if one is\n                  // specified.\n                  if (charCode == 43 || charCode == 45) {\n                    Index++;\n                  }\n                  // Parse the exponential component.\n                  for (position = Index; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);\n                  if (position == Index) {\n                    // Illegal empty exponent.\n                    abort();\n                  }\n                  Index = position;\n                }\n                // Coerce the parsed value to a JavaScript number.\n                return +source.slice(begin, Index);\n              }\n              // A negative sign may only precede numbers.\n              if (isSigned) {\n                abort();\n              }\n              // `true`, `false`, and `null` literals.\n              if (source.slice(Index, Index + 4) == \"true\") {\n                Index += 4;\n                return true;\n              } else if (source.slice(Index, Index + 5) == \"false\") {\n                Index += 5;\n                return false;\n              } else if (source.slice(Index, Index + 4) == \"null\") {\n                Index += 4;\n                return null;\n              }\n              // Unrecognized token.\n              abort();\n          }\n        }\n        // Return the sentinel `$` character if the parser has reached the end\n        // of the source string.\n        return \"$\";\n      };\n\n      // Internal: Parses a JSON `value` token.\n      var get = function (value) {\n        var results, hasMembers;\n        if (value == \"$\") {\n          // Unexpected end of input.\n          abort();\n        }\n        if (typeof value == \"string\") {\n          if ((charIndexBuggy ? value.charAt(0) : value[0]) == \"@\") {\n            // Remove the sentinel `@` character.\n            return value.slice(1);\n          }\n          // Parse object and array literals.\n          if (value == \"[\") {\n            // Parses a JSON array, returning a new JavaScript array.\n            results = [];\n            for (;; hasMembers || (hasMembers = true)) {\n              value = lex();\n              // A closing square bracket marks the end of the array literal.\n              if (value == \"]\") {\n                break;\n              }\n              // If the array literal contains elements, the current token\n              // should be a comma separating the previous element from the\n              // next.\n              if (hasMembers) {\n                if (value == \",\") {\n                  value = lex();\n                  if (value == \"]\") {\n                    // Unexpected trailing `,` in array literal.\n                    abort();\n                  }\n                } else {\n                  // A `,` must separate each array element.\n                  abort();\n                }\n              }\n              // Elisions and leading commas are not permitted.\n              if (value == \",\") {\n                abort();\n              }\n              results.push(get(value));\n            }\n            return results;\n          } else if (value == \"{\") {\n            // Parses a JSON object, returning a new JavaScript object.\n            results = {};\n            for (;; hasMembers || (hasMembers = true)) {\n              value = lex();\n              // A closing curly brace marks the end of the object literal.\n              if (value == \"}\") {\n                break;\n              }\n              // If the object literal contains members, the current token\n              // should be a comma separator.\n              if (hasMembers) {\n                if (value == \",\") {\n                  value = lex();\n                  if (value == \"}\") {\n                    // Unexpected trailing `,` in object literal.\n                    abort();\n                  }\n                } else {\n                  // A `,` must separate each object member.\n                  abort();\n                }\n              }\n              // Leading commas are not permitted, object property names must be\n              // double-quoted strings, and a `:` must separate each property\n              // name and value.\n              if (value == \",\" || typeof value != \"string\" || (charIndexBuggy ? value.charAt(0) : value[0]) != \"@\" || lex() != \":\") {\n                abort();\n              }\n              results[value.slice(1)] = get(lex());\n            }\n            return results;\n          }\n          // Unexpected token encountered.\n          abort();\n        }\n        return value;\n      };\n\n      // Internal: Updates a traversed object member.\n      var update = function(source, property, callback) {\n        var element = walk(source, property, callback);\n        if (element === undef) {\n          delete source[property];\n        } else {\n          source[property] = element;\n        }\n      };\n\n      // Internal: Recursively traverses a parsed JSON object, invoking the\n      // `callback` function for each value. This is an implementation of the\n      // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.\n      var walk = function (source, property, callback) {\n        var value = source[property], length;\n        if (typeof value == \"object\" && value) {\n          // `forEach` can't be used to traverse an array in Opera <= 8.54\n          // because its `Object#hasOwnProperty` implementation returns `false`\n          // for array indices (e.g., `![1, 2, 3].hasOwnProperty(\"0\")`).\n          if (getClass.call(value) == arrayClass) {\n            for (length = value.length; length--;) {\n              update(value, length, callback);\n            }\n          } else {\n            forEach(value, function (property) {\n              update(value, property, callback);\n            });\n          }\n        }\n        return callback.call(source, property, value);\n      };\n\n      // Public: `JSON.parse`. See ES 5.1 section 15.12.2.\n      JSON3.parse = function (source, callback) {\n        var result, value;\n        Index = 0;\n        Source = \"\" + source;\n        result = get(lex());\n        // If a JSON string contains multiple tokens, it is invalid.\n        if (lex() != \"$\") {\n          abort();\n        }\n        // Reset the parser state.\n        Index = Source = null;\n        return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[\"\"] = result, value), \"\", callback) : result;\n      };\n    }\n  }\n\n  // Export for asynchronous module loaders.\n  if (isLoader) {\n    define(function () {\n      return JSON3;\n    });\n  }\n}(this));\n\n},{}],50:[function(_dereq_,module,exports){\nmodule.exports = toArray\n\nfunction toArray(list, index) {\n    var array = []\n\n    index = index || 0\n\n    for (var i = index || 0; i < list.length; i++) {\n        array[i - index] = list[i]\n    }\n\n    return array\n}\n\n},{}]},{},[1])\n(1)\n});\n","Vue.http.headers.common['X-CSRF-TOKEN'] = document.querySelector('#token').getAttribute('value');\n\nnew Vue({\n    el: '#guestbook',\n\n    data: {\n        newMessage: {\n            name: '',\n            email: '',\n            message: ''\n        },\n\n        submitted: false\n    },\n\n    computed: {\n        errors: function() {\n            for ( var key in this.newMessage) {\n                if ( ! this.newMessage[key]) return true;\n            }\n\n            return false;\n        }\n    },\n\n    ready: function() {\n        this.fetchMessages();\n    },\n\n    methods: {\n        fetchMessages: function() {\n            this.$http.get('api/messages', function(messages) {\n                this.$set('messages', messages);\n            })\n        },\n\n        onSubmitForm: function(e) {\n            e.preventDefault();\n\n            var message = this.newMessage;\n\n            this.messages.push(message);\n\n            this.newMessage = { name: '', email: '', message: '' };\n\n            this.submitted = true;\n\n            this.$http.post('api/messages', message);\n        }\n    }\n});"],"sourceRoot":"/source/"}